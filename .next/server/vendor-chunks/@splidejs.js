"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@splidejs";
exports.ids = ["vendor-chunks/@splidejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@splidejs/react-splide/dist/js/react-splide.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@splidejs/react-splide/dist/js/react-splide.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Splide: () => (/* binding */ Splide2),\n/* harmony export */   SplideSlide: () => (/* binding */ SplideSlide),\n/* harmony export */   SplideTrack: () => (/* binding */ SplideTrack)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// node_modules/@splidejs/splide/dist/js/splide.esm.js\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nvar MEDIA_PREFERS_REDUCED_MOTION = \"(prefers-reduced-motion: reduce)\";\nvar CREATED = 1;\nvar MOUNTED = 2;\nvar IDLE = 3;\nvar MOVING = 4;\nvar SCROLLING = 5;\nvar DRAGGING = 6;\nvar DESTROYED = 7;\nvar STATES = {\n    CREATED,\n    MOUNTED,\n    IDLE,\n    MOVING,\n    SCROLLING,\n    DRAGGING,\n    DESTROYED\n};\nfunction empty(array) {\n    array.length = 0;\n}\nfunction slice(arrayLike, start, end) {\n    return Array.prototype.slice.call(arrayLike, start, end);\n}\nfunction apply(func) {\n    return func.bind.apply(func, [\n        null\n    ].concat(slice(arguments, 1)));\n}\nvar nextTick = setTimeout;\nvar noop = function noop2() {};\nfunction raf(func) {\n    return requestAnimationFrame(func);\n}\nfunction typeOf(type, subject) {\n    return typeof subject === type;\n}\nfunction isObject(subject) {\n    return !isNull(subject) && typeOf(\"object\", subject);\n}\nvar isArray = Array.isArray;\nvar isFunction = apply(typeOf, \"function\");\nvar isString = apply(typeOf, \"string\");\nvar isUndefined = apply(typeOf, \"undefined\");\nfunction isNull(subject) {\n    return subject === null;\n}\nfunction isHTMLElement(subject) {\n    try {\n        return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;\n    } catch (e) {\n        return false;\n    }\n}\nfunction toArray(value) {\n    return isArray(value) ? value : [\n        value\n    ];\n}\nfunction forEach(values, iteratee) {\n    toArray(values).forEach(iteratee);\n}\nfunction includes(array, value) {\n    return array.indexOf(value) > -1;\n}\nfunction push(array, items) {\n    array.push.apply(array, toArray(items));\n    return array;\n}\nfunction toggleClass(elm, classes, add) {\n    if (elm) {\n        forEach(classes, function(name) {\n            if (name) {\n                elm.classList[add ? \"add\" : \"remove\"](name);\n            }\n        });\n    }\n}\nfunction addClass(elm, classes) {\n    toggleClass(elm, isString(classes) ? classes.split(\" \") : classes, true);\n}\nfunction append(parent, children2) {\n    forEach(children2, parent.appendChild.bind(parent));\n}\nfunction before(nodes, ref) {\n    forEach(nodes, function(node) {\n        var parent = (ref || node).parentNode;\n        if (parent) {\n            parent.insertBefore(node, ref);\n        }\n    });\n}\nfunction matches(elm, selector) {\n    return isHTMLElement(elm) && (elm[\"msMatchesSelector\"] || elm.matches).call(elm, selector);\n}\nfunction children(parent, selector) {\n    var children2 = parent ? slice(parent.children) : [];\n    return selector ? children2.filter(function(child2) {\n        return matches(child2, selector);\n    }) : children2;\n}\nfunction child(parent, selector) {\n    return selector ? children(parent, selector)[0] : parent.firstElementChild;\n}\nvar ownKeys = Object.keys;\nfunction forOwn(object, iteratee, right) {\n    if (object) {\n        (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function(key) {\n            key !== \"__proto__\" && iteratee(object[key], key);\n        });\n    }\n    return object;\n}\nfunction assign(object) {\n    slice(arguments, 1).forEach(function(source) {\n        forOwn(source, function(value, key) {\n            object[key] = source[key];\n        });\n    });\n    return object;\n}\nfunction merge(object) {\n    slice(arguments, 1).forEach(function(source) {\n        forOwn(source, function(value, key) {\n            if (isArray(value)) {\n                object[key] = value.slice();\n            } else if (isObject(value)) {\n                object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);\n            } else {\n                object[key] = value;\n            }\n        });\n    });\n    return object;\n}\nfunction omit(object, keys) {\n    forEach(keys || ownKeys(object), function(key) {\n        delete object[key];\n    });\n}\nfunction removeAttribute(elms, attrs) {\n    forEach(elms, function(elm) {\n        forEach(attrs, function(attr) {\n            elm && elm.removeAttribute(attr);\n        });\n    });\n}\nfunction setAttribute(elms, attrs, value) {\n    if (isObject(attrs)) {\n        forOwn(attrs, function(value2, name) {\n            setAttribute(elms, name, value2);\n        });\n    } else {\n        forEach(elms, function(elm) {\n            isNull(value) || value === \"\" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n        });\n    }\n}\nfunction create(tag, attrs, parent) {\n    var elm = document.createElement(tag);\n    if (attrs) {\n        isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);\n    }\n    parent && append(parent, elm);\n    return elm;\n}\nfunction style(elm, prop, value) {\n    if (isUndefined(value)) {\n        return getComputedStyle(elm)[prop];\n    }\n    if (!isNull(value)) {\n        elm.style[prop] = \"\" + value;\n    }\n}\nfunction display(elm, display2) {\n    style(elm, \"display\", display2);\n}\nfunction focus(elm) {\n    elm[\"setActive\"] && elm[\"setActive\"]() || elm.focus({\n        preventScroll: true\n    });\n}\nfunction getAttribute(elm, attr) {\n    return elm.getAttribute(attr);\n}\nfunction hasClass(elm, className) {\n    return elm && elm.classList.contains(className);\n}\nfunction rect(target) {\n    return target.getBoundingClientRect();\n}\nfunction remove(nodes) {\n    forEach(nodes, function(node) {\n        if (node && node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    });\n}\nfunction parseHtml(html) {\n    return child(new DOMParser().parseFromString(html, \"text/html\").body);\n}\nfunction prevent(e, stopPropagation) {\n    e.preventDefault();\n    if (stopPropagation) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n    }\n}\nfunction query(parent, selector) {\n    return parent && parent.querySelector(selector);\n}\nfunction queryAll(parent, selector) {\n    return selector ? slice(parent.querySelectorAll(selector)) : [];\n}\nfunction removeClass(elm, classes) {\n    toggleClass(elm, classes, false);\n}\nfunction timeOf(e) {\n    return e.timeStamp;\n}\nfunction unit(value) {\n    return isString(value) ? value : value ? value + \"px\" : \"\";\n}\nvar PROJECT_CODE = \"splide\";\nvar DATA_ATTRIBUTE = \"data-\" + PROJECT_CODE;\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(\"[\" + PROJECT_CODE + \"] \" + (message || \"\"));\n    }\n}\nvar min = Math.min;\nvar max = Math.max;\nvar floor = Math.floor;\nvar ceil = Math.ceil;\nvar abs = Math.abs;\nfunction approximatelyEqual(x, y, epsilon) {\n    return abs(x - y) < epsilon;\n}\nfunction between(number, x, y, exclusive) {\n    var minimum = min(x, y);\n    var maximum = max(x, y);\n    return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;\n}\nfunction clamp(number, x, y) {\n    var minimum = min(x, y);\n    var maximum = max(x, y);\n    return min(max(minimum, number), maximum);\n}\nfunction sign(x) {\n    return +(x > 0) - +(x < 0);\n}\nfunction format(string, replacements) {\n    forEach(replacements, function(replacement) {\n        string = string.replace(\"%s\", \"\" + replacement);\n    });\n    return string;\n}\nfunction pad(number) {\n    return number < 10 ? \"0\" + number : \"\" + number;\n}\nvar ids = {};\nfunction uniqueId(prefix) {\n    return \"\" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);\n}\nfunction EventBinder() {\n    var listeners = [];\n    function bind(targets, events, callback, options) {\n        forEachEvent(targets, events, function(target, event, namespace) {\n            var isEventTarget = \"addEventListener\" in target;\n            var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target[\"removeListener\"].bind(target, callback);\n            isEventTarget ? target.addEventListener(event, callback, options) : target[\"addListener\"](callback);\n            listeners.push([\n                target,\n                event,\n                namespace,\n                callback,\n                remover\n            ]);\n        });\n    }\n    function unbind(targets, events, callback) {\n        forEachEvent(targets, events, function(target, event, namespace) {\n            listeners = listeners.filter(function(listener) {\n                if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {\n                    listener[4]();\n                    return false;\n                }\n                return true;\n            });\n        });\n    }\n    function dispatch(target, type, detail) {\n        var e;\n        var bubbles = true;\n        if (typeof CustomEvent === \"function\") {\n            e = new CustomEvent(type, {\n                bubbles,\n                detail\n            });\n        } else {\n            e = document.createEvent(\"CustomEvent\");\n            e.initCustomEvent(type, bubbles, false, detail);\n        }\n        target.dispatchEvent(e);\n        return e;\n    }\n    function forEachEvent(targets, events, iteratee) {\n        forEach(targets, function(target) {\n            target && forEach(events, function(events2) {\n                events2.split(\" \").forEach(function(eventNS) {\n                    var fragment = eventNS.split(\".\");\n                    iteratee(target, fragment[0], fragment[1]);\n                });\n            });\n        });\n    }\n    function destroy() {\n        listeners.forEach(function(data) {\n            data[4]();\n        });\n        empty(listeners);\n    }\n    return {\n        bind,\n        unbind,\n        dispatch,\n        destroy\n    };\n}\nvar EVENT_MOUNTED = \"mounted\";\nvar EVENT_READY = \"ready\";\nvar EVENT_MOVE = \"move\";\nvar EVENT_MOVED = \"moved\";\nvar EVENT_CLICK = \"click\";\nvar EVENT_ACTIVE = \"active\";\nvar EVENT_INACTIVE = \"inactive\";\nvar EVENT_VISIBLE = \"visible\";\nvar EVENT_HIDDEN = \"hidden\";\nvar EVENT_REFRESH = \"refresh\";\nvar EVENT_UPDATED = \"updated\";\nvar EVENT_RESIZE = \"resize\";\nvar EVENT_RESIZED = \"resized\";\nvar EVENT_DRAG = \"drag\";\nvar EVENT_DRAGGING = \"dragging\";\nvar EVENT_DRAGGED = \"dragged\";\nvar EVENT_SCROLL = \"scroll\";\nvar EVENT_SCROLLED = \"scrolled\";\nvar EVENT_OVERFLOW = \"overflow\";\nvar EVENT_DESTROY = \"destroy\";\nvar EVENT_ARROWS_MOUNTED = \"arrows:mounted\";\nvar EVENT_ARROWS_UPDATED = \"arrows:updated\";\nvar EVENT_PAGINATION_MOUNTED = \"pagination:mounted\";\nvar EVENT_PAGINATION_UPDATED = \"pagination:updated\";\nvar EVENT_NAVIGATION_MOUNTED = \"navigation:mounted\";\nvar EVENT_AUTOPLAY_PLAY = \"autoplay:play\";\nvar EVENT_AUTOPLAY_PLAYING = \"autoplay:playing\";\nvar EVENT_AUTOPLAY_PAUSE = \"autoplay:pause\";\nvar EVENT_LAZYLOAD_LOADED = \"lazyload:loaded\";\nvar EVENT_SLIDE_KEYDOWN = \"sk\";\nvar EVENT_SHIFTED = \"sh\";\nvar EVENT_END_INDEX_CHANGED = \"ei\";\nfunction EventInterface(Splide22) {\n    var bus = Splide22 ? Splide22.event.bus : document.createDocumentFragment();\n    var binder = EventBinder();\n    function on(events, callback) {\n        binder.bind(bus, toArray(events).join(\" \"), function(e) {\n            callback.apply(callback, isArray(e.detail) ? e.detail : []);\n        });\n    }\n    function emit(event) {\n        binder.dispatch(bus, event, slice(arguments, 1));\n    }\n    if (Splide22) {\n        Splide22.event.on(EVENT_DESTROY, binder.destroy);\n    }\n    return assign(binder, {\n        bus,\n        on,\n        off: apply(binder.unbind, bus),\n        emit\n    });\n}\nfunction RequestInterval(interval, onInterval, onUpdate, limit) {\n    var now = Date.now;\n    var startTime;\n    var rate = 0;\n    var id;\n    var paused = true;\n    var count = 0;\n    function update() {\n        if (!paused) {\n            rate = interval ? min((now() - startTime) / interval, 1) : 1;\n            onUpdate && onUpdate(rate);\n            if (rate >= 1) {\n                onInterval();\n                startTime = now();\n                if (limit && ++count >= limit) {\n                    return pause();\n                }\n            }\n            id = raf(update);\n        }\n    }\n    function start(resume) {\n        resume || cancel();\n        startTime = now() - (resume ? rate * interval : 0);\n        paused = false;\n        id = raf(update);\n    }\n    function pause() {\n        paused = true;\n    }\n    function rewind() {\n        startTime = now();\n        rate = 0;\n        if (onUpdate) {\n            onUpdate(rate);\n        }\n    }\n    function cancel() {\n        id && cancelAnimationFrame(id);\n        rate = 0;\n        id = 0;\n        paused = true;\n    }\n    function set(time) {\n        interval = time;\n    }\n    function isPaused() {\n        return paused;\n    }\n    return {\n        start,\n        rewind,\n        pause,\n        cancel,\n        set,\n        isPaused\n    };\n}\nfunction State(initialState) {\n    var state = initialState;\n    function set(value) {\n        state = value;\n    }\n    function is(states) {\n        return includes(toArray(states), state);\n    }\n    return {\n        set,\n        is\n    };\n}\nfunction Throttle(func, duration) {\n    var interval = RequestInterval(duration || 0, func, null, 1);\n    return function() {\n        interval.isPaused() && interval.start();\n    };\n}\nfunction Media(Splide22, Components2, options) {\n    var state = Splide22.state;\n    var breakpoints = options.breakpoints || {};\n    var reducedMotion = options.reducedMotion || {};\n    var binder = EventBinder();\n    var queries = [];\n    function setup() {\n        var isMin = options.mediaQuery === \"min\";\n        ownKeys(breakpoints).sort(function(n, m) {\n            return isMin ? +n - +m : +m - +n;\n        }).forEach(function(key) {\n            register(breakpoints[key], \"(\" + (isMin ? \"min\" : \"max\") + \"-width:\" + key + \"px)\");\n        });\n        register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);\n        update();\n    }\n    function destroy(completely) {\n        if (completely) {\n            binder.destroy();\n        }\n    }\n    function register(options2, query2) {\n        var queryList = matchMedia(query2);\n        binder.bind(queryList, \"change\", update);\n        queries.push([\n            options2,\n            queryList\n        ]);\n    }\n    function update() {\n        var destroyed = state.is(DESTROYED);\n        var direction = options.direction;\n        var merged = queries.reduce(function(merged2, entry) {\n            return merge(merged2, entry[1].matches ? entry[0] : {});\n        }, {});\n        omit(options);\n        set(merged);\n        if (options.destroy) {\n            Splide22.destroy(options.destroy === \"completely\");\n        } else if (destroyed) {\n            destroy(true);\n            Splide22.mount();\n        } else {\n            direction !== options.direction && Splide22.refresh();\n        }\n    }\n    function reduce(enable) {\n        if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {\n            enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));\n        }\n    }\n    function set(opts, base, notify) {\n        merge(options, opts);\n        base && merge(Object.getPrototypeOf(options), opts);\n        if (notify || !state.is(CREATED)) {\n            Splide22.emit(EVENT_UPDATED, options);\n        }\n    }\n    return {\n        setup,\n        destroy,\n        reduce,\n        set\n    };\n}\nvar ARROW = \"Arrow\";\nvar ARROW_LEFT = ARROW + \"Left\";\nvar ARROW_RIGHT = ARROW + \"Right\";\nvar ARROW_UP = ARROW + \"Up\";\nvar ARROW_DOWN = ARROW + \"Down\";\nvar RTL = \"rtl\";\nvar TTB = \"ttb\";\nvar ORIENTATION_MAP = {\n    width: [\n        \"height\"\n    ],\n    left: [\n        \"top\",\n        \"right\"\n    ],\n    right: [\n        \"bottom\",\n        \"left\"\n    ],\n    x: [\n        \"y\"\n    ],\n    X: [\n        \"Y\"\n    ],\n    Y: [\n        \"X\"\n    ],\n    ArrowLeft: [\n        ARROW_UP,\n        ARROW_RIGHT\n    ],\n    ArrowRight: [\n        ARROW_DOWN,\n        ARROW_LEFT\n    ]\n};\nfunction Direction(Splide22, Components2, options) {\n    function resolve(prop, axisOnly, direction) {\n        direction = direction || options.direction;\n        var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;\n        return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function(match, offset) {\n            var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;\n            return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;\n        });\n    }\n    function orient(value) {\n        return value * (options.direction === RTL ? 1 : -1);\n    }\n    return {\n        resolve,\n        orient\n    };\n}\nvar ROLE = \"role\";\nvar TAB_INDEX = \"tabindex\";\nvar DISABLED = \"disabled\";\nvar ARIA_PREFIX = \"aria-\";\nvar ARIA_CONTROLS = ARIA_PREFIX + \"controls\";\nvar ARIA_CURRENT = ARIA_PREFIX + \"current\";\nvar ARIA_SELECTED = ARIA_PREFIX + \"selected\";\nvar ARIA_LABEL = ARIA_PREFIX + \"label\";\nvar ARIA_LABELLEDBY = ARIA_PREFIX + \"labelledby\";\nvar ARIA_HIDDEN = ARIA_PREFIX + \"hidden\";\nvar ARIA_ORIENTATION = ARIA_PREFIX + \"orientation\";\nvar ARIA_ROLEDESCRIPTION = ARIA_PREFIX + \"roledescription\";\nvar ARIA_LIVE = ARIA_PREFIX + \"live\";\nvar ARIA_BUSY = ARIA_PREFIX + \"busy\";\nvar ARIA_ATOMIC = ARIA_PREFIX + \"atomic\";\nvar ALL_ATTRIBUTES = [\n    ROLE,\n    TAB_INDEX,\n    DISABLED,\n    ARIA_CONTROLS,\n    ARIA_CURRENT,\n    ARIA_LABEL,\n    ARIA_LABELLEDBY,\n    ARIA_HIDDEN,\n    ARIA_ORIENTATION,\n    ARIA_ROLEDESCRIPTION\n];\nvar CLASS_PREFIX = PROJECT_CODE + \"__\";\nvar STATUS_CLASS_PREFIX = \"is-\";\nvar CLASS_ROOT = PROJECT_CODE;\nvar CLASS_TRACK = CLASS_PREFIX + \"track\";\nvar CLASS_LIST = CLASS_PREFIX + \"list\";\nvar CLASS_SLIDE = CLASS_PREFIX + \"slide\";\nvar CLASS_CLONE = CLASS_SLIDE + \"--clone\";\nvar CLASS_CONTAINER = CLASS_SLIDE + \"__container\";\nvar CLASS_ARROWS = CLASS_PREFIX + \"arrows\";\nvar CLASS_ARROW = CLASS_PREFIX + \"arrow\";\nvar CLASS_ARROW_PREV = CLASS_ARROW + \"--prev\";\nvar CLASS_ARROW_NEXT = CLASS_ARROW + \"--next\";\nvar CLASS_PAGINATION = CLASS_PREFIX + \"pagination\";\nvar CLASS_PAGINATION_PAGE = CLASS_PAGINATION + \"__page\";\nvar CLASS_PROGRESS = CLASS_PREFIX + \"progress\";\nvar CLASS_PROGRESS_BAR = CLASS_PROGRESS + \"__bar\";\nvar CLASS_TOGGLE = CLASS_PREFIX + \"toggle\";\nvar CLASS_TOGGLE_PLAY = CLASS_TOGGLE + \"__play\";\nvar CLASS_TOGGLE_PAUSE = CLASS_TOGGLE + \"__pause\";\nvar CLASS_SPINNER = CLASS_PREFIX + \"spinner\";\nvar CLASS_SR = CLASS_PREFIX + \"sr\";\nvar CLASS_INITIALIZED = STATUS_CLASS_PREFIX + \"initialized\";\nvar CLASS_ACTIVE = STATUS_CLASS_PREFIX + \"active\";\nvar CLASS_PREV = STATUS_CLASS_PREFIX + \"prev\";\nvar CLASS_NEXT = STATUS_CLASS_PREFIX + \"next\";\nvar CLASS_VISIBLE = STATUS_CLASS_PREFIX + \"visible\";\nvar CLASS_LOADING = STATUS_CLASS_PREFIX + \"loading\";\nvar CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + \"focus-in\";\nvar CLASS_OVERFLOW = STATUS_CLASS_PREFIX + \"overflow\";\nvar STATUS_CLASSES = [\n    CLASS_ACTIVE,\n    CLASS_VISIBLE,\n    CLASS_PREV,\n    CLASS_NEXT,\n    CLASS_LOADING,\n    CLASS_FOCUS_IN,\n    CLASS_OVERFLOW\n];\nvar CLASSES = {\n    slide: CLASS_SLIDE,\n    clone: CLASS_CLONE,\n    arrows: CLASS_ARROWS,\n    arrow: CLASS_ARROW,\n    prev: CLASS_ARROW_PREV,\n    next: CLASS_ARROW_NEXT,\n    pagination: CLASS_PAGINATION,\n    page: CLASS_PAGINATION_PAGE,\n    spinner: CLASS_SPINNER\n};\nfunction closest(from, selector) {\n    if (isFunction(from.closest)) {\n        return from.closest(selector);\n    }\n    var elm = from;\n    while(elm && elm.nodeType === 1){\n        if (matches(elm, selector)) {\n            break;\n        }\n        elm = elm.parentElement;\n    }\n    return elm;\n}\nvar FRICTION = 5;\nvar LOG_INTERVAL = 200;\nvar POINTER_DOWN_EVENTS = \"touchstart mousedown\";\nvar POINTER_MOVE_EVENTS = \"touchmove mousemove\";\nvar POINTER_UP_EVENTS = \"touchend touchcancel mouseup click\";\nfunction Elements(Splide22, Components2, options) {\n    var _EventInterface = EventInterface(Splide22), on = _EventInterface.on, bind = _EventInterface.bind;\n    var root = Splide22.root;\n    var i18n = options.i18n;\n    var elements = {};\n    var slides = [];\n    var rootClasses = [];\n    var trackClasses = [];\n    var track;\n    var list;\n    var isUsingKey;\n    function setup() {\n        collect();\n        init();\n        update();\n    }\n    function mount() {\n        on(EVENT_REFRESH, destroy);\n        on(EVENT_REFRESH, setup);\n        on(EVENT_UPDATED, update);\n        bind(document, POINTER_DOWN_EVENTS + \" keydown\", function(e) {\n            isUsingKey = e.type === \"keydown\";\n        }, {\n            capture: true\n        });\n        bind(root, \"focusin\", function() {\n            toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);\n        });\n    }\n    function destroy(completely) {\n        var attrs = ALL_ATTRIBUTES.concat(\"style\");\n        empty(slides);\n        removeClass(root, rootClasses);\n        removeClass(track, trackClasses);\n        removeAttribute([\n            track,\n            list\n        ], attrs);\n        removeAttribute(root, completely ? attrs : [\n            \"style\",\n            ARIA_ROLEDESCRIPTION\n        ]);\n    }\n    function update() {\n        removeClass(root, rootClasses);\n        removeClass(track, trackClasses);\n        rootClasses = getClasses(CLASS_ROOT);\n        trackClasses = getClasses(CLASS_TRACK);\n        addClass(root, rootClasses);\n        addClass(track, trackClasses);\n        setAttribute(root, ARIA_LABEL, options.label);\n        setAttribute(root, ARIA_LABELLEDBY, options.labelledby);\n    }\n    function collect() {\n        track = find(\".\" + CLASS_TRACK);\n        list = child(track, \".\" + CLASS_LIST);\n        assert(track && list, \"A track/list element is missing.\");\n        push(slides, children(list, \".\" + CLASS_SLIDE + \":not(.\" + CLASS_CLONE + \")\"));\n        forOwn({\n            arrows: CLASS_ARROWS,\n            pagination: CLASS_PAGINATION,\n            prev: CLASS_ARROW_PREV,\n            next: CLASS_ARROW_NEXT,\n            bar: CLASS_PROGRESS_BAR,\n            toggle: CLASS_TOGGLE\n        }, function(className, key) {\n            elements[key] = find(\".\" + className);\n        });\n        assign(elements, {\n            root,\n            track,\n            list,\n            slides\n        });\n    }\n    function init() {\n        var id = root.id || uniqueId(PROJECT_CODE);\n        var role = options.role;\n        root.id = id;\n        track.id = track.id || id + \"-track\";\n        list.id = list.id || id + \"-list\";\n        if (!getAttribute(root, ROLE) && root.tagName !== \"SECTION\" && role) {\n            setAttribute(root, ROLE, role);\n        }\n        setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);\n        setAttribute(list, ROLE, \"presentation\");\n    }\n    function find(selector) {\n        var elm = query(root, selector);\n        return elm && closest(elm, \".\" + CLASS_ROOT) === root ? elm : void 0;\n    }\n    function getClasses(base) {\n        return [\n            base + \"--\" + options.type,\n            base + \"--\" + options.direction,\n            options.drag && base + \"--draggable\",\n            options.isNavigation && base + \"--nav\",\n            base === CLASS_ROOT && CLASS_ACTIVE\n        ];\n    }\n    return assign(elements, {\n        setup,\n        mount,\n        destroy\n    });\n}\nvar SLIDE = \"slide\";\nvar LOOP = \"loop\";\nvar FADE = \"fade\";\nfunction Slide$1(Splide22, index, slideIndex, slide) {\n    var event = EventInterface(Splide22);\n    var on = event.on, emit = event.emit, bind = event.bind;\n    var Components = Splide22.Components, root = Splide22.root, options = Splide22.options;\n    var isNavigation = options.isNavigation, updateOnMove = options.updateOnMove, i18n = options.i18n, pagination = options.pagination, slideFocus = options.slideFocus;\n    var resolve = Components.Direction.resolve;\n    var styles = getAttribute(slide, \"style\");\n    var label = getAttribute(slide, ARIA_LABEL);\n    var isClone = slideIndex > -1;\n    var container = child(slide, \".\" + CLASS_CONTAINER);\n    var destroyed;\n    function mount() {\n        if (!isClone) {\n            slide.id = root.id + \"-slide\" + pad(index + 1);\n            setAttribute(slide, ROLE, pagination ? \"tabpanel\" : \"group\");\n            setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);\n            setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [\n                index + 1,\n                Splide22.length\n            ]));\n        }\n        listen();\n    }\n    function listen() {\n        bind(slide, \"click\", apply(emit, EVENT_CLICK, self));\n        bind(slide, \"keydown\", apply(emit, EVENT_SLIDE_KEYDOWN, self));\n        on([\n            EVENT_MOVED,\n            EVENT_SHIFTED,\n            EVENT_SCROLLED\n        ], update);\n        on(EVENT_NAVIGATION_MOUNTED, initNavigation);\n        if (updateOnMove) {\n            on(EVENT_MOVE, onMove);\n        }\n    }\n    function destroy() {\n        destroyed = true;\n        event.destroy();\n        removeClass(slide, STATUS_CLASSES);\n        removeAttribute(slide, ALL_ATTRIBUTES);\n        setAttribute(slide, \"style\", styles);\n        setAttribute(slide, ARIA_LABEL, label || \"\");\n    }\n    function initNavigation() {\n        var controls = Splide22.splides.map(function(target) {\n            var Slide2 = target.splide.Components.Slides.getAt(index);\n            return Slide2 ? Slide2.slide.id : \"\";\n        }).join(\" \");\n        setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));\n        setAttribute(slide, ARIA_CONTROLS, controls);\n        setAttribute(slide, ROLE, slideFocus ? \"button\" : \"\");\n        slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);\n    }\n    function onMove() {\n        if (!destroyed) {\n            update();\n        }\n    }\n    function update() {\n        if (!destroyed) {\n            var curr = Splide22.index;\n            updateActivity();\n            updateVisibility();\n            toggleClass(slide, CLASS_PREV, index === curr - 1);\n            toggleClass(slide, CLASS_NEXT, index === curr + 1);\n        }\n    }\n    function updateActivity() {\n        var active = isActive();\n        if (active !== hasClass(slide, CLASS_ACTIVE)) {\n            toggleClass(slide, CLASS_ACTIVE, active);\n            setAttribute(slide, ARIA_CURRENT, isNavigation && active || \"\");\n            emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);\n        }\n    }\n    function updateVisibility() {\n        var visible = isVisible();\n        var hidden = !visible && (!isActive() || isClone);\n        if (!Splide22.state.is([\n            MOVING,\n            SCROLLING\n        ])) {\n            setAttribute(slide, ARIA_HIDDEN, hidden || \"\");\n        }\n        setAttribute(queryAll(slide, options.focusableNodes || \"\"), TAB_INDEX, hidden ? -1 : \"\");\n        if (slideFocus) {\n            setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);\n        }\n        if (visible !== hasClass(slide, CLASS_VISIBLE)) {\n            toggleClass(slide, CLASS_VISIBLE, visible);\n            emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);\n        }\n        if (!visible && document.activeElement === slide) {\n            var Slide2 = Components.Slides.getAt(Splide22.index);\n            Slide2 && focus(Slide2.slide);\n        }\n    }\n    function style$1(prop, value, useContainer) {\n        style(useContainer && container || slide, prop, value);\n    }\n    function isActive() {\n        var curr = Splide22.index;\n        return curr === index || options.cloneStatus && curr === slideIndex;\n    }\n    function isVisible() {\n        if (Splide22.is(FADE)) {\n            return isActive();\n        }\n        var trackRect = rect(Components.Elements.track);\n        var slideRect = rect(slide);\n        var left = resolve(\"left\", true);\n        var right = resolve(\"right\", true);\n        return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);\n    }\n    function isWithin(from, distance) {\n        var diff = abs(from - index);\n        if (!isClone && (options.rewind || Splide22.is(LOOP))) {\n            diff = min(diff, Splide22.length - diff);\n        }\n        return diff <= distance;\n    }\n    var self = {\n        index,\n        slideIndex,\n        slide,\n        container,\n        isClone,\n        mount,\n        destroy,\n        update,\n        style: style$1,\n        isWithin\n    };\n    return self;\n}\nfunction Slides(Splide22, Components2, options) {\n    var _EventInterface2 = EventInterface(Splide22), on = _EventInterface2.on, emit = _EventInterface2.emit, bind = _EventInterface2.bind;\n    var _Components2$Elements = Components2.Elements, slides = _Components2$Elements.slides, list = _Components2$Elements.list;\n    var Slides2 = [];\n    function mount() {\n        init();\n        on(EVENT_REFRESH, destroy);\n        on(EVENT_REFRESH, init);\n    }\n    function init() {\n        slides.forEach(function(slide, index) {\n            register(slide, index, -1);\n        });\n    }\n    function destroy() {\n        forEach$1(function(Slide2) {\n            Slide2.destroy();\n        });\n        empty(Slides2);\n    }\n    function update() {\n        forEach$1(function(Slide2) {\n            Slide2.update();\n        });\n    }\n    function register(slide, index, slideIndex) {\n        var object = Slide$1(Splide22, index, slideIndex, slide);\n        object.mount();\n        Slides2.push(object);\n        Slides2.sort(function(Slide1, Slide2) {\n            return Slide1.index - Slide2.index;\n        });\n    }\n    function get(excludeClones) {\n        return excludeClones ? filter(function(Slide2) {\n            return !Slide2.isClone;\n        }) : Slides2;\n    }\n    function getIn(page) {\n        var Controller2 = Components2.Controller;\n        var index = Controller2.toIndex(page);\n        var max2 = Controller2.hasFocus() ? 1 : options.perPage;\n        return filter(function(Slide2) {\n            return between(Slide2.index, index, index + max2 - 1);\n        });\n    }\n    function getAt(index) {\n        return filter(index)[0];\n    }\n    function add(items, index) {\n        forEach(items, function(slide) {\n            if (isString(slide)) {\n                slide = parseHtml(slide);\n            }\n            if (isHTMLElement(slide)) {\n                var ref = slides[index];\n                ref ? before(slide, ref) : append(list, slide);\n                addClass(slide, options.classes.slide);\n                observeImages(slide, apply(emit, EVENT_RESIZE));\n            }\n        });\n        emit(EVENT_REFRESH);\n    }\n    function remove$1(matcher) {\n        remove(filter(matcher).map(function(Slide2) {\n            return Slide2.slide;\n        }));\n        emit(EVENT_REFRESH);\n    }\n    function forEach$1(iteratee, excludeClones) {\n        get(excludeClones).forEach(iteratee);\n    }\n    function filter(matcher) {\n        return Slides2.filter(isFunction(matcher) ? matcher : function(Slide2) {\n            return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);\n        });\n    }\n    function style2(prop, value, useContainer) {\n        forEach$1(function(Slide2) {\n            Slide2.style(prop, value, useContainer);\n        });\n    }\n    function observeImages(elm, callback) {\n        var images = queryAll(elm, \"img\");\n        var length = images.length;\n        if (length) {\n            images.forEach(function(img) {\n                bind(img, \"load error\", function() {\n                    if (!--length) {\n                        callback();\n                    }\n                });\n            });\n        } else {\n            callback();\n        }\n    }\n    function getLength(excludeClones) {\n        return excludeClones ? slides.length : Slides2.length;\n    }\n    function isEnough() {\n        return Slides2.length > options.perPage;\n    }\n    return {\n        mount,\n        destroy,\n        update,\n        register,\n        get,\n        getIn,\n        getAt,\n        add,\n        remove: remove$1,\n        forEach: forEach$1,\n        filter,\n        style: style2,\n        getLength,\n        isEnough\n    };\n}\nfunction Layout(Splide22, Components2, options) {\n    var _EventInterface3 = EventInterface(Splide22), on = _EventInterface3.on, bind = _EventInterface3.bind, emit = _EventInterface3.emit;\n    var Slides2 = Components2.Slides;\n    var resolve = Components2.Direction.resolve;\n    var _Components2$Elements2 = Components2.Elements, root = _Components2$Elements2.root, track = _Components2$Elements2.track, list = _Components2$Elements2.list;\n    var getAt = Slides2.getAt, styleSlides = Slides2.style;\n    var vertical;\n    var rootRect;\n    var overflow;\n    function mount() {\n        init();\n        bind(window, \"resize load\", Throttle(apply(emit, EVENT_RESIZE)));\n        on([\n            EVENT_UPDATED,\n            EVENT_REFRESH\n        ], init);\n        on(EVENT_RESIZE, resize);\n    }\n    function init() {\n        vertical = options.direction === TTB;\n        style(root, \"maxWidth\", unit(options.width));\n        style(track, resolve(\"paddingLeft\"), cssPadding(false));\n        style(track, resolve(\"paddingRight\"), cssPadding(true));\n        resize(true);\n    }\n    function resize(force) {\n        var newRect = rect(root);\n        if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {\n            style(track, \"height\", cssTrackHeight());\n            styleSlides(resolve(\"marginRight\"), unit(options.gap));\n            styleSlides(\"width\", cssSlideWidth());\n            styleSlides(\"height\", cssSlideHeight(), true);\n            rootRect = newRect;\n            emit(EVENT_RESIZED);\n            if (overflow !== (overflow = isOverflow())) {\n                toggleClass(root, CLASS_OVERFLOW, overflow);\n                emit(EVENT_OVERFLOW, overflow);\n            }\n        }\n    }\n    function cssPadding(right) {\n        var padding = options.padding;\n        var prop = resolve(right ? \"right\" : \"left\");\n        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || \"0px\";\n    }\n    function cssTrackHeight() {\n        var height = \"\";\n        if (vertical) {\n            height = cssHeight();\n            assert(height, \"height or heightRatio is missing.\");\n            height = \"calc(\" + height + \" - \" + cssPadding(false) + \" - \" + cssPadding(true) + \")\";\n        }\n        return height;\n    }\n    function cssHeight() {\n        return unit(options.height || rect(list).width * options.heightRatio);\n    }\n    function cssSlideWidth() {\n        return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? \"\" : cssSlideSize());\n    }\n    function cssSlideHeight() {\n        return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());\n    }\n    function cssSlideSize() {\n        var gap = unit(options.gap);\n        return \"calc((100%\" + (gap && \" + \" + gap) + \")/\" + (options.perPage || 1) + (gap && \" - \" + gap) + \")\";\n    }\n    function listSize() {\n        return rect(list)[resolve(\"width\")];\n    }\n    function slideSize(index, withoutGap) {\n        var Slide2 = getAt(index || 0);\n        return Slide2 ? rect(Slide2.slide)[resolve(\"width\")] + (withoutGap ? 0 : getGap()) : 0;\n    }\n    function totalSize(index, withoutGap) {\n        var Slide2 = getAt(index);\n        if (Slide2) {\n            var right = rect(Slide2.slide)[resolve(\"right\")];\n            var left = rect(list)[resolve(\"left\")];\n            return abs(right - left) + (withoutGap ? 0 : getGap());\n        }\n        return 0;\n    }\n    function sliderSize(withoutGap) {\n        return totalSize(Splide22.length - 1) - totalSize(0) + slideSize(0, withoutGap);\n    }\n    function getGap() {\n        var Slide2 = getAt(0);\n        return Slide2 && parseFloat(style(Slide2.slide, resolve(\"marginRight\"))) || 0;\n    }\n    function getPadding(right) {\n        return parseFloat(style(track, resolve(\"padding\" + (right ? \"Right\" : \"Left\")))) || 0;\n    }\n    function isOverflow() {\n        return Splide22.is(FADE) || sliderSize(true) > listSize();\n    }\n    return {\n        mount,\n        resize,\n        listSize,\n        slideSize,\n        sliderSize,\n        totalSize,\n        getPadding,\n        isOverflow\n    };\n}\nvar MULTIPLIER = 2;\nfunction Clones(Splide22, Components2, options) {\n    var event = EventInterface(Splide22);\n    var on = event.on;\n    var Elements2 = Components2.Elements, Slides2 = Components2.Slides;\n    var resolve = Components2.Direction.resolve;\n    var clones = [];\n    var cloneCount;\n    function mount() {\n        on(EVENT_REFRESH, remount);\n        on([\n            EVENT_UPDATED,\n            EVENT_RESIZE\n        ], observe);\n        if (cloneCount = computeCloneCount()) {\n            generate(cloneCount);\n            Components2.Layout.resize(true);\n        }\n    }\n    function remount() {\n        destroy();\n        mount();\n    }\n    function destroy() {\n        remove(clones);\n        empty(clones);\n        event.destroy();\n    }\n    function observe() {\n        var count = computeCloneCount();\n        if (cloneCount !== count) {\n            if (cloneCount < count || !count) {\n                event.emit(EVENT_REFRESH);\n            }\n        }\n    }\n    function generate(count) {\n        var slides = Slides2.get().slice();\n        var length = slides.length;\n        if (length) {\n            while(slides.length < count){\n                push(slides, slides);\n            }\n            push(slides.slice(-count), slides.slice(0, count)).forEach(function(Slide2, index) {\n                var isHead = index < count;\n                var clone = cloneDeep(Slide2.slide, index);\n                isHead ? before(clone, slides[0].slide) : append(Elements2.list, clone);\n                push(clones, clone);\n                Slides2.register(clone, index - count + (isHead ? 0 : length), Slide2.index);\n            });\n        }\n    }\n    function cloneDeep(elm, index) {\n        var clone = elm.cloneNode(true);\n        addClass(clone, options.classes.clone);\n        clone.id = Splide22.root.id + \"-clone\" + pad(index + 1);\n        return clone;\n    }\n    function computeCloneCount() {\n        var clones2 = options.clones;\n        if (!Splide22.is(LOOP)) {\n            clones2 = 0;\n        } else if (isUndefined(clones2)) {\n            var fixedSize = options[resolve(\"fixedWidth\")] && Components2.Layout.slideSize(0);\n            var fixedCount = fixedSize && ceil(rect(Elements2.track)[resolve(\"width\")] / fixedSize);\n            clones2 = fixedCount || options[resolve(\"autoWidth\")] && Splide22.length || options.perPage * MULTIPLIER;\n        }\n        return clones2;\n    }\n    return {\n        mount,\n        destroy\n    };\n}\nfunction Move(Splide22, Components2, options) {\n    var _EventInterface4 = EventInterface(Splide22), on = _EventInterface4.on, emit = _EventInterface4.emit;\n    var set = Splide22.state.set;\n    var _Components2$Layout = Components2.Layout, slideSize = _Components2$Layout.slideSize, getPadding = _Components2$Layout.getPadding, totalSize = _Components2$Layout.totalSize, listSize = _Components2$Layout.listSize, sliderSize = _Components2$Layout.sliderSize;\n    var _Components2$Directio = Components2.Direction, resolve = _Components2$Directio.resolve, orient = _Components2$Directio.orient;\n    var _Components2$Elements3 = Components2.Elements, list = _Components2$Elements3.list, track = _Components2$Elements3.track;\n    var Transition;\n    function mount() {\n        Transition = Components2.Transition;\n        on([\n            EVENT_MOUNTED,\n            EVENT_RESIZED,\n            EVENT_UPDATED,\n            EVENT_REFRESH\n        ], reposition);\n    }\n    function reposition() {\n        if (!Components2.Controller.isBusy()) {\n            Components2.Scroll.cancel();\n            jump(Splide22.index);\n            Components2.Slides.update();\n        }\n    }\n    function move(dest, index, prev, callback) {\n        if (dest !== index && canShift(dest > prev)) {\n            cancel();\n            translate(shift(getPosition(), dest > prev), true);\n        }\n        set(MOVING);\n        emit(EVENT_MOVE, index, prev, dest);\n        Transition.start(index, function() {\n            set(IDLE);\n            emit(EVENT_MOVED, index, prev, dest);\n            callback && callback();\n        });\n    }\n    function jump(index) {\n        translate(toPosition(index, true));\n    }\n    function translate(position, preventLoop) {\n        if (!Splide22.is(FADE)) {\n            var destination = preventLoop ? position : loop(position);\n            style(list, \"transform\", \"translate\" + resolve(\"X\") + \"(\" + destination + \"px)\");\n            position !== destination && emit(EVENT_SHIFTED);\n        }\n    }\n    function loop(position) {\n        if (Splide22.is(LOOP)) {\n            var index = toIndex(position);\n            var exceededMax = index > Components2.Controller.getEnd();\n            var exceededMin = index < 0;\n            if (exceededMin || exceededMax) {\n                position = shift(position, exceededMax);\n            }\n        }\n        return position;\n    }\n    function shift(position, backwards) {\n        var excess = position - getLimit(backwards);\n        var size = sliderSize();\n        position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);\n        return position;\n    }\n    function cancel() {\n        translate(getPosition(), true);\n        Transition.cancel();\n    }\n    function toIndex(position) {\n        var Slides2 = Components2.Slides.get();\n        var index = 0;\n        var minDistance = Infinity;\n        for(var i = 0; i < Slides2.length; i++){\n            var slideIndex = Slides2[i].index;\n            var distance = abs(toPosition(slideIndex, true) - position);\n            if (distance <= minDistance) {\n                minDistance = distance;\n                index = slideIndex;\n            } else {\n                break;\n            }\n        }\n        return index;\n    }\n    function toPosition(index, trimming) {\n        var position = orient(totalSize(index - 1) - offset(index));\n        return trimming ? trim(position) : position;\n    }\n    function getPosition() {\n        var left = resolve(\"left\");\n        return rect(list)[left] - rect(track)[left] + orient(getPadding(false));\n    }\n    function trim(position) {\n        if (options.trimSpace && Splide22.is(SLIDE)) {\n            position = clamp(position, 0, orient(sliderSize(true) - listSize()));\n        }\n        return position;\n    }\n    function offset(index) {\n        var focus2 = options.focus;\n        return focus2 === \"center\" ? (listSize() - slideSize(index, true)) / 2 : +focus2 * slideSize(index) || 0;\n    }\n    function getLimit(max2) {\n        return toPosition(max2 ? Components2.Controller.getEnd() : 0, !!options.trimSpace);\n    }\n    function canShift(backwards) {\n        var shifted = orient(shift(getPosition(), backwards));\n        return backwards ? shifted >= 0 : shifted <= list[resolve(\"scrollWidth\")] - rect(track)[resolve(\"width\")];\n    }\n    function exceededLimit(max2, position) {\n        position = isUndefined(position) ? getPosition() : position;\n        var exceededMin = max2 !== true && orient(position) < orient(getLimit(false));\n        var exceededMax = max2 !== false && orient(position) > orient(getLimit(true));\n        return exceededMin || exceededMax;\n    }\n    return {\n        mount,\n        move,\n        jump,\n        translate,\n        shift,\n        cancel,\n        toIndex,\n        toPosition,\n        getPosition,\n        getLimit,\n        exceededLimit,\n        reposition\n    };\n}\nfunction Controller(Splide22, Components2, options) {\n    var _EventInterface5 = EventInterface(Splide22), on = _EventInterface5.on, emit = _EventInterface5.emit;\n    var Move2 = Components2.Move;\n    var getPosition = Move2.getPosition, getLimit = Move2.getLimit, toPosition = Move2.toPosition;\n    var _Components2$Slides = Components2.Slides, isEnough = _Components2$Slides.isEnough, getLength = _Components2$Slides.getLength;\n    var omitEnd = options.omitEnd;\n    var isLoop = Splide22.is(LOOP);\n    var isSlide = Splide22.is(SLIDE);\n    var getNext = apply(getAdjacent, false);\n    var getPrev = apply(getAdjacent, true);\n    var currIndex = options.start || 0;\n    var endIndex;\n    var prevIndex = currIndex;\n    var slideCount;\n    var perMove;\n    var perPage;\n    function mount() {\n        init();\n        on([\n            EVENT_UPDATED,\n            EVENT_REFRESH,\n            EVENT_END_INDEX_CHANGED\n        ], init);\n        on(EVENT_RESIZED, onResized);\n    }\n    function init() {\n        slideCount = getLength(true);\n        perMove = options.perMove;\n        perPage = options.perPage;\n        endIndex = getEnd();\n        var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);\n        if (index !== currIndex) {\n            currIndex = index;\n            Move2.reposition();\n        }\n    }\n    function onResized() {\n        if (endIndex !== getEnd()) {\n            emit(EVENT_END_INDEX_CHANGED);\n        }\n    }\n    function go(control, allowSameIndex, callback) {\n        if (!isBusy()) {\n            var dest = parse(control);\n            var index = loop(dest);\n            if (index > -1 && (allowSameIndex || index !== currIndex)) {\n                setIndex(index);\n                Move2.move(dest, index, prevIndex, callback);\n            }\n        }\n    }\n    function scroll(destination, duration, snap, callback) {\n        Components2.Scroll.scroll(destination, duration, snap, function() {\n            var index = loop(Move2.toIndex(getPosition()));\n            setIndex(omitEnd ? min(index, endIndex) : index);\n            callback && callback();\n        });\n    }\n    function parse(control) {\n        var index = currIndex;\n        if (isString(control)) {\n            var _ref = control.match(/([+\\-<>])(\\d+)?/) || [], indicator = _ref[1], number = _ref[2];\n            if (indicator === \"+\" || indicator === \"-\") {\n                index = computeDestIndex(currIndex + +(\"\" + indicator + (+number || 1)), currIndex);\n            } else if (indicator === \">\") {\n                index = number ? toIndex(+number) : getNext(true);\n            } else if (indicator === \"<\") {\n                index = getPrev(true);\n            }\n        } else {\n            index = isLoop ? control : clamp(control, 0, endIndex);\n        }\n        return index;\n    }\n    function getAdjacent(prev, destination) {\n        var number = perMove || (hasFocus() ? 1 : perPage);\n        var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));\n        if (dest === -1 && isSlide) {\n            if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {\n                return prev ? 0 : endIndex;\n            }\n        }\n        return destination ? dest : loop(dest);\n    }\n    function computeDestIndex(dest, from, snapPage) {\n        if (isEnough() || hasFocus()) {\n            var index = computeMovableDestIndex(dest);\n            if (index !== dest) {\n                from = dest;\n                dest = index;\n                snapPage = false;\n            }\n            if (dest < 0 || dest > endIndex) {\n                if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {\n                    dest = toIndex(toPage(dest));\n                } else {\n                    if (isLoop) {\n                        dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;\n                    } else if (options.rewind) {\n                        dest = dest < 0 ? endIndex : 0;\n                    } else {\n                        dest = -1;\n                    }\n                }\n            } else {\n                if (snapPage && dest !== from) {\n                    dest = toIndex(toPage(from) + (dest < from ? -1 : 1));\n                }\n            }\n        } else {\n            dest = -1;\n        }\n        return dest;\n    }\n    function computeMovableDestIndex(dest) {\n        if (isSlide && options.trimSpace === \"move\" && dest !== currIndex) {\n            var position = getPosition();\n            while(position === toPosition(dest, true) && between(dest, 0, Splide22.length - 1, !options.rewind)){\n                dest < currIndex ? --dest : ++dest;\n            }\n        }\n        return dest;\n    }\n    function loop(index) {\n        return isLoop ? (index + slideCount) % slideCount || 0 : index;\n    }\n    function getEnd() {\n        var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);\n        while(omitEnd && end-- > 0){\n            if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {\n                end++;\n                break;\n            }\n        }\n        return clamp(end, 0, slideCount - 1);\n    }\n    function toIndex(page) {\n        return clamp(hasFocus() ? page : perPage * page, 0, endIndex);\n    }\n    function toPage(index) {\n        return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);\n    }\n    function toDest(destination) {\n        var closest2 = Move2.toIndex(destination);\n        return isSlide ? clamp(closest2, 0, endIndex) : closest2;\n    }\n    function setIndex(index) {\n        if (index !== currIndex) {\n            prevIndex = currIndex;\n            currIndex = index;\n        }\n    }\n    function getIndex(prev) {\n        return prev ? prevIndex : currIndex;\n    }\n    function hasFocus() {\n        return !isUndefined(options.focus) || options.isNavigation;\n    }\n    function isBusy() {\n        return Splide22.state.is([\n            MOVING,\n            SCROLLING\n        ]) && !!options.waitForTransition;\n    }\n    return {\n        mount,\n        go,\n        scroll,\n        getNext,\n        getPrev,\n        getAdjacent,\n        getEnd,\n        setIndex,\n        getIndex,\n        toIndex,\n        toPage,\n        toDest,\n        hasFocus,\n        isBusy\n    };\n}\nvar XML_NAME_SPACE = \"http://www.w3.org/2000/svg\";\nvar PATH = \"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\";\nvar SIZE = 40;\nfunction Arrows(Splide22, Components2, options) {\n    var event = EventInterface(Splide22);\n    var on = event.on, bind = event.bind, emit = event.emit;\n    var classes = options.classes, i18n = options.i18n;\n    var Elements2 = Components2.Elements, Controller2 = Components2.Controller;\n    var placeholder = Elements2.arrows, track = Elements2.track;\n    var wrapper = placeholder;\n    var prev = Elements2.prev;\n    var next = Elements2.next;\n    var created;\n    var wrapperClasses;\n    var arrows = {};\n    function mount() {\n        init();\n        on(EVENT_UPDATED, remount);\n    }\n    function remount() {\n        destroy();\n        mount();\n    }\n    function init() {\n        var enabled = options.arrows;\n        if (enabled && !(prev && next)) {\n            createArrows();\n        }\n        if (prev && next) {\n            assign(arrows, {\n                prev,\n                next\n            });\n            display(wrapper, enabled ? \"\" : \"none\");\n            addClass(wrapper, wrapperClasses = CLASS_ARROWS + \"--\" + options.direction);\n            if (enabled) {\n                listen();\n                update();\n                setAttribute([\n                    prev,\n                    next\n                ], ARIA_CONTROLS, track.id);\n                emit(EVENT_ARROWS_MOUNTED, prev, next);\n            }\n        }\n    }\n    function destroy() {\n        event.destroy();\n        removeClass(wrapper, wrapperClasses);\n        if (created) {\n            remove(placeholder ? [\n                prev,\n                next\n            ] : wrapper);\n            prev = next = null;\n        } else {\n            removeAttribute([\n                prev,\n                next\n            ], ALL_ATTRIBUTES);\n        }\n    }\n    function listen() {\n        on([\n            EVENT_MOUNTED,\n            EVENT_MOVED,\n            EVENT_REFRESH,\n            EVENT_SCROLLED,\n            EVENT_END_INDEX_CHANGED\n        ], update);\n        bind(next, \"click\", apply(go, \">\"));\n        bind(prev, \"click\", apply(go, \"<\"));\n    }\n    function go(control) {\n        Controller2.go(control, true);\n    }\n    function createArrows() {\n        wrapper = placeholder || create(\"div\", classes.arrows);\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        append(wrapper, [\n            prev,\n            next\n        ]);\n        !placeholder && before(wrapper, track);\n    }\n    function createArrow(prev2) {\n        var arrow = '<button class=\"' + classes.arrow + \" \" + (prev2 ? classes.prev : classes.next) + '\" type=\"button\"><svg xmlns=\"' + XML_NAME_SPACE + '\" viewBox=\"0 0 ' + SIZE + \" \" + SIZE + '\" width=\"' + SIZE + '\" height=\"' + SIZE + '\" focusable=\"false\"><path d=\"' + (options.arrowPath || PATH) + '\" />';\n        return parseHtml(arrow);\n    }\n    function update() {\n        if (prev && next) {\n            var index = Splide22.index;\n            var prevIndex = Controller2.getPrev();\n            var nextIndex = Controller2.getNext();\n            var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n            var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n            prev.disabled = prevIndex < 0;\n            next.disabled = nextIndex < 0;\n            setAttribute(prev, ARIA_LABEL, prevLabel);\n            setAttribute(next, ARIA_LABEL, nextLabel);\n            emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);\n        }\n    }\n    return {\n        arrows,\n        mount,\n        destroy,\n        update\n    };\n}\nvar INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + \"-interval\";\nfunction Autoplay(Splide22, Components2, options) {\n    var _EventInterface6 = EventInterface(Splide22), on = _EventInterface6.on, bind = _EventInterface6.bind, emit = _EventInterface6.emit;\n    var interval = RequestInterval(options.interval, Splide22.go.bind(Splide22, \">\"), onAnimationFrame);\n    var isPaused = interval.isPaused;\n    var Elements2 = Components2.Elements, _Components2$Elements4 = Components2.Elements, root = _Components2$Elements4.root, toggle = _Components2$Elements4.toggle;\n    var autoplay = options.autoplay;\n    var hovered;\n    var focused;\n    var stopped = autoplay === \"pause\";\n    function mount() {\n        if (autoplay) {\n            listen();\n            toggle && setAttribute(toggle, ARIA_CONTROLS, Elements2.track.id);\n            stopped || play();\n            update();\n        }\n    }\n    function listen() {\n        if (options.pauseOnHover) {\n            bind(root, \"mouseenter mouseleave\", function(e) {\n                hovered = e.type === \"mouseenter\";\n                autoToggle();\n            });\n        }\n        if (options.pauseOnFocus) {\n            bind(root, \"focusin focusout\", function(e) {\n                focused = e.type === \"focusin\";\n                autoToggle();\n            });\n        }\n        if (toggle) {\n            bind(toggle, \"click\", function() {\n                stopped ? play() : pause(true);\n            });\n        }\n        on([\n            EVENT_MOVE,\n            EVENT_SCROLL,\n            EVENT_REFRESH\n        ], interval.rewind);\n        on(EVENT_MOVE, onMove);\n    }\n    function play() {\n        if (isPaused() && Components2.Slides.isEnough()) {\n            interval.start(!options.resetProgress);\n            focused = hovered = stopped = false;\n            update();\n            emit(EVENT_AUTOPLAY_PLAY);\n        }\n    }\n    function pause(stop) {\n        if (stop === void 0) {\n            stop = true;\n        }\n        stopped = !!stop;\n        update();\n        if (!isPaused()) {\n            interval.pause();\n            emit(EVENT_AUTOPLAY_PAUSE);\n        }\n    }\n    function autoToggle() {\n        if (!stopped) {\n            hovered || focused ? pause(false) : play();\n        }\n    }\n    function update() {\n        if (toggle) {\n            toggleClass(toggle, CLASS_ACTIVE, !stopped);\n            setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? \"play\" : \"pause\"]);\n        }\n    }\n    function onAnimationFrame(rate) {\n        var bar = Elements2.bar;\n        bar && style(bar, \"width\", rate * 100 + \"%\");\n        emit(EVENT_AUTOPLAY_PLAYING, rate);\n    }\n    function onMove(index) {\n        var Slide2 = Components2.Slides.getAt(index);\n        interval.set(Slide2 && +getAttribute(Slide2.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);\n    }\n    return {\n        mount,\n        destroy: interval.cancel,\n        play,\n        pause,\n        isPaused\n    };\n}\nfunction Cover(Splide22, Components2, options) {\n    var _EventInterface7 = EventInterface(Splide22), on = _EventInterface7.on;\n    function mount() {\n        if (options.cover) {\n            on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));\n            on([\n                EVENT_MOUNTED,\n                EVENT_UPDATED,\n                EVENT_REFRESH\n            ], apply(cover, true));\n        }\n    }\n    function cover(cover2) {\n        Components2.Slides.forEach(function(Slide2) {\n            var img = child(Slide2.container || Slide2.slide, \"img\");\n            if (img && img.src) {\n                toggle(cover2, img, Slide2);\n            }\n        });\n    }\n    function toggle(cover2, img, Slide2) {\n        Slide2.style(\"background\", cover2 ? 'center/cover no-repeat url(\"' + img.src + '\")' : \"\", true);\n        display(img, cover2 ? \"none\" : \"\");\n    }\n    return {\n        mount,\n        destroy: apply(cover, false)\n    };\n}\nvar BOUNCE_DIFF_THRESHOLD = 10;\nvar BOUNCE_DURATION = 600;\nvar FRICTION_FACTOR = 0.6;\nvar BASE_VELOCITY = 1.5;\nvar MIN_DURATION = 800;\nfunction Scroll(Splide22, Components2, options) {\n    var _EventInterface8 = EventInterface(Splide22), on = _EventInterface8.on, emit = _EventInterface8.emit;\n    var set = Splide22.state.set;\n    var Move2 = Components2.Move;\n    var getPosition = Move2.getPosition, getLimit = Move2.getLimit, exceededLimit = Move2.exceededLimit, translate = Move2.translate;\n    var isSlide = Splide22.is(SLIDE);\n    var interval;\n    var callback;\n    var friction = 1;\n    function mount() {\n        on(EVENT_MOVE, clear);\n        on([\n            EVENT_UPDATED,\n            EVENT_REFRESH\n        ], cancel);\n    }\n    function scroll(destination, duration, snap, onScrolled, noConstrain) {\n        var from = getPosition();\n        clear();\n        if (snap && (!isSlide || !exceededLimit())) {\n            var size = Components2.Layout.sliderSize();\n            var offset = sign(destination) * size * floor(abs(destination) / size) || 0;\n            destination = Move2.toPosition(Components2.Controller.toDest(destination % size)) + offset;\n        }\n        var noDistance = approximatelyEqual(from, destination, 1);\n        friction = 1;\n        duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);\n        callback = onScrolled;\n        interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);\n        set(SCROLLING);\n        emit(EVENT_SCROLL);\n        interval.start();\n    }\n    function onEnd() {\n        set(IDLE);\n        callback && callback();\n        emit(EVENT_SCROLLED);\n    }\n    function update(from, to, noConstrain, rate) {\n        var position = getPosition();\n        var target = from + (to - from) * easing(rate);\n        var diff = (target - position) * friction;\n        translate(position + diff);\n        if (isSlide && !noConstrain && exceededLimit()) {\n            friction *= FRICTION_FACTOR;\n            if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {\n                scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);\n            }\n        }\n    }\n    function clear() {\n        if (interval) {\n            interval.cancel();\n        }\n    }\n    function cancel() {\n        if (interval && !interval.isPaused()) {\n            clear();\n            onEnd();\n        }\n    }\n    function easing(t) {\n        var easingFunc = options.easingFunc;\n        return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);\n    }\n    return {\n        mount,\n        destroy: clear,\n        scroll,\n        cancel\n    };\n}\nvar SCROLL_LISTENER_OPTIONS = {\n    passive: false,\n    capture: true\n};\nfunction Drag(Splide22, Components2, options) {\n    var _EventInterface9 = EventInterface(Splide22), on = _EventInterface9.on, emit = _EventInterface9.emit, bind = _EventInterface9.bind, unbind = _EventInterface9.unbind;\n    var state = Splide22.state;\n    var Move2 = Components2.Move, Scroll2 = Components2.Scroll, Controller2 = Components2.Controller, track = Components2.Elements.track, reduce = Components2.Media.reduce;\n    var _Components2$Directio2 = Components2.Direction, resolve = _Components2$Directio2.resolve, orient = _Components2$Directio2.orient;\n    var getPosition = Move2.getPosition, exceededLimit = Move2.exceededLimit;\n    var basePosition;\n    var baseEvent;\n    var prevBaseEvent;\n    var isFree;\n    var dragging;\n    var exceeded = false;\n    var clickPrevented;\n    var disabled;\n    var target;\n    function mount() {\n        bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n        bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);\n        bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);\n        bind(track, \"click\", onClick, {\n            capture: true\n        });\n        bind(track, \"dragstart\", prevent);\n        on([\n            EVENT_MOUNTED,\n            EVENT_UPDATED\n        ], init);\n    }\n    function init() {\n        var drag = options.drag;\n        disable(!drag);\n        isFree = drag === \"free\";\n    }\n    function onPointerDown(e) {\n        clickPrevented = false;\n        if (!disabled) {\n            var isTouch = isTouchEvent(e);\n            if (isDraggable(e.target) && (isTouch || !e.button)) {\n                if (!Controller2.isBusy()) {\n                    target = isTouch ? track : window;\n                    dragging = state.is([\n                        MOVING,\n                        SCROLLING\n                    ]);\n                    prevBaseEvent = null;\n                    bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);\n                    bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);\n                    Move2.cancel();\n                    Scroll2.cancel();\n                    save(e);\n                } else {\n                    prevent(e, true);\n                }\n            }\n        }\n    }\n    function onPointerMove(e) {\n        if (!state.is(DRAGGING)) {\n            state.set(DRAGGING);\n            emit(EVENT_DRAG);\n        }\n        if (e.cancelable) {\n            if (dragging) {\n                Move2.translate(basePosition + constrain(diffCoord(e)));\n                var expired = diffTime(e) > LOG_INTERVAL;\n                var hasExceeded = exceeded !== (exceeded = exceededLimit());\n                if (expired || hasExceeded) {\n                    save(e);\n                }\n                clickPrevented = true;\n                emit(EVENT_DRAGGING);\n                prevent(e);\n            } else if (isSliderDirection(e)) {\n                dragging = shouldStart(e);\n                prevent(e);\n            }\n        }\n    }\n    function onPointerUp(e) {\n        if (state.is(DRAGGING)) {\n            state.set(IDLE);\n            emit(EVENT_DRAGGED);\n        }\n        if (dragging) {\n            move(e);\n            prevent(e);\n        }\n        unbind(target, POINTER_MOVE_EVENTS, onPointerMove);\n        unbind(target, POINTER_UP_EVENTS, onPointerUp);\n        dragging = false;\n    }\n    function onClick(e) {\n        if (!disabled && clickPrevented) {\n            prevent(e, true);\n        }\n    }\n    function save(e) {\n        prevBaseEvent = baseEvent;\n        baseEvent = e;\n        basePosition = getPosition();\n    }\n    function move(e) {\n        var velocity = computeVelocity(e);\n        var destination = computeDestination(velocity);\n        var rewind = options.rewind && options.rewindByDrag;\n        reduce(false);\n        if (isFree) {\n            Controller2.scroll(destination, 0, options.snap);\n        } else if (Splide22.is(FADE)) {\n            Controller2.go(orient(sign(velocity)) < 0 ? rewind ? \"<\" : \"-\" : rewind ? \">\" : \"+\");\n        } else if (Splide22.is(SLIDE) && exceeded && rewind) {\n            Controller2.go(exceededLimit(true) ? \">\" : \"<\");\n        } else {\n            Controller2.go(Controller2.toDest(destination), true);\n        }\n        reduce(true);\n    }\n    function shouldStart(e) {\n        var thresholds = options.dragMinThreshold;\n        var isObj = isObject(thresholds);\n        var mouse = isObj && thresholds.mouse || 0;\n        var touch = (isObj ? thresholds.touch : +thresholds) || 10;\n        return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);\n    }\n    function isSliderDirection(e) {\n        return abs(diffCoord(e)) > abs(diffCoord(e, true));\n    }\n    function computeVelocity(e) {\n        if (Splide22.is(LOOP) || !exceeded) {\n            var time = diffTime(e);\n            if (time && time < LOG_INTERVAL) {\n                return diffCoord(e) / time;\n            }\n        }\n        return 0;\n    }\n    function computeDestination(velocity) {\n        return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));\n    }\n    function diffCoord(e, orthogonal) {\n        return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);\n    }\n    function diffTime(e) {\n        return timeOf(e) - timeOf(getBaseEvent(e));\n    }\n    function getBaseEvent(e) {\n        return baseEvent === e && prevBaseEvent || baseEvent;\n    }\n    function coordOf(e, orthogonal) {\n        return (isTouchEvent(e) ? e.changedTouches[0] : e)[\"page\" + resolve(orthogonal ? \"Y\" : \"X\")];\n    }\n    function constrain(diff) {\n        return diff / (exceeded && Splide22.is(SLIDE) ? FRICTION : 1);\n    }\n    function isDraggable(target2) {\n        var noDrag = options.noDrag;\n        return !matches(target2, \".\" + CLASS_PAGINATION_PAGE + \", .\" + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));\n    }\n    function isTouchEvent(e) {\n        return typeof TouchEvent !== \"undefined\" && e instanceof TouchEvent;\n    }\n    function isDragging() {\n        return dragging;\n    }\n    function disable(value) {\n        disabled = value;\n    }\n    return {\n        mount,\n        disable,\n        isDragging\n    };\n}\nvar NORMALIZATION_MAP = {\n    Spacebar: \" \",\n    Right: ARROW_RIGHT,\n    Left: ARROW_LEFT,\n    Up: ARROW_UP,\n    Down: ARROW_DOWN\n};\nfunction normalizeKey(key) {\n    key = isString(key) ? key : key.key;\n    return NORMALIZATION_MAP[key] || key;\n}\nvar KEYBOARD_EVENT = \"keydown\";\nfunction Keyboard(Splide22, Components2, options) {\n    var _EventInterface10 = EventInterface(Splide22), on = _EventInterface10.on, bind = _EventInterface10.bind, unbind = _EventInterface10.unbind;\n    var root = Splide22.root;\n    var resolve = Components2.Direction.resolve;\n    var target;\n    var disabled;\n    function mount() {\n        init();\n        on(EVENT_UPDATED, destroy);\n        on(EVENT_UPDATED, init);\n        on(EVENT_MOVE, onMove);\n    }\n    function init() {\n        var keyboard = options.keyboard;\n        if (keyboard) {\n            target = keyboard === \"global\" ? window : root;\n            bind(target, KEYBOARD_EVENT, onKeydown);\n        }\n    }\n    function destroy() {\n        unbind(target, KEYBOARD_EVENT);\n    }\n    function disable(value) {\n        disabled = value;\n    }\n    function onMove() {\n        var _disabled = disabled;\n        disabled = true;\n        nextTick(function() {\n            disabled = _disabled;\n        });\n    }\n    function onKeydown(e) {\n        if (!disabled) {\n            var key = normalizeKey(e);\n            if (key === resolve(ARROW_LEFT)) {\n                Splide22.go(\"<\");\n            } else if (key === resolve(ARROW_RIGHT)) {\n                Splide22.go(\">\");\n            }\n        }\n    }\n    return {\n        mount,\n        destroy,\n        disable\n    };\n}\nvar SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + \"-lazy\";\nvar SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + \"-srcset\";\nvar IMAGE_SELECTOR = \"[\" + SRC_DATA_ATTRIBUTE + \"], [\" + SRCSET_DATA_ATTRIBUTE + \"]\";\nfunction LazyLoad(Splide22, Components2, options) {\n    var _EventInterface11 = EventInterface(Splide22), on = _EventInterface11.on, off = _EventInterface11.off, bind = _EventInterface11.bind, emit = _EventInterface11.emit;\n    var isSequential = options.lazyLoad === \"sequential\";\n    var events = [\n        EVENT_MOVED,\n        EVENT_SCROLLED\n    ];\n    var entries = [];\n    function mount() {\n        if (options.lazyLoad) {\n            init();\n            on(EVENT_REFRESH, init);\n        }\n    }\n    function init() {\n        empty(entries);\n        register();\n        if (isSequential) {\n            loadNext();\n        } else {\n            off(events);\n            on(events, check);\n            check();\n        }\n    }\n    function register() {\n        Components2.Slides.forEach(function(Slide2) {\n            queryAll(Slide2.slide, IMAGE_SELECTOR).forEach(function(img) {\n                var src = getAttribute(img, SRC_DATA_ATTRIBUTE);\n                var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);\n                if (src !== img.src || srcset !== img.srcset) {\n                    var className = options.classes.spinner;\n                    var parent = img.parentElement;\n                    var spinner = child(parent, \".\" + className) || create(\"span\", className, parent);\n                    entries.push([\n                        img,\n                        Slide2,\n                        spinner\n                    ]);\n                    img.src || display(img, \"none\");\n                }\n            });\n        });\n    }\n    function check() {\n        entries = entries.filter(function(data) {\n            var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;\n            return data[1].isWithin(Splide22.index, distance) ? load(data) : true;\n        });\n        entries.length || off(events);\n    }\n    function load(data) {\n        var img = data[0];\n        addClass(data[1].slide, CLASS_LOADING);\n        bind(img, \"load error\", apply(onLoad, data));\n        setAttribute(img, \"src\", getAttribute(img, SRC_DATA_ATTRIBUTE));\n        setAttribute(img, \"srcset\", getAttribute(img, SRCSET_DATA_ATTRIBUTE));\n        removeAttribute(img, SRC_DATA_ATTRIBUTE);\n        removeAttribute(img, SRCSET_DATA_ATTRIBUTE);\n    }\n    function onLoad(data, e) {\n        var img = data[0], Slide2 = data[1];\n        removeClass(Slide2.slide, CLASS_LOADING);\n        if (e.type !== \"error\") {\n            remove(data[2]);\n            display(img, \"\");\n            emit(EVENT_LAZYLOAD_LOADED, img, Slide2);\n            emit(EVENT_RESIZE);\n        }\n        isSequential && loadNext();\n    }\n    function loadNext() {\n        entries.length && load(entries.shift());\n    }\n    return {\n        mount,\n        destroy: apply(empty, entries),\n        check\n    };\n}\nfunction Pagination(Splide22, Components2, options) {\n    var event = EventInterface(Splide22);\n    var on = event.on, emit = event.emit, bind = event.bind;\n    var Slides2 = Components2.Slides, Elements2 = Components2.Elements, Controller2 = Components2.Controller;\n    var hasFocus = Controller2.hasFocus, getIndex = Controller2.getIndex, go = Controller2.go;\n    var resolve = Components2.Direction.resolve;\n    var placeholder = Elements2.pagination;\n    var items = [];\n    var list;\n    var paginationClasses;\n    function mount() {\n        destroy();\n        on([\n            EVENT_UPDATED,\n            EVENT_REFRESH,\n            EVENT_END_INDEX_CHANGED\n        ], mount);\n        var enabled = options.pagination;\n        placeholder && display(placeholder, enabled ? \"\" : \"none\");\n        if (enabled) {\n            on([\n                EVENT_MOVE,\n                EVENT_SCROLL,\n                EVENT_SCROLLED\n            ], update);\n            createPagination();\n            update();\n            emit(EVENT_PAGINATION_MOUNTED, {\n                list,\n                items\n            }, getAt(Splide22.index));\n        }\n    }\n    function destroy() {\n        if (list) {\n            remove(placeholder ? slice(list.children) : list);\n            removeClass(list, paginationClasses);\n            empty(items);\n            list = null;\n        }\n        event.destroy();\n    }\n    function createPagination() {\n        var length = Splide22.length;\n        var classes = options.classes, i18n = options.i18n, perPage = options.perPage;\n        var max2 = hasFocus() ? Controller2.getEnd() + 1 : ceil(length / perPage);\n        list = placeholder || create(\"ul\", classes.pagination, Elements2.track.parentElement);\n        addClass(list, paginationClasses = CLASS_PAGINATION + \"--\" + getDirection());\n        setAttribute(list, ROLE, \"tablist\");\n        setAttribute(list, ARIA_LABEL, i18n.select);\n        setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? \"vertical\" : \"\");\n        for(var i = 0; i < max2; i++){\n            var li = create(\"li\", null, list);\n            var button = create(\"button\", {\n                class: classes.page,\n                type: \"button\"\n            }, li);\n            var controls = Slides2.getIn(i).map(function(Slide2) {\n                return Slide2.slide.id;\n            });\n            var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;\n            bind(button, \"click\", apply(onClick, i));\n            if (options.paginationKeyboard) {\n                bind(button, \"keydown\", apply(onKeydown, i));\n            }\n            setAttribute(li, ROLE, \"presentation\");\n            setAttribute(button, ROLE, \"tab\");\n            setAttribute(button, ARIA_CONTROLS, controls.join(\" \"));\n            setAttribute(button, ARIA_LABEL, format(text, i + 1));\n            setAttribute(button, TAB_INDEX, -1);\n            items.push({\n                li,\n                button,\n                page: i\n            });\n        }\n    }\n    function onClick(page) {\n        go(\">\" + page, true);\n    }\n    function onKeydown(page, e) {\n        var length = items.length;\n        var key = normalizeKey(e);\n        var dir = getDirection();\n        var nextPage = -1;\n        if (key === resolve(ARROW_RIGHT, false, dir)) {\n            nextPage = ++page % length;\n        } else if (key === resolve(ARROW_LEFT, false, dir)) {\n            nextPage = (--page + length) % length;\n        } else if (key === \"Home\") {\n            nextPage = 0;\n        } else if (key === \"End\") {\n            nextPage = length - 1;\n        }\n        var item = items[nextPage];\n        if (item) {\n            focus(item.button);\n            go(\">\" + nextPage);\n            prevent(e, true);\n        }\n    }\n    function getDirection() {\n        return options.paginationDirection || options.direction;\n    }\n    function getAt(index) {\n        return items[Controller2.toPage(index)];\n    }\n    function update() {\n        var prev = getAt(getIndex(true));\n        var curr = getAt(getIndex());\n        if (prev) {\n            var button = prev.button;\n            removeClass(button, CLASS_ACTIVE);\n            removeAttribute(button, ARIA_SELECTED);\n            setAttribute(button, TAB_INDEX, -1);\n        }\n        if (curr) {\n            var _button = curr.button;\n            addClass(_button, CLASS_ACTIVE);\n            setAttribute(_button, ARIA_SELECTED, true);\n            setAttribute(_button, TAB_INDEX, \"\");\n        }\n        emit(EVENT_PAGINATION_UPDATED, {\n            list,\n            items\n        }, prev, curr);\n    }\n    return {\n        items,\n        mount,\n        destroy,\n        getAt,\n        update\n    };\n}\nvar TRIGGER_KEYS = [\n    \" \",\n    \"Enter\"\n];\nfunction Sync(Splide22, Components2, options) {\n    var isNavigation = options.isNavigation, slideFocus = options.slideFocus;\n    var events = [];\n    function mount() {\n        Splide22.splides.forEach(function(target) {\n            if (!target.isParent) {\n                sync(Splide22, target.splide);\n                sync(target.splide, Splide22);\n            }\n        });\n        if (isNavigation) {\n            navigate();\n        }\n    }\n    function destroy() {\n        events.forEach(function(event) {\n            event.destroy();\n        });\n        empty(events);\n    }\n    function remount() {\n        destroy();\n        mount();\n    }\n    function sync(splide, target) {\n        var event = EventInterface(splide);\n        event.on(EVENT_MOVE, function(index, prev, dest) {\n            target.go(target.is(LOOP) ? dest : index);\n        });\n        events.push(event);\n    }\n    function navigate() {\n        var event = EventInterface(Splide22);\n        var on = event.on;\n        on(EVENT_CLICK, onClick);\n        on(EVENT_SLIDE_KEYDOWN, onKeydown);\n        on([\n            EVENT_MOUNTED,\n            EVENT_UPDATED\n        ], update);\n        events.push(event);\n        event.emit(EVENT_NAVIGATION_MOUNTED, Splide22.splides);\n    }\n    function update() {\n        setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? \"vertical\" : \"\");\n    }\n    function onClick(Slide2) {\n        Splide22.go(Slide2.index);\n    }\n    function onKeydown(Slide2, e) {\n        if (includes(TRIGGER_KEYS, normalizeKey(e))) {\n            onClick(Slide2);\n            prevent(e);\n        }\n    }\n    return {\n        setup: apply(Components2.Media.set, {\n            slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus\n        }, true),\n        mount,\n        destroy,\n        remount\n    };\n}\nfunction Wheel(Splide22, Components2, options) {\n    var _EventInterface12 = EventInterface(Splide22), bind = _EventInterface12.bind;\n    var lastTime = 0;\n    function mount() {\n        if (options.wheel) {\n            bind(Components2.Elements.track, \"wheel\", onWheel, SCROLL_LISTENER_OPTIONS);\n        }\n    }\n    function onWheel(e) {\n        if (e.cancelable) {\n            var deltaY = e.deltaY;\n            var backwards = deltaY < 0;\n            var timeStamp = timeOf(e);\n            var _min = options.wheelMinThreshold || 0;\n            var sleep = options.wheelSleep || 0;\n            if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {\n                Splide22.go(backwards ? \"<\" : \">\");\n                lastTime = timeStamp;\n            }\n            shouldPrevent(backwards) && prevent(e);\n        }\n    }\n    function shouldPrevent(backwards) {\n        return !options.releaseWheel || Splide22.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;\n    }\n    return {\n        mount\n    };\n}\nvar SR_REMOVAL_DELAY = 90;\nfunction Live(Splide22, Components2, options) {\n    var _EventInterface13 = EventInterface(Splide22), on = _EventInterface13.on;\n    var track = Components2.Elements.track;\n    var enabled = options.live && !options.isNavigation;\n    var sr = create(\"span\", CLASS_SR);\n    var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));\n    function mount() {\n        if (enabled) {\n            disable(!Components2.Autoplay.isPaused());\n            setAttribute(track, ARIA_ATOMIC, true);\n            sr.textContent = \"…\";\n            on(EVENT_AUTOPLAY_PLAY, apply(disable, true));\n            on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));\n            on([\n                EVENT_MOVED,\n                EVENT_SCROLLED\n            ], apply(toggle, true));\n        }\n    }\n    function toggle(active) {\n        setAttribute(track, ARIA_BUSY, active);\n        if (active) {\n            append(track, sr);\n            interval.start();\n        } else {\n            remove(sr);\n            interval.cancel();\n        }\n    }\n    function destroy() {\n        removeAttribute(track, [\n            ARIA_LIVE,\n            ARIA_ATOMIC,\n            ARIA_BUSY\n        ]);\n        remove(sr);\n    }\n    function disable(disabled) {\n        if (enabled) {\n            setAttribute(track, ARIA_LIVE, disabled ? \"off\" : \"polite\");\n        }\n    }\n    return {\n        mount,\n        disable,\n        destroy\n    };\n}\nvar ComponentConstructors = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    Media,\n    Direction,\n    Elements,\n    Slides,\n    Layout,\n    Clones,\n    Move,\n    Controller,\n    Arrows,\n    Autoplay,\n    Cover,\n    Scroll,\n    Drag,\n    Keyboard,\n    LazyLoad,\n    Pagination,\n    Sync,\n    Wheel,\n    Live\n});\nvar I18N = {\n    prev: \"Previous slide\",\n    next: \"Next slide\",\n    first: \"Go to first slide\",\n    last: \"Go to last slide\",\n    slideX: \"Go to slide %s\",\n    pageX: \"Go to page %s\",\n    play: \"Start autoplay\",\n    pause: \"Pause autoplay\",\n    carousel: \"carousel\",\n    slide: \"slide\",\n    select: \"Select a slide to show\",\n    slideLabel: \"%s of %s\"\n};\nvar DEFAULTS = {\n    type: \"slide\",\n    role: \"region\",\n    speed: 400,\n    perPage: 1,\n    cloneStatus: true,\n    arrows: true,\n    pagination: true,\n    paginationKeyboard: true,\n    interval: 5e3,\n    pauseOnHover: true,\n    pauseOnFocus: true,\n    resetProgress: true,\n    easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n    drag: true,\n    direction: \"ltr\",\n    trimSpace: true,\n    focusableNodes: \"a, button, textarea, input, select, iframe\",\n    live: true,\n    classes: CLASSES,\n    i18n: I18N,\n    reducedMotion: {\n        speed: 0,\n        rewindSpeed: 0,\n        autoplay: \"pause\"\n    }\n};\nfunction Fade(Splide22, Components2, options) {\n    var Slides2 = Components2.Slides;\n    function mount() {\n        EventInterface(Splide22).on([\n            EVENT_MOUNTED,\n            EVENT_REFRESH\n        ], init);\n    }\n    function init() {\n        Slides2.forEach(function(Slide2) {\n            Slide2.style(\"transform\", \"translateX(-\" + 100 * Slide2.index + \"%)\");\n        });\n    }\n    function start(index, done) {\n        Slides2.style(\"transition\", \"opacity \" + options.speed + \"ms \" + options.easing);\n        nextTick(done);\n    }\n    return {\n        mount,\n        start,\n        cancel: noop\n    };\n}\nfunction Slide(Splide22, Components2, options) {\n    var Move2 = Components2.Move, Controller2 = Components2.Controller, Scroll2 = Components2.Scroll;\n    var list = Components2.Elements.list;\n    var transition = apply(style, list, \"transition\");\n    var endCallback;\n    function mount() {\n        EventInterface(Splide22).bind(list, \"transitionend\", function(e) {\n            if (e.target === list && endCallback) {\n                cancel();\n                endCallback();\n            }\n        });\n    }\n    function start(index, done) {\n        var destination = Move2.toPosition(index, true);\n        var position = Move2.getPosition();\n        var speed = getSpeed(index);\n        if (abs(destination - position) >= 1 && speed >= 1) {\n            if (options.useScroll) {\n                Scroll2.scroll(destination, speed, false, done);\n            } else {\n                transition(\"transform \" + speed + \"ms \" + options.easing);\n                Move2.translate(destination, true);\n                endCallback = done;\n            }\n        } else {\n            Move2.jump(index);\n            done();\n        }\n    }\n    function cancel() {\n        transition(\"\");\n        Scroll2.cancel();\n    }\n    function getSpeed(index) {\n        var rewindSpeed = options.rewindSpeed;\n        if (Splide22.is(SLIDE) && rewindSpeed) {\n            var prev = Controller2.getIndex(true);\n            var end = Controller2.getEnd();\n            if (prev === 0 && index >= end || prev >= end && index === 0) {\n                return rewindSpeed;\n            }\n        }\n        return options.speed;\n    }\n    return {\n        mount,\n        start,\n        cancel\n    };\n}\nvar _Splide = /* @__PURE__ */ function() {\n    function _Splide2(target, options) {\n        this.event = EventInterface();\n        this.Components = {};\n        this.state = State(CREATED);\n        this.splides = [];\n        this._o = {};\n        this._E = {};\n        var root = isString(target) ? query(document, target) : target;\n        assert(root, root + \" is invalid.\");\n        this.root = root;\n        options = merge({\n            label: getAttribute(root, ARIA_LABEL) || \"\",\n            labelledby: getAttribute(root, ARIA_LABELLEDBY) || \"\"\n        }, DEFAULTS, _Splide2.defaults, options || {});\n        try {\n            merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));\n        } catch (e) {\n            assert(false, \"Invalid JSON\");\n        }\n        this._o = Object.create(merge({}, options));\n    }\n    var _proto = _Splide2.prototype;\n    _proto.mount = function mount(Extensions, Transition) {\n        var _this = this;\n        var state = this.state, Components2 = this.Components;\n        assert(state.is([\n            CREATED,\n            DESTROYED\n        ]), \"Already mounted!\");\n        state.set(CREATED);\n        this._C = Components2;\n        this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);\n        this._E = Extensions || this._E;\n        var Constructors = assign({}, ComponentConstructors, this._E, {\n            Transition: this._T\n        });\n        forOwn(Constructors, function(Component, key) {\n            var component = Component(_this, Components2, _this._o);\n            Components2[key] = component;\n            component.setup && component.setup();\n        });\n        forOwn(Components2, function(component) {\n            component.mount && component.mount();\n        });\n        this.emit(EVENT_MOUNTED);\n        addClass(this.root, CLASS_INITIALIZED);\n        state.set(IDLE);\n        this.emit(EVENT_READY);\n        return this;\n    };\n    _proto.sync = function sync(splide) {\n        this.splides.push({\n            splide\n        });\n        splide.splides.push({\n            splide: this,\n            isParent: true\n        });\n        if (this.state.is(IDLE)) {\n            this._C.Sync.remount();\n            splide.Components.Sync.remount();\n        }\n        return this;\n    };\n    _proto.go = function go(control) {\n        this._C.Controller.go(control);\n        return this;\n    };\n    _proto.on = function on(events, callback) {\n        this.event.on(events, callback);\n        return this;\n    };\n    _proto.off = function off(events) {\n        this.event.off(events);\n        return this;\n    };\n    _proto.emit = function emit(event) {\n        var _this$event;\n        (_this$event = this.event).emit.apply(_this$event, [\n            event\n        ].concat(slice(arguments, 1)));\n        return this;\n    };\n    _proto.add = function add(slides, index) {\n        this._C.Slides.add(slides, index);\n        return this;\n    };\n    _proto.remove = function remove2(matcher) {\n        this._C.Slides.remove(matcher);\n        return this;\n    };\n    _proto.is = function is(type) {\n        return this._o.type === type;\n    };\n    _proto.refresh = function refresh() {\n        this.emit(EVENT_REFRESH);\n        return this;\n    };\n    _proto.destroy = function destroy(completely) {\n        if (completely === void 0) {\n            completely = true;\n        }\n        var event = this.event, state = this.state;\n        if (state.is(CREATED)) {\n            EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));\n        } else {\n            forOwn(this._C, function(component) {\n                component.destroy && component.destroy(completely);\n            }, true);\n            event.emit(EVENT_DESTROY);\n            event.destroy();\n            completely && empty(this.splides);\n            state.set(DESTROYED);\n        }\n        return this;\n    };\n    _createClass(_Splide2, [\n        {\n            key: \"options\",\n            get: function get() {\n                return this._o;\n            },\n            set: function set(options) {\n                this._C.Media.set(options, true, true);\n            }\n        },\n        {\n            key: \"length\",\n            get: function get() {\n                return this._C.Slides.getLength(true);\n            }\n        },\n        {\n            key: \"index\",\n            get: function get() {\n                return this._C.Controller.getIndex();\n            }\n        }\n    ]);\n    return _Splide2;\n}();\nvar Splide = _Splide;\nSplide.defaults = {};\nSplide.STATES = STATES;\n// src/js/components/Splide/Splide.tsx\n\n// src/js/constants/events.ts\nvar EVENTS = [\n    [\n        EVENT_MOUNTED,\n        \"onMounted\"\n    ],\n    [\n        EVENT_READY,\n        \"onReady\"\n    ],\n    [\n        EVENT_MOVE,\n        \"onMove\"\n    ],\n    [\n        EVENT_MOVED,\n        \"onMoved\"\n    ],\n    [\n        EVENT_CLICK,\n        \"onClick\"\n    ],\n    [\n        EVENT_ACTIVE,\n        \"onActive\"\n    ],\n    [\n        EVENT_INACTIVE,\n        \"onInactive\"\n    ],\n    [\n        EVENT_VISIBLE,\n        \"onVisible\"\n    ],\n    [\n        EVENT_HIDDEN,\n        \"onHidden\"\n    ],\n    [\n        EVENT_REFRESH,\n        \"onRefresh\"\n    ],\n    [\n        EVENT_UPDATED,\n        \"onUpdated\"\n    ],\n    [\n        EVENT_RESIZE,\n        \"onResize\"\n    ],\n    [\n        EVENT_RESIZED,\n        \"onResized\"\n    ],\n    [\n        EVENT_DRAG,\n        \"onDrag\"\n    ],\n    [\n        EVENT_DRAGGING,\n        \"onDragging\"\n    ],\n    [\n        EVENT_DRAGGED,\n        \"onDragged\"\n    ],\n    [\n        EVENT_SCROLL,\n        \"onScroll\"\n    ],\n    [\n        EVENT_SCROLLED,\n        \"onScrolled\"\n    ],\n    [\n        EVENT_DESTROY,\n        \"onDestroy\"\n    ],\n    [\n        EVENT_ARROWS_MOUNTED,\n        \"onArrowsMounted\"\n    ],\n    [\n        EVENT_ARROWS_UPDATED,\n        \"onArrowsUpdated\"\n    ],\n    [\n        EVENT_PAGINATION_MOUNTED,\n        \"onPaginationMounted\"\n    ],\n    [\n        EVENT_PAGINATION_UPDATED,\n        \"onPaginationUpdated\"\n    ],\n    [\n        EVENT_NAVIGATION_MOUNTED,\n        \"onNavigationMounted\"\n    ],\n    [\n        EVENT_AUTOPLAY_PLAY,\n        \"onAutoplayPlay\"\n    ],\n    [\n        EVENT_AUTOPLAY_PLAYING,\n        \"onAutoplayPlaying\"\n    ],\n    [\n        EVENT_AUTOPLAY_PAUSE,\n        \"onAutoplayPause\"\n    ],\n    [\n        EVENT_LAZYLOAD_LOADED,\n        \"onLazyLoadLoaded\"\n    ]\n];\n// src/js/utils/classNames/classNames.ts\nfunction classNames(...classes) {\n    return classes.filter(Boolean).join(\" \");\n}\n// src/js/utils/isObject/isObject.ts\nfunction isObject2(subject) {\n    return subject !== null && typeof subject === \"object\";\n}\n// src/js/utils/isEqualDeep/isEqualDeep.ts\nfunction isEqualDeep(subject1, subject2) {\n    if (Array.isArray(subject1) && Array.isArray(subject2)) {\n        return subject1.length === subject2.length && !subject1.some((elm, index)=>!isEqualDeep(elm, subject2[index]));\n    }\n    if (isObject2(subject1) && isObject2(subject2)) {\n        const keys1 = Object.keys(subject1);\n        const keys2 = Object.keys(subject2);\n        return keys1.length === keys2.length && !keys1.some((key)=>{\n            return !Object.prototype.hasOwnProperty.call(subject2, key) || !isEqualDeep(subject1[key], subject2[key]);\n        });\n    }\n    return subject1 === subject2;\n}\n// src/js/utils/isEqualShallow/isEqualShallow.ts\nfunction isEqualShallow(array1, array2) {\n    return array1.length === array2.length && !array1.some((elm, index)=>elm !== array2[index]);\n}\n// src/js/utils/forOwn/forOwn.ts\nfunction forOwn2(object, iteratee) {\n    if (object) {\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            if (key !== \"__proto__\") {\n                if (iteratee(object[key], key) === false) {\n                    break;\n                }\n            }\n        }\n    }\n    return object;\n}\n// src/js/utils/merge/merge.ts\nfunction merge2(object, source) {\n    const merged = object;\n    forOwn2(source, (value, key)=>{\n        if (Array.isArray(value)) {\n            merged[key] = value.slice();\n        } else if (isObject2(value)) {\n            merged[key] = merge2(isObject2(merged[key]) ? merged[key] : {}, value);\n        } else {\n            merged[key] = value;\n        }\n    });\n    return merged;\n}\n// src/js/components/SplideTrack/SplideTrack.tsx\n\nvar SplideTrack = ({ children: children2, className, ...props })=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: classNames(\"splide__track\", className),\n        ...props\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", {\n        className: \"splide__list\"\n    }, children2));\n};\n// src/js/components/Splide/Splide.tsx\nvar Splide2 = class extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(){\n        super(...arguments);\n        this.splideRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        this.slides = [];\n    }\n    componentDidMount() {\n        const { options, extensions, transition } = this.props;\n        const { current } = this.splideRef;\n        if (current) {\n            this.splide = new Splide(current, options);\n            this.bind(this.splide);\n            this.splide.mount(extensions, transition);\n            this.options = merge2({}, options || {});\n            this.slides = this.getSlides();\n        }\n    }\n    componentWillUnmount() {\n        if (this.splide) {\n            this.splide.destroy();\n            this.splide = void 0;\n        }\n        this.options = void 0;\n        this.slides.length = 0;\n    }\n    componentDidUpdate() {\n        if (!this.splide) {\n            return;\n        }\n        const { options } = this.props;\n        if (options && !isEqualDeep(this.options, options)) {\n            this.splide.options = options;\n            this.options = merge2({}, options);\n        }\n        const newSlides = this.getSlides();\n        if (!isEqualShallow(this.slides, newSlides)) {\n            this.splide.refresh();\n            this.slides = newSlides;\n        }\n    }\n    sync(splide) {\n        var _a;\n        (_a = this.splide) == null ? void 0 : _a.sync(splide);\n    }\n    go(control) {\n        var _a;\n        (_a = this.splide) == null ? void 0 : _a.go(control);\n    }\n    getSlides() {\n        var _a;\n        if (this.splide) {\n            const children2 = (_a = this.splide.Components.Elements) == null ? void 0 : _a.list.children;\n            return children2 && Array.prototype.slice.call(children2) || [];\n        }\n        return [];\n    }\n    bind(splide) {\n        EVENTS.forEach(([event, name])=>{\n            const handler = this.props[name];\n            if (typeof handler === \"function\") {\n                splide.on(event, (...args)=>{\n                    handler(splide, ...args);\n                });\n            }\n        });\n    }\n    omit(props, keys) {\n        keys.forEach((key)=>{\n            if (Object.prototype.hasOwnProperty.call(props, key)) {\n                delete props[key];\n            }\n        });\n        return props;\n    }\n    render() {\n        const { className, tag: Root = \"div\", hasTrack = true, children: children2, ...props } = this.props;\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Root, {\n            className: classNames(\"splide\", className),\n            ref: this.splideRef,\n            ...this.omit(props, [\n                \"options\",\n                ...EVENTS.map((event)=>event[1])\n            ])\n        }, hasTrack ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SplideTrack, null, children2) : children2);\n    }\n};\n// src/js/components/SplideSlide/SplideSlide.tsx\n\nvar SplideSlide = ({ children: children2, className, ...props })=>{\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n        className: classNames(\"splide__slide\", className),\n        ...props\n    }, children2);\n};\n /*!\n * Splide.js\n * Version  : 4.1.3\n * License  : MIT\n * Copyright: 2022 Naotoshi Fujita\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3JlYWN0LXNwbGlkZS9kaXN0L2pzL3JlYWN0LXNwbGlkZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxzREFBc0Q7QUFDdEQsU0FBU0Esa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFDdEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztRQUNyQyxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFDekJFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQ2pERCxXQUFXRSxZQUFZLEdBQUc7UUFDMUIsSUFBSSxXQUFXRixZQUNiQSxXQUFXRyxRQUFRLEdBQUc7UUFDeEJDLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUUksV0FBV00sR0FBRyxFQUFFTjtJQUNoRDtBQUNGO0FBQ0EsU0FBU08sYUFBYUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDeEQsSUFBSUQsWUFDRmQsa0JBQWtCYSxZQUFZRyxTQUFTLEVBQUVGO0lBQzNDLElBQUlDLGFBQ0ZmLGtCQUFrQmEsYUFBYUU7SUFDakNOLE9BQU9DLGNBQWMsQ0FBQ0csYUFBYSxhQUFhO1FBQUVMLFVBQVU7SUFBTTtJQUNsRSxPQUFPSztBQUNUO0FBQ0EsSUFBSUksK0JBQStCO0FBQ25DLElBQUlDLFVBQVU7QUFDZCxJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsT0FBTztBQUNYLElBQUlDLFNBQVM7QUFDYixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLFdBQVc7QUFDZixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLFNBQVM7SUFDWFA7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7QUFDRjtBQUNBLFNBQVNFLE1BQU1DLEtBQUs7SUFDbEJBLE1BQU12QixNQUFNLEdBQUc7QUFDakI7QUFDQSxTQUFTd0IsTUFBTUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLEdBQUc7SUFDbEMsT0FB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QUNoQkEsS0FBS2pDLE9BQU8sQ0FBQyxDQUFDbkQ7WUFDWixJQUFJRixPQUFPTyxTQUFTLENBQUM0eEIsY0FBYyxDQUFDM3dCLElBQUksQ0FBQy9CLE9BQU9TLE1BQU07Z0JBQ3BELE9BQU9ULEtBQUssQ0FBQ1MsSUFBSTtZQUNuQjtRQUNGO1FBQ0EsT0FBT1Q7SUFDVDtJQUNBZzBCLFNBQVM7UUFDUCxNQUFNLEVBQUV0c0IsU0FBUyxFQUFFWixLQUFLbXRCLE9BQU8sS0FBSyxFQUFFQyxXQUFXLElBQUksRUFBRTN1QixVQUFVVixTQUFTLEVBQUUsR0FBRzdFLE9BQU8sR0FBRyxJQUFJLENBQUNBLEtBQUs7UUFDbkcsT0FBTyxhQUFhLGlCQUFHK3hCLDBEQUFvQixDQUFDa0MsTUFBTTtZQUNoRHZzQixXQUFXdXFCLFdBQVcsVUFBVXZxQjtZQUNoQ3pDLEtBQUssSUFBSSxDQUFDbXVCLFNBQVM7WUFDbkIsR0FBRyxJQUFJLENBQUMvc0IsSUFBSSxDQUFDckcsT0FBTztnQkFBQzttQkFBY2d5QixPQUFPN1csR0FBRyxDQUFDLENBQUMzUCxRQUFVQSxLQUFLLENBQUMsRUFBRTthQUFFLENBQUM7UUFDdEUsR0FBRzBvQixXQUFXLGFBQWEsaUJBQUduQywwREFBb0IsQ0FBQ2tCLGFBQWEsTUFBTXB1QixhQUFhQTtJQUNyRjtBQUNGO0FBRUEsZ0RBQWdEO0FBQ3JCO0FBQzNCLElBQUl1dkIsY0FBYyxDQUFDLEVBQUU3dUIsVUFBVVYsU0FBUyxFQUFFNkMsU0FBUyxFQUFFLEdBQUcxSCxPQUFPO0lBQzdELE9BQU8sYUFBYSxpQkFBR20wQiwwREFBb0IsQ0FBQyxNQUFNO1FBQ2hEenNCLFdBQVd1cUIsV0FBVyxpQkFBaUJ2cUI7UUFDdkMsR0FBRzFILEtBQUs7SUFDVixHQUFHNkU7QUFDTDtBQUtFLENBQ0Y7Ozs7O0NBS0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maW50by8uL25vZGVfbW9kdWxlcy9Ac3BsaWRlanMvcmVhY3Qtc3BsaWRlL2Rpc3QvanMvcmVhY3Qtc3BsaWRlLmVzbS5qcz9jZjM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIG5vZGVfbW9kdWxlcy9Ac3BsaWRlanMvc3BsaWRlL2Rpc3QvanMvc3BsaWRlLmVzbS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcilcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcylcbiAgICBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpXG4gICAgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxudmFyIE1FRElBX1BSRUZFUlNfUkVEVUNFRF9NT1RJT04gPSBcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCI7XG52YXIgQ1JFQVRFRCA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgSURMRSA9IDM7XG52YXIgTU9WSU5HID0gNDtcbnZhciBTQ1JPTExJTkcgPSA1O1xudmFyIERSQUdHSU5HID0gNjtcbnZhciBERVNUUk9ZRUQgPSA3O1xudmFyIFNUQVRFUyA9IHtcbiAgQ1JFQVRFRCxcbiAgTU9VTlRFRCxcbiAgSURMRSxcbiAgTU9WSU5HLFxuICBTQ1JPTExJTkcsXG4gIERSQUdHSU5HLFxuICBERVNUUk9ZRURcbn07XG5mdW5jdGlvbiBlbXB0eShhcnJheSkge1xuICBhcnJheS5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gc2xpY2UoYXJyYXlMaWtlLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UsIHN0YXJ0LCBlbmQpO1xufVxuZnVuY3Rpb24gYXBwbHkoZnVuYykge1xuICByZXR1cm4gZnVuYy5iaW5kLmFwcGx5KGZ1bmMsIFtudWxsXS5jb25jYXQoc2xpY2UoYXJndW1lbnRzLCAxKSkpO1xufVxudmFyIG5leHRUaWNrID0gc2V0VGltZW91dDtcbnZhciBub29wID0gZnVuY3Rpb24gbm9vcDIoKSB7XG59O1xuZnVuY3Rpb24gcmFmKGZ1bmMpIHtcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jKTtcbn1cbmZ1bmN0aW9uIHR5cGVPZih0eXBlLCBzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gdHlwZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICFpc051bGwoc3ViamVjdCkgJiYgdHlwZU9mKFwib2JqZWN0XCIsIHN1YmplY3QpO1xufVxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGlzRnVuY3Rpb24gPSBhcHBseSh0eXBlT2YsIFwiZnVuY3Rpb25cIik7XG52YXIgaXNTdHJpbmcgPSBhcHBseSh0eXBlT2YsIFwic3RyaW5nXCIpO1xudmFyIGlzVW5kZWZpbmVkID0gYXBwbHkodHlwZU9mLCBcInVuZGVmaW5lZFwiKTtcbmZ1bmN0aW9uIGlzTnVsbChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChzdWJqZWN0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHN1YmplY3QgaW5zdGFuY2VvZiAoc3ViamVjdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuSFRNTEVsZW1lbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gZm9yRWFjaCh2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gIHRvQXJyYXkodmFsdWVzKS5mb3JFYWNoKGl0ZXJhdGVlKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn1cbmZ1bmN0aW9uIHB1c2goYXJyYXksIGl0ZW1zKSB7XG4gIGFycmF5LnB1c2guYXBwbHkoYXJyYXksIHRvQXJyYXkoaXRlbXMpKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxtLCBjbGFzc2VzLCBhZGQpIHtcbiAgaWYgKGVsbSkge1xuICAgIGZvckVhY2goY2xhc3NlcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZWxtLmNsYXNzTGlzdFthZGQgPyBcImFkZFwiIDogXCJyZW1vdmVcIl0obmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZENsYXNzKGVsbSwgY2xhc3Nlcykge1xuICB0b2dnbGVDbGFzcyhlbG0sIGlzU3RyaW5nKGNsYXNzZXMpID8gY2xhc3Nlcy5zcGxpdChcIiBcIikgOiBjbGFzc2VzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZChwYXJlbnQsIGNoaWxkcmVuMikge1xuICBmb3JFYWNoKGNoaWxkcmVuMiwgcGFyZW50LmFwcGVuZENoaWxkLmJpbmQocGFyZW50KSk7XG59XG5mdW5jdGlvbiBiZWZvcmUobm9kZXMsIHJlZikge1xuICBmb3JFYWNoKG5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IChyZWYgfHwgbm9kZSkucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXMoZWxtLCBzZWxlY3Rvcikge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChlbG0pICYmIChlbG1bXCJtc01hdGNoZXNTZWxlY3RvclwiXSB8fCBlbG0ubWF0Y2hlcykuY2FsbChlbG0sIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgdmFyIGNoaWxkcmVuMiA9IHBhcmVudCA/IHNsaWNlKHBhcmVudC5jaGlsZHJlbikgOiBbXTtcbiAgcmV0dXJuIHNlbGVjdG9yID8gY2hpbGRyZW4yLmZpbHRlcihmdW5jdGlvbihjaGlsZDIpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyhjaGlsZDIsIHNlbGVjdG9yKTtcbiAgfSkgOiBjaGlsZHJlbjI7XG59XG5mdW5jdGlvbiBjaGlsZChwYXJlbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA/IGNoaWxkcmVuKHBhcmVudCwgc2VsZWN0b3IpWzBdIDogcGFyZW50LmZpcnN0RWxlbWVudENoaWxkO1xufVxudmFyIG93bktleXMgPSBPYmplY3Qua2V5cztcbmZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlLCByaWdodCkge1xuICBpZiAob2JqZWN0KSB7XG4gICAgKHJpZ2h0ID8gb3duS2V5cyhvYmplY3QpLnJldmVyc2UoKSA6IG93bktleXMob2JqZWN0KSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGtleSAhPT0gXCJfX3Byb3RvX19cIiAmJiBpdGVyYXRlZShvYmplY3Rba2V5XSwga2V5KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gYXNzaWduKG9iamVjdCkge1xuICBzbGljZShhcmd1bWVudHMsIDEpLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgZm9yT3duKHNvdXJjZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBtZXJnZShvYmplY3QpIHtcbiAgc2xpY2UoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGZvck93bihzb3VyY2UsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IG1lcmdlKHt9LCBpc09iamVjdChvYmplY3Rba2V5XSkgPyBvYmplY3Rba2V5XSA6IHt9LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIG9taXQob2JqZWN0LCBrZXlzKSB7XG4gIGZvckVhY2goa2V5cyB8fCBvd25LZXlzKG9iamVjdCksIGZ1bmN0aW9uKGtleSkge1xuICAgIGRlbGV0ZSBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxtcywgYXR0cnMpIHtcbiAgZm9yRWFjaChlbG1zLCBmdW5jdGlvbihlbG0pIHtcbiAgICBmb3JFYWNoKGF0dHJzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBlbG0gJiYgZWxtLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxtcywgYXR0cnMsIHZhbHVlKSB7XG4gIGlmIChpc09iamVjdChhdHRycykpIHtcbiAgICBmb3JPd24oYXR0cnMsIGZ1bmN0aW9uKHZhbHVlMiwgbmFtZSkge1xuICAgICAgc2V0QXR0cmlidXRlKGVsbXMsIG5hbWUsIHZhbHVlMik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaChlbG1zLCBmdW5jdGlvbihlbG0pIHtcbiAgICAgIGlzTnVsbCh2YWx1ZSkgfHwgdmFsdWUgPT09IFwiXCIgPyByZW1vdmVBdHRyaWJ1dGUoZWxtLCBhdHRycykgOiBlbG0uc2V0QXR0cmlidXRlKGF0dHJzLCBTdHJpbmcodmFsdWUpKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlKHRhZywgYXR0cnMsIHBhcmVudCkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAoYXR0cnMpIHtcbiAgICBpc1N0cmluZyhhdHRycykgPyBhZGRDbGFzcyhlbG0sIGF0dHJzKSA6IHNldEF0dHJpYnV0ZShlbG0sIGF0dHJzKTtcbiAgfVxuICBwYXJlbnQgJiYgYXBwZW5kKHBhcmVudCwgZWxtKTtcbiAgcmV0dXJuIGVsbTtcbn1cbmZ1bmN0aW9uIHN0eWxlKGVsbSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsbSlbcHJvcF07XG4gIH1cbiAgaWYgKCFpc051bGwodmFsdWUpKSB7XG4gICAgZWxtLnN0eWxlW3Byb3BdID0gXCJcIiArIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwbGF5KGVsbSwgZGlzcGxheTIpIHtcbiAgc3R5bGUoZWxtLCBcImRpc3BsYXlcIiwgZGlzcGxheTIpO1xufVxuZnVuY3Rpb24gZm9jdXMoZWxtKSB7XG4gIGVsbVtcInNldEFjdGl2ZVwiXSAmJiBlbG1bXCJzZXRBY3RpdmVcIl0oKSB8fCBlbG0uZm9jdXMoe1xuICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWxtLCBhdHRyKSB7XG4gIHJldHVybiBlbG0uZ2V0QXR0cmlidXRlKGF0dHIpO1xufVxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxtLCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIGVsbSAmJiBlbG0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG59XG5mdW5jdGlvbiByZWN0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG5vZGVzKSB7XG4gIGZvckVhY2gobm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIGNoaWxkKG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgXCJ0ZXh0L2h0bWxcIikuYm9keSk7XG59XG5mdW5jdGlvbiBwcmV2ZW50KGUsIHN0b3BQcm9wYWdhdGlvbikge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGlmIChzdG9wUHJvcGFnYXRpb24pIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXJ5KHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBxdWVyeUFsbChwYXJlbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA/IHNsaWNlKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsbSwgY2xhc3Nlcykge1xuICB0b2dnbGVDbGFzcyhlbG0sIGNsYXNzZXMsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHRpbWVPZihlKSB7XG4gIHJldHVybiBlLnRpbWVTdGFtcDtcbn1cbmZ1bmN0aW9uIHVuaXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUgPyB2YWx1ZSArIFwicHhcIiA6IFwiXCI7XG59XG52YXIgUFJPSkVDVF9DT0RFID0gXCJzcGxpZGVcIjtcbnZhciBEQVRBX0FUVFJJQlVURSA9IFwiZGF0YS1cIiArIFBST0pFQ1RfQ09ERTtcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbXCIgKyBQUk9KRUNUX0NPREUgKyBcIl0gXCIgKyAobWVzc2FnZSB8fCBcIlwiKSk7XG4gIH1cbn1cbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBhYnMgPSBNYXRoLmFicztcbmZ1bmN0aW9uIGFwcHJveGltYXRlbHlFcXVhbCh4LCB5LCBlcHNpbG9uKSB7XG4gIHJldHVybiBhYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cbmZ1bmN0aW9uIGJldHdlZW4obnVtYmVyLCB4LCB5LCBleGNsdXNpdmUpIHtcbiAgdmFyIG1pbmltdW0gPSBtaW4oeCwgeSk7XG4gIHZhciBtYXhpbXVtID0gbWF4KHgsIHkpO1xuICByZXR1cm4gZXhjbHVzaXZlID8gbWluaW11bSA8IG51bWJlciAmJiBudW1iZXIgPCBtYXhpbXVtIDogbWluaW11bSA8PSBudW1iZXIgJiYgbnVtYmVyIDw9IG1heGltdW07XG59XG5mdW5jdGlvbiBjbGFtcChudW1iZXIsIHgsIHkpIHtcbiAgdmFyIG1pbmltdW0gPSBtaW4oeCwgeSk7XG4gIHZhciBtYXhpbXVtID0gbWF4KHgsIHkpO1xuICByZXR1cm4gbWluKG1heChtaW5pbXVtLCBudW1iZXIpLCBtYXhpbXVtKTtcbn1cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4gKyh4ID4gMCkgLSArKHggPCAwKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdChzdHJpbmcsIHJlcGxhY2VtZW50cykge1xuICBmb3JFYWNoKHJlcGxhY2VtZW50cywgZnVuY3Rpb24ocmVwbGFjZW1lbnQpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShcIiVzXCIsIFwiXCIgKyByZXBsYWNlbWVudCk7XG4gIH0pO1xuICByZXR1cm4gc3RyaW5nO1xufVxuZnVuY3Rpb24gcGFkKG51bWJlcikge1xuICByZXR1cm4gbnVtYmVyIDwgMTAgPyBcIjBcIiArIG51bWJlciA6IFwiXCIgKyBudW1iZXI7XG59XG52YXIgaWRzID0ge307XG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyBwYWQoaWRzW3ByZWZpeF0gPSAoaWRzW3ByZWZpeF0gfHwgMCkgKyAxKTtcbn1cbmZ1bmN0aW9uIEV2ZW50QmluZGVyKCkge1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIGZ1bmN0aW9uIGJpbmQodGFyZ2V0cywgZXZlbnRzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGZvckVhY2hFdmVudCh0YXJnZXRzLCBldmVudHMsIGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIG5hbWVzcGFjZSkge1xuICAgICAgdmFyIGlzRXZlbnRUYXJnZXQgPSBcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiB0YXJnZXQ7XG4gICAgICB2YXIgcmVtb3ZlciA9IGlzRXZlbnRUYXJnZXQgPyB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHRhcmdldCwgZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zKSA6IHRhcmdldFtcInJlbW92ZUxpc3RlbmVyXCJdLmJpbmQodGFyZ2V0LCBjYWxsYmFjayk7XG4gICAgICBpc0V2ZW50VGFyZ2V0ID8gdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zKSA6IHRhcmdldFtcImFkZExpc3RlbmVyXCJdKGNhbGxiYWNrKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKFt0YXJnZXQsIGV2ZW50LCBuYW1lc3BhY2UsIGNhbGxiYWNrLCByZW1vdmVyXSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdW5iaW5kKHRhcmdldHMsIGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICBmb3JFYWNoRXZlbnQodGFyZ2V0cywgZXZlbnRzLCBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyWzBdID09PSB0YXJnZXQgJiYgbGlzdGVuZXJbMV0gPT09IGV2ZW50ICYmIGxpc3RlbmVyWzJdID09PSBuYW1lc3BhY2UgJiYgKCFjYWxsYmFjayB8fCBsaXN0ZW5lclszXSA9PT0gY2FsbGJhY2spKSB7XG4gICAgICAgICAgbGlzdGVuZXJbNF0oKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaCh0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICAgIHZhciBlO1xuICAgIHZhciBidWJibGVzID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGUgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICBidWJibGVzLFxuICAgICAgICBkZXRhaWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBkZXRhaWwpO1xuICAgIH1cbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBmb3JFYWNoRXZlbnQodGFyZ2V0cywgZXZlbnRzLCBpdGVyYXRlZSkge1xuICAgIGZvckVhY2godGFyZ2V0cywgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB0YXJnZXQgJiYgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2ZW50czIpIHtcbiAgICAgICAgZXZlbnRzMi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihldmVudE5TKSB7XG4gICAgICAgICAgdmFyIGZyYWdtZW50ID0gZXZlbnROUy5zcGxpdChcIi5cIik7XG4gICAgICAgICAgaXRlcmF0ZWUodGFyZ2V0LCBmcmFnbWVudFswXSwgZnJhZ21lbnRbMV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGF0YVs0XSgpO1xuICAgIH0pO1xuICAgIGVtcHR5KGxpc3RlbmVycyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiaW5kLFxuICAgIHVuYmluZCxcbiAgICBkaXNwYXRjaCxcbiAgICBkZXN0cm95XG4gIH07XG59XG52YXIgRVZFTlRfTU9VTlRFRCA9IFwibW91bnRlZFwiO1xudmFyIEVWRU5UX1JFQURZID0gXCJyZWFkeVwiO1xudmFyIEVWRU5UX01PVkUgPSBcIm1vdmVcIjtcbnZhciBFVkVOVF9NT1ZFRCA9IFwibW92ZWRcIjtcbnZhciBFVkVOVF9DTElDSyA9IFwiY2xpY2tcIjtcbnZhciBFVkVOVF9BQ1RJVkUgPSBcImFjdGl2ZVwiO1xudmFyIEVWRU5UX0lOQUNUSVZFID0gXCJpbmFjdGl2ZVwiO1xudmFyIEVWRU5UX1ZJU0lCTEUgPSBcInZpc2libGVcIjtcbnZhciBFVkVOVF9ISURERU4gPSBcImhpZGRlblwiO1xudmFyIEVWRU5UX1JFRlJFU0ggPSBcInJlZnJlc2hcIjtcbnZhciBFVkVOVF9VUERBVEVEID0gXCJ1cGRhdGVkXCI7XG52YXIgRVZFTlRfUkVTSVpFID0gXCJyZXNpemVcIjtcbnZhciBFVkVOVF9SRVNJWkVEID0gXCJyZXNpemVkXCI7XG52YXIgRVZFTlRfRFJBRyA9IFwiZHJhZ1wiO1xudmFyIEVWRU5UX0RSQUdHSU5HID0gXCJkcmFnZ2luZ1wiO1xudmFyIEVWRU5UX0RSQUdHRUQgPSBcImRyYWdnZWRcIjtcbnZhciBFVkVOVF9TQ1JPTEwgPSBcInNjcm9sbFwiO1xudmFyIEVWRU5UX1NDUk9MTEVEID0gXCJzY3JvbGxlZFwiO1xudmFyIEVWRU5UX09WRVJGTE9XID0gXCJvdmVyZmxvd1wiO1xudmFyIEVWRU5UX0RFU1RST1kgPSBcImRlc3Ryb3lcIjtcbnZhciBFVkVOVF9BUlJPV1NfTU9VTlRFRCA9IFwiYXJyb3dzOm1vdW50ZWRcIjtcbnZhciBFVkVOVF9BUlJPV1NfVVBEQVRFRCA9IFwiYXJyb3dzOnVwZGF0ZWRcIjtcbnZhciBFVkVOVF9QQUdJTkFUSU9OX01PVU5URUQgPSBcInBhZ2luYXRpb246bW91bnRlZFwiO1xudmFyIEVWRU5UX1BBR0lOQVRJT05fVVBEQVRFRCA9IFwicGFnaW5hdGlvbjp1cGRhdGVkXCI7XG52YXIgRVZFTlRfTkFWSUdBVElPTl9NT1VOVEVEID0gXCJuYXZpZ2F0aW9uOm1vdW50ZWRcIjtcbnZhciBFVkVOVF9BVVRPUExBWV9QTEFZID0gXCJhdXRvcGxheTpwbGF5XCI7XG52YXIgRVZFTlRfQVVUT1BMQVlfUExBWUlORyA9IFwiYXV0b3BsYXk6cGxheWluZ1wiO1xudmFyIEVWRU5UX0FVVE9QTEFZX1BBVVNFID0gXCJhdXRvcGxheTpwYXVzZVwiO1xudmFyIEVWRU5UX0xBWllMT0FEX0xPQURFRCA9IFwibGF6eWxvYWQ6bG9hZGVkXCI7XG52YXIgRVZFTlRfU0xJREVfS0VZRE9XTiA9IFwic2tcIjtcbnZhciBFVkVOVF9TSElGVEVEID0gXCJzaFwiO1xudmFyIEVWRU5UX0VORF9JTkRFWF9DSEFOR0VEID0gXCJlaVwiO1xuZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpIHtcbiAgdmFyIGJ1cyA9IFNwbGlkZTIyID8gU3BsaWRlMjIuZXZlbnQuYnVzIDogZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgYmluZGVyID0gRXZlbnRCaW5kZXIoKTtcbiAgZnVuY3Rpb24gb24oZXZlbnRzLCBjYWxsYmFjaykge1xuICAgIGJpbmRlci5iaW5kKGJ1cywgdG9BcnJheShldmVudHMpLmpvaW4oXCIgXCIpLCBmdW5jdGlvbihlKSB7XG4gICAgICBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgaXNBcnJheShlLmRldGFpbCkgPyBlLmRldGFpbCA6IFtdKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgYmluZGVyLmRpc3BhdGNoKGJ1cywgZXZlbnQsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICB9XG4gIGlmIChTcGxpZGUyMikge1xuICAgIFNwbGlkZTIyLmV2ZW50Lm9uKEVWRU5UX0RFU1RST1ksIGJpbmRlci5kZXN0cm95KTtcbiAgfVxuICByZXR1cm4gYXNzaWduKGJpbmRlciwge1xuICAgIGJ1cyxcbiAgICBvbixcbiAgICBvZmY6IGFwcGx5KGJpbmRlci51bmJpbmQsIGJ1cyksXG4gICAgZW1pdFxuICB9KTtcbn1cbmZ1bmN0aW9uIFJlcXVlc3RJbnRlcnZhbChpbnRlcnZhbCwgb25JbnRlcnZhbCwgb25VcGRhdGUsIGxpbWl0KSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdztcbiAgdmFyIHN0YXJ0VGltZTtcbiAgdmFyIHJhdGUgPSAwO1xuICB2YXIgaWQ7XG4gIHZhciBwYXVzZWQgPSB0cnVlO1xuICB2YXIgY291bnQgPSAwO1xuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHJhdGUgPSBpbnRlcnZhbCA/IG1pbigobm93KCkgLSBzdGFydFRpbWUpIC8gaW50ZXJ2YWwsIDEpIDogMTtcbiAgICAgIG9uVXBkYXRlICYmIG9uVXBkYXRlKHJhdGUpO1xuICAgICAgaWYgKHJhdGUgPj0gMSkge1xuICAgICAgICBvbkludGVydmFsKCk7XG4gICAgICAgIHN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICBpZiAobGltaXQgJiYgKytjb3VudCA+PSBsaW1pdCkge1xuICAgICAgICAgIHJldHVybiBwYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZCA9IHJhZih1cGRhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdGFydChyZXN1bWUpIHtcbiAgICByZXN1bWUgfHwgY2FuY2VsKCk7XG4gICAgc3RhcnRUaW1lID0gbm93KCkgLSAocmVzdW1lID8gcmF0ZSAqIGludGVydmFsIDogMCk7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWQgPSByYWYodXBkYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHJld2luZCgpIHtcbiAgICBzdGFydFRpbWUgPSBub3coKTtcbiAgICByYXRlID0gMDtcbiAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgIG9uVXBkYXRlKHJhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWQgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgIHJhdGUgPSAwO1xuICAgIGlkID0gMDtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHNldCh0aW1lKSB7XG4gICAgaW50ZXJ2YWwgPSB0aW1lO1xuICB9XG4gIGZ1bmN0aW9uIGlzUGF1c2VkKCkge1xuICAgIHJldHVybiBwYXVzZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICByZXdpbmQsXG4gICAgcGF1c2UsXG4gICAgY2FuY2VsLFxuICAgIHNldCxcbiAgICBpc1BhdXNlZFxuICB9O1xufVxuZnVuY3Rpb24gU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgc3RhdGUgPSB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBpcyhzdGF0ZXMpIHtcbiAgICByZXR1cm4gaW5jbHVkZXModG9BcnJheShzdGF0ZXMpLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzZXQsXG4gICAgaXNcbiAgfTtcbn1cbmZ1bmN0aW9uIFRocm90dGxlKGZ1bmMsIGR1cmF0aW9uKSB7XG4gIHZhciBpbnRlcnZhbCA9IFJlcXVlc3RJbnRlcnZhbChkdXJhdGlvbiB8fCAwLCBmdW5jLCBudWxsLCAxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGludGVydmFsLmlzUGF1c2VkKCkgJiYgaW50ZXJ2YWwuc3RhcnQoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE1lZGlhKFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSBTcGxpZGUyMi5zdGF0ZTtcbiAgdmFyIGJyZWFrcG9pbnRzID0gb3B0aW9ucy5icmVha3BvaW50cyB8fCB7fTtcbiAgdmFyIHJlZHVjZWRNb3Rpb24gPSBvcHRpb25zLnJlZHVjZWRNb3Rpb24gfHwge307XG4gIHZhciBiaW5kZXIgPSBFdmVudEJpbmRlcigpO1xuICB2YXIgcXVlcmllcyA9IFtdO1xuICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICB2YXIgaXNNaW4gPSBvcHRpb25zLm1lZGlhUXVlcnkgPT09IFwibWluXCI7XG4gICAgb3duS2V5cyhicmVha3BvaW50cykuc29ydChmdW5jdGlvbihuLCBtKSB7XG4gICAgICByZXR1cm4gaXNNaW4gPyArbiAtICttIDogK20gLSArbjtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmVnaXN0ZXIoYnJlYWtwb2ludHNba2V5XSwgXCIoXCIgKyAoaXNNaW4gPyBcIm1pblwiIDogXCJtYXhcIikgKyBcIi13aWR0aDpcIiArIGtleSArIFwicHgpXCIpO1xuICAgIH0pO1xuICAgIHJlZ2lzdGVyKHJlZHVjZWRNb3Rpb24sIE1FRElBX1BSRUZFUlNfUkVEVUNFRF9NT1RJT04pO1xuICAgIHVwZGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koY29tcGxldGVseSkge1xuICAgIGlmIChjb21wbGV0ZWx5KSB7XG4gICAgICBiaW5kZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlcihvcHRpb25zMiwgcXVlcnkyKSB7XG4gICAgdmFyIHF1ZXJ5TGlzdCA9IG1hdGNoTWVkaWEocXVlcnkyKTtcbiAgICBiaW5kZXIuYmluZChxdWVyeUxpc3QsIFwiY2hhbmdlXCIsIHVwZGF0ZSk7XG4gICAgcXVlcmllcy5wdXNoKFtvcHRpb25zMiwgcXVlcnlMaXN0XSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBkZXN0cm95ZWQgPSBzdGF0ZS5pcyhERVNUUk9ZRUQpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbjtcbiAgICB2YXIgbWVyZ2VkID0gcXVlcmllcy5yZWR1Y2UoZnVuY3Rpb24obWVyZ2VkMiwgZW50cnkpIHtcbiAgICAgIHJldHVybiBtZXJnZShtZXJnZWQyLCBlbnRyeVsxXS5tYXRjaGVzID8gZW50cnlbMF0gOiB7fSk7XG4gICAgfSwge30pO1xuICAgIG9taXQob3B0aW9ucyk7XG4gICAgc2V0KG1lcmdlZCk7XG4gICAgaWYgKG9wdGlvbnMuZGVzdHJveSkge1xuICAgICAgU3BsaWRlMjIuZGVzdHJveShvcHRpb25zLmRlc3Ryb3kgPT09IFwiY29tcGxldGVseVwiKTtcbiAgICB9IGVsc2UgaWYgKGRlc3Ryb3llZCkge1xuICAgICAgZGVzdHJveSh0cnVlKTtcbiAgICAgIFNwbGlkZTIyLm1vdW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbiAhPT0gb3B0aW9ucy5kaXJlY3Rpb24gJiYgU3BsaWRlMjIucmVmcmVzaCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWR1Y2UoZW5hYmxlKSB7XG4gICAgaWYgKG1hdGNoTWVkaWEoTUVESUFfUFJFRkVSU19SRURVQ0VEX01PVElPTikubWF0Y2hlcykge1xuICAgICAgZW5hYmxlID8gbWVyZ2Uob3B0aW9ucywgcmVkdWNlZE1vdGlvbikgOiBvbWl0KG9wdGlvbnMsIG93bktleXMocmVkdWNlZE1vdGlvbikpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXQob3B0cywgYmFzZSwgbm90aWZ5KSB7XG4gICAgbWVyZ2Uob3B0aW9ucywgb3B0cyk7XG4gICAgYmFzZSAmJiBtZXJnZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3B0aW9ucyksIG9wdHMpO1xuICAgIGlmIChub3RpZnkgfHwgIXN0YXRlLmlzKENSRUFURUQpKSB7XG4gICAgICBTcGxpZGUyMi5lbWl0KEVWRU5UX1VQREFURUQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNldHVwLFxuICAgIGRlc3Ryb3ksXG4gICAgcmVkdWNlLFxuICAgIHNldFxuICB9O1xufVxudmFyIEFSUk9XID0gXCJBcnJvd1wiO1xudmFyIEFSUk9XX0xFRlQgPSBBUlJPVyArIFwiTGVmdFwiO1xudmFyIEFSUk9XX1JJR0hUID0gQVJST1cgKyBcIlJpZ2h0XCI7XG52YXIgQVJST1dfVVAgPSBBUlJPVyArIFwiVXBcIjtcbnZhciBBUlJPV19ET1dOID0gQVJST1cgKyBcIkRvd25cIjtcbnZhciBSVEwgPSBcInJ0bFwiO1xudmFyIFRUQiA9IFwidHRiXCI7XG52YXIgT1JJRU5UQVRJT05fTUFQID0ge1xuICB3aWR0aDogW1wiaGVpZ2h0XCJdLFxuICBsZWZ0OiBbXCJ0b3BcIiwgXCJyaWdodFwiXSxcbiAgcmlnaHQ6IFtcImJvdHRvbVwiLCBcImxlZnRcIl0sXG4gIHg6IFtcInlcIl0sXG4gIFg6IFtcIllcIl0sXG4gIFk6IFtcIlhcIl0sXG4gIEFycm93TGVmdDogW0FSUk9XX1VQLCBBUlJPV19SSUdIVF0sXG4gIEFycm93UmlnaHQ6IFtBUlJPV19ET1dOLCBBUlJPV19MRUZUXVxufTtcbmZ1bmN0aW9uIERpcmVjdGlvbihTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gcmVzb2x2ZShwcm9wLCBheGlzT25seSwgZGlyZWN0aW9uKSB7XG4gICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIHZhciBpbmRleCA9IGRpcmVjdGlvbiA9PT0gUlRMICYmICFheGlzT25seSA/IDEgOiBkaXJlY3Rpb24gPT09IFRUQiA/IDAgOiAtMTtcbiAgICByZXR1cm4gT1JJRU5UQVRJT05fTUFQW3Byb3BdICYmIE9SSUVOVEFUSU9OX01BUFtwcm9wXVtpbmRleF0gfHwgcHJvcC5yZXBsYWNlKC93aWR0aHxsZWZ0fHJpZ2h0L2ksIGZ1bmN0aW9uKG1hdGNoLCBvZmZzZXQpIHtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IE9SSUVOVEFUSU9OX01BUFttYXRjaC50b0xvd2VyQ2FzZSgpXVtpbmRleF0gfHwgbWF0Y2g7XG4gICAgICByZXR1cm4gb2Zmc2V0ID4gMCA/IHJlcGxhY2VtZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcmVwbGFjZW1lbnQuc2xpY2UoMSkgOiByZXBsYWNlbWVudDtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvcmllbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKiAob3B0aW9ucy5kaXJlY3Rpb24gPT09IFJUTCA/IDEgOiAtMSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNvbHZlLFxuICAgIG9yaWVudFxuICB9O1xufVxudmFyIFJPTEUgPSBcInJvbGVcIjtcbnZhciBUQUJfSU5ERVggPSBcInRhYmluZGV4XCI7XG52YXIgRElTQUJMRUQgPSBcImRpc2FibGVkXCI7XG52YXIgQVJJQV9QUkVGSVggPSBcImFyaWEtXCI7XG52YXIgQVJJQV9DT05UUk9MUyA9IEFSSUFfUFJFRklYICsgXCJjb250cm9sc1wiO1xudmFyIEFSSUFfQ1VSUkVOVCA9IEFSSUFfUFJFRklYICsgXCJjdXJyZW50XCI7XG52YXIgQVJJQV9TRUxFQ1RFRCA9IEFSSUFfUFJFRklYICsgXCJzZWxlY3RlZFwiO1xudmFyIEFSSUFfTEFCRUwgPSBBUklBX1BSRUZJWCArIFwibGFiZWxcIjtcbnZhciBBUklBX0xBQkVMTEVEQlkgPSBBUklBX1BSRUZJWCArIFwibGFiZWxsZWRieVwiO1xudmFyIEFSSUFfSElEREVOID0gQVJJQV9QUkVGSVggKyBcImhpZGRlblwiO1xudmFyIEFSSUFfT1JJRU5UQVRJT04gPSBBUklBX1BSRUZJWCArIFwib3JpZW50YXRpb25cIjtcbnZhciBBUklBX1JPTEVERVNDUklQVElPTiA9IEFSSUFfUFJFRklYICsgXCJyb2xlZGVzY3JpcHRpb25cIjtcbnZhciBBUklBX0xJVkUgPSBBUklBX1BSRUZJWCArIFwibGl2ZVwiO1xudmFyIEFSSUFfQlVTWSA9IEFSSUFfUFJFRklYICsgXCJidXN5XCI7XG52YXIgQVJJQV9BVE9NSUMgPSBBUklBX1BSRUZJWCArIFwiYXRvbWljXCI7XG52YXIgQUxMX0FUVFJJQlVURVMgPSBbUk9MRSwgVEFCX0lOREVYLCBESVNBQkxFRCwgQVJJQV9DT05UUk9MUywgQVJJQV9DVVJSRU5ULCBBUklBX0xBQkVMLCBBUklBX0xBQkVMTEVEQlksIEFSSUFfSElEREVOLCBBUklBX09SSUVOVEFUSU9OLCBBUklBX1JPTEVERVNDUklQVElPTl07XG52YXIgQ0xBU1NfUFJFRklYID0gUFJPSkVDVF9DT0RFICsgXCJfX1wiO1xudmFyIFNUQVRVU19DTEFTU19QUkVGSVggPSBcImlzLVwiO1xudmFyIENMQVNTX1JPT1QgPSBQUk9KRUNUX0NPREU7XG52YXIgQ0xBU1NfVFJBQ0sgPSBDTEFTU19QUkVGSVggKyBcInRyYWNrXCI7XG52YXIgQ0xBU1NfTElTVCA9IENMQVNTX1BSRUZJWCArIFwibGlzdFwiO1xudmFyIENMQVNTX1NMSURFID0gQ0xBU1NfUFJFRklYICsgXCJzbGlkZVwiO1xudmFyIENMQVNTX0NMT05FID0gQ0xBU1NfU0xJREUgKyBcIi0tY2xvbmVcIjtcbnZhciBDTEFTU19DT05UQUlORVIgPSBDTEFTU19TTElERSArIFwiX19jb250YWluZXJcIjtcbnZhciBDTEFTU19BUlJPV1MgPSBDTEFTU19QUkVGSVggKyBcImFycm93c1wiO1xudmFyIENMQVNTX0FSUk9XID0gQ0xBU1NfUFJFRklYICsgXCJhcnJvd1wiO1xudmFyIENMQVNTX0FSUk9XX1BSRVYgPSBDTEFTU19BUlJPVyArIFwiLS1wcmV2XCI7XG52YXIgQ0xBU1NfQVJST1dfTkVYVCA9IENMQVNTX0FSUk9XICsgXCItLW5leHRcIjtcbnZhciBDTEFTU19QQUdJTkFUSU9OID0gQ0xBU1NfUFJFRklYICsgXCJwYWdpbmF0aW9uXCI7XG52YXIgQ0xBU1NfUEFHSU5BVElPTl9QQUdFID0gQ0xBU1NfUEFHSU5BVElPTiArIFwiX19wYWdlXCI7XG52YXIgQ0xBU1NfUFJPR1JFU1MgPSBDTEFTU19QUkVGSVggKyBcInByb2dyZXNzXCI7XG52YXIgQ0xBU1NfUFJPR1JFU1NfQkFSID0gQ0xBU1NfUFJPR1JFU1MgKyBcIl9fYmFyXCI7XG52YXIgQ0xBU1NfVE9HR0xFID0gQ0xBU1NfUFJFRklYICsgXCJ0b2dnbGVcIjtcbnZhciBDTEFTU19UT0dHTEVfUExBWSA9IENMQVNTX1RPR0dMRSArIFwiX19wbGF5XCI7XG52YXIgQ0xBU1NfVE9HR0xFX1BBVVNFID0gQ0xBU1NfVE9HR0xFICsgXCJfX3BhdXNlXCI7XG52YXIgQ0xBU1NfU1BJTk5FUiA9IENMQVNTX1BSRUZJWCArIFwic3Bpbm5lclwiO1xudmFyIENMQVNTX1NSID0gQ0xBU1NfUFJFRklYICsgXCJzclwiO1xudmFyIENMQVNTX0lOSVRJQUxJWkVEID0gU1RBVFVTX0NMQVNTX1BSRUZJWCArIFwiaW5pdGlhbGl6ZWRcIjtcbnZhciBDTEFTU19BQ1RJVkUgPSBTVEFUVVNfQ0xBU1NfUFJFRklYICsgXCJhY3RpdmVcIjtcbnZhciBDTEFTU19QUkVWID0gU1RBVFVTX0NMQVNTX1BSRUZJWCArIFwicHJldlwiO1xudmFyIENMQVNTX05FWFQgPSBTVEFUVVNfQ0xBU1NfUFJFRklYICsgXCJuZXh0XCI7XG52YXIgQ0xBU1NfVklTSUJMRSA9IFNUQVRVU19DTEFTU19QUkVGSVggKyBcInZpc2libGVcIjtcbnZhciBDTEFTU19MT0FESU5HID0gU1RBVFVTX0NMQVNTX1BSRUZJWCArIFwibG9hZGluZ1wiO1xudmFyIENMQVNTX0ZPQ1VTX0lOID0gU1RBVFVTX0NMQVNTX1BSRUZJWCArIFwiZm9jdXMtaW5cIjtcbnZhciBDTEFTU19PVkVSRkxPVyA9IFNUQVRVU19DTEFTU19QUkVGSVggKyBcIm92ZXJmbG93XCI7XG52YXIgU1RBVFVTX0NMQVNTRVMgPSBbQ0xBU1NfQUNUSVZFLCBDTEFTU19WSVNJQkxFLCBDTEFTU19QUkVWLCBDTEFTU19ORVhULCBDTEFTU19MT0FESU5HLCBDTEFTU19GT0NVU19JTiwgQ0xBU1NfT1ZFUkZMT1ddO1xudmFyIENMQVNTRVMgPSB7XG4gIHNsaWRlOiBDTEFTU19TTElERSxcbiAgY2xvbmU6IENMQVNTX0NMT05FLFxuICBhcnJvd3M6IENMQVNTX0FSUk9XUyxcbiAgYXJyb3c6IENMQVNTX0FSUk9XLFxuICBwcmV2OiBDTEFTU19BUlJPV19QUkVWLFxuICBuZXh0OiBDTEFTU19BUlJPV19ORVhULFxuICBwYWdpbmF0aW9uOiBDTEFTU19QQUdJTkFUSU9OLFxuICBwYWdlOiBDTEFTU19QQUdJTkFUSU9OX1BBR0UsXG4gIHNwaW5uZXI6IENMQVNTX1NQSU5ORVJcbn07XG5mdW5jdGlvbiBjbG9zZXN0KGZyb20sIHNlbGVjdG9yKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGZyb20uY2xvc2VzdCkpIHtcbiAgICByZXR1cm4gZnJvbS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgfVxuICB2YXIgZWxtID0gZnJvbTtcbiAgd2hpbGUgKGVsbSAmJiBlbG0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICBpZiAobWF0Y2hlcyhlbG0sIHNlbGVjdG9yKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVsbSA9IGVsbS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbG07XG59XG52YXIgRlJJQ1RJT04gPSA1O1xudmFyIExPR19JTlRFUlZBTCA9IDIwMDtcbnZhciBQT0lOVEVSX0RPV05fRVZFTlRTID0gXCJ0b3VjaHN0YXJ0IG1vdXNlZG93blwiO1xudmFyIFBPSU5URVJfTU9WRV9FVkVOVFMgPSBcInRvdWNobW92ZSBtb3VzZW1vdmVcIjtcbnZhciBQT0lOVEVSX1VQX0VWRU5UUyA9IFwidG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCBjbGlja1wiO1xuZnVuY3Rpb24gRWxlbWVudHMoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBfRXZlbnRJbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMiksIG9uID0gX0V2ZW50SW50ZXJmYWNlLm9uLCBiaW5kID0gX0V2ZW50SW50ZXJmYWNlLmJpbmQ7XG4gIHZhciByb290ID0gU3BsaWRlMjIucm9vdDtcbiAgdmFyIGkxOG4gPSBvcHRpb25zLmkxOG47XG4gIHZhciBlbGVtZW50cyA9IHt9O1xuICB2YXIgc2xpZGVzID0gW107XG4gIHZhciByb290Q2xhc3NlcyA9IFtdO1xuICB2YXIgdHJhY2tDbGFzc2VzID0gW107XG4gIHZhciB0cmFjaztcbiAgdmFyIGxpc3Q7XG4gIHZhciBpc1VzaW5nS2V5O1xuICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBjb2xsZWN0KCk7XG4gICAgaW5pdCgpO1xuICAgIHVwZGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIG9uKEVWRU5UX1JFRlJFU0gsIGRlc3Ryb3kpO1xuICAgIG9uKEVWRU5UX1JFRlJFU0gsIHNldHVwKTtcbiAgICBvbihFVkVOVF9VUERBVEVELCB1cGRhdGUpO1xuICAgIGJpbmQoZG9jdW1lbnQsIFBPSU5URVJfRE9XTl9FVkVOVFMgKyBcIiBrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlzVXNpbmdLZXkgPSBlLnR5cGUgPT09IFwia2V5ZG93blwiO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICBiaW5kKHJvb3QsIFwiZm9jdXNpblwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHJvb3QsIENMQVNTX0ZPQ1VTX0lOLCAhIWlzVXNpbmdLZXkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koY29tcGxldGVseSkge1xuICAgIHZhciBhdHRycyA9IEFMTF9BVFRSSUJVVEVTLmNvbmNhdChcInN0eWxlXCIpO1xuICAgIGVtcHR5KHNsaWRlcyk7XG4gICAgcmVtb3ZlQ2xhc3Mocm9vdCwgcm9vdENsYXNzZXMpO1xuICAgIHJlbW92ZUNsYXNzKHRyYWNrLCB0cmFja0NsYXNzZXMpO1xuICAgIHJlbW92ZUF0dHJpYnV0ZShbdHJhY2ssIGxpc3RdLCBhdHRycyk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKHJvb3QsIGNvbXBsZXRlbHkgPyBhdHRycyA6IFtcInN0eWxlXCIsIEFSSUFfUk9MRURFU0NSSVBUSU9OXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHJlbW92ZUNsYXNzKHJvb3QsIHJvb3RDbGFzc2VzKTtcbiAgICByZW1vdmVDbGFzcyh0cmFjaywgdHJhY2tDbGFzc2VzKTtcbiAgICByb290Q2xhc3NlcyA9IGdldENsYXNzZXMoQ0xBU1NfUk9PVCk7XG4gICAgdHJhY2tDbGFzc2VzID0gZ2V0Q2xhc3NlcyhDTEFTU19UUkFDSyk7XG4gICAgYWRkQ2xhc3Mocm9vdCwgcm9vdENsYXNzZXMpO1xuICAgIGFkZENsYXNzKHRyYWNrLCB0cmFja0NsYXNzZXMpO1xuICAgIHNldEF0dHJpYnV0ZShyb290LCBBUklBX0xBQkVMLCBvcHRpb25zLmxhYmVsKTtcbiAgICBzZXRBdHRyaWJ1dGUocm9vdCwgQVJJQV9MQUJFTExFREJZLCBvcHRpb25zLmxhYmVsbGVkYnkpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbGxlY3QoKSB7XG4gICAgdHJhY2sgPSBmaW5kKFwiLlwiICsgQ0xBU1NfVFJBQ0spO1xuICAgIGxpc3QgPSBjaGlsZCh0cmFjaywgXCIuXCIgKyBDTEFTU19MSVNUKTtcbiAgICBhc3NlcnQodHJhY2sgJiYgbGlzdCwgXCJBIHRyYWNrL2xpc3QgZWxlbWVudCBpcyBtaXNzaW5nLlwiKTtcbiAgICBwdXNoKHNsaWRlcywgY2hpbGRyZW4obGlzdCwgXCIuXCIgKyBDTEFTU19TTElERSArIFwiOm5vdCguXCIgKyBDTEFTU19DTE9ORSArIFwiKVwiKSk7XG4gICAgZm9yT3duKHtcbiAgICAgIGFycm93czogQ0xBU1NfQVJST1dTLFxuICAgICAgcGFnaW5hdGlvbjogQ0xBU1NfUEFHSU5BVElPTixcbiAgICAgIHByZXY6IENMQVNTX0FSUk9XX1BSRVYsXG4gICAgICBuZXh0OiBDTEFTU19BUlJPV19ORVhULFxuICAgICAgYmFyOiBDTEFTU19QUk9HUkVTU19CQVIsXG4gICAgICB0b2dnbGU6IENMQVNTX1RPR0dMRVxuICAgIH0sIGZ1bmN0aW9uKGNsYXNzTmFtZSwga2V5KSB7XG4gICAgICBlbGVtZW50c1trZXldID0gZmluZChcIi5cIiArIGNsYXNzTmFtZSk7XG4gICAgfSk7XG4gICAgYXNzaWduKGVsZW1lbnRzLCB7XG4gICAgICByb290LFxuICAgICAgdHJhY2ssXG4gICAgICBsaXN0LFxuICAgICAgc2xpZGVzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgaWQgPSByb290LmlkIHx8IHVuaXF1ZUlkKFBST0pFQ1RfQ09ERSk7XG4gICAgdmFyIHJvbGUgPSBvcHRpb25zLnJvbGU7XG4gICAgcm9vdC5pZCA9IGlkO1xuICAgIHRyYWNrLmlkID0gdHJhY2suaWQgfHwgaWQgKyBcIi10cmFja1wiO1xuICAgIGxpc3QuaWQgPSBsaXN0LmlkIHx8IGlkICsgXCItbGlzdFwiO1xuICAgIGlmICghZ2V0QXR0cmlidXRlKHJvb3QsIFJPTEUpICYmIHJvb3QudGFnTmFtZSAhPT0gXCJTRUNUSU9OXCIgJiYgcm9sZSkge1xuICAgICAgc2V0QXR0cmlidXRlKHJvb3QsIFJPTEUsIHJvbGUpO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUocm9vdCwgQVJJQV9ST0xFREVTQ1JJUFRJT04sIGkxOG4uY2Fyb3VzZWwpO1xuICAgIHNldEF0dHJpYnV0ZShsaXN0LCBST0xFLCBcInByZXNlbnRhdGlvblwiKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsbSA9IHF1ZXJ5KHJvb3QsIHNlbGVjdG9yKTtcbiAgICByZXR1cm4gZWxtICYmIGNsb3Nlc3QoZWxtLCBcIi5cIiArIENMQVNTX1JPT1QpID09PSByb290ID8gZWxtIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldENsYXNzZXMoYmFzZSkge1xuICAgIHJldHVybiBbYmFzZSArIFwiLS1cIiArIG9wdGlvbnMudHlwZSwgYmFzZSArIFwiLS1cIiArIG9wdGlvbnMuZGlyZWN0aW9uLCBvcHRpb25zLmRyYWcgJiYgYmFzZSArIFwiLS1kcmFnZ2FibGVcIiwgb3B0aW9ucy5pc05hdmlnYXRpb24gJiYgYmFzZSArIFwiLS1uYXZcIiwgYmFzZSA9PT0gQ0xBU1NfUk9PVCAmJiBDTEFTU19BQ1RJVkVdO1xuICB9XG4gIHJldHVybiBhc3NpZ24oZWxlbWVudHMsIHtcbiAgICBzZXR1cCxcbiAgICBtb3VudCxcbiAgICBkZXN0cm95XG4gIH0pO1xufVxudmFyIFNMSURFID0gXCJzbGlkZVwiO1xudmFyIExPT1AgPSBcImxvb3BcIjtcbnZhciBGQURFID0gXCJmYWRlXCI7XG5mdW5jdGlvbiBTbGlkZSQxKFNwbGlkZTIyLCBpbmRleCwgc2xpZGVJbmRleCwgc2xpZGUpIHtcbiAgdmFyIGV2ZW50ID0gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpO1xuICB2YXIgb24gPSBldmVudC5vbiwgZW1pdCA9IGV2ZW50LmVtaXQsIGJpbmQgPSBldmVudC5iaW5kO1xuICB2YXIgQ29tcG9uZW50cyA9IFNwbGlkZTIyLkNvbXBvbmVudHMsIHJvb3QgPSBTcGxpZGUyMi5yb290LCBvcHRpb25zID0gU3BsaWRlMjIub3B0aW9ucztcbiAgdmFyIGlzTmF2aWdhdGlvbiA9IG9wdGlvbnMuaXNOYXZpZ2F0aW9uLCB1cGRhdGVPbk1vdmUgPSBvcHRpb25zLnVwZGF0ZU9uTW92ZSwgaTE4biA9IG9wdGlvbnMuaTE4biwgcGFnaW5hdGlvbiA9IG9wdGlvbnMucGFnaW5hdGlvbiwgc2xpZGVGb2N1cyA9IG9wdGlvbnMuc2xpZGVGb2N1cztcbiAgdmFyIHJlc29sdmUgPSBDb21wb25lbnRzLkRpcmVjdGlvbi5yZXNvbHZlO1xuICB2YXIgc3R5bGVzID0gZ2V0QXR0cmlidXRlKHNsaWRlLCBcInN0eWxlXCIpO1xuICB2YXIgbGFiZWwgPSBnZXRBdHRyaWJ1dGUoc2xpZGUsIEFSSUFfTEFCRUwpO1xuICB2YXIgaXNDbG9uZSA9IHNsaWRlSW5kZXggPiAtMTtcbiAgdmFyIGNvbnRhaW5lciA9IGNoaWxkKHNsaWRlLCBcIi5cIiArIENMQVNTX0NPTlRBSU5FUik7XG4gIHZhciBkZXN0cm95ZWQ7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGlmICghaXNDbG9uZSkge1xuICAgICAgc2xpZGUuaWQgPSByb290LmlkICsgXCItc2xpZGVcIiArIHBhZChpbmRleCArIDEpO1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBST0xFLCBwYWdpbmF0aW9uID8gXCJ0YWJwYW5lbFwiIDogXCJncm91cFwiKTtcbiAgICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgQVJJQV9ST0xFREVTQ1JJUFRJT04sIGkxOG4uc2xpZGUpO1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0xBQkVMLCBsYWJlbCB8fCBmb3JtYXQoaTE4bi5zbGlkZUxhYmVsLCBbaW5kZXggKyAxLCBTcGxpZGUyMi5sZW5ndGhdKSk7XG4gICAgfVxuICAgIGxpc3RlbigpO1xuICB9XG4gIGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICBiaW5kKHNsaWRlLCBcImNsaWNrXCIsIGFwcGx5KGVtaXQsIEVWRU5UX0NMSUNLLCBzZWxmKSk7XG4gICAgYmluZChzbGlkZSwgXCJrZXlkb3duXCIsIGFwcGx5KGVtaXQsIEVWRU5UX1NMSURFX0tFWURPV04sIHNlbGYpKTtcbiAgICBvbihbRVZFTlRfTU9WRUQsIEVWRU5UX1NISUZURUQsIEVWRU5UX1NDUk9MTEVEXSwgdXBkYXRlKTtcbiAgICBvbihFVkVOVF9OQVZJR0FUSU9OX01PVU5URUQsIGluaXROYXZpZ2F0aW9uKTtcbiAgICBpZiAodXBkYXRlT25Nb3ZlKSB7XG4gICAgICBvbihFVkVOVF9NT1ZFLCBvbk1vdmUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gICAgZXZlbnQuZGVzdHJveSgpO1xuICAgIHJlbW92ZUNsYXNzKHNsaWRlLCBTVEFUVVNfQ0xBU1NFUyk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKHNsaWRlLCBBTExfQVRUUklCVVRFUyk7XG4gICAgc2V0QXR0cmlidXRlKHNsaWRlLCBcInN0eWxlXCIsIHN0eWxlcyk7XG4gICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0xBQkVMLCBsYWJlbCB8fCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0TmF2aWdhdGlvbigpIHtcbiAgICB2YXIgY29udHJvbHMgPSBTcGxpZGUyMi5zcGxpZGVzLm1hcChmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBTbGlkZTIgPSB0YXJnZXQuc3BsaWRlLkNvbXBvbmVudHMuU2xpZGVzLmdldEF0KGluZGV4KTtcbiAgICAgIHJldHVybiBTbGlkZTIgPyBTbGlkZTIuc2xpZGUuaWQgOiBcIlwiO1xuICAgIH0pLmpvaW4oXCIgXCIpO1xuICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgQVJJQV9MQUJFTCwgZm9ybWF0KGkxOG4uc2xpZGVYLCAoaXNDbG9uZSA/IHNsaWRlSW5kZXggOiBpbmRleCkgKyAxKSk7XG4gICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0NPTlRST0xTLCBjb250cm9scyk7XG4gICAgc2V0QXR0cmlidXRlKHNsaWRlLCBST0xFLCBzbGlkZUZvY3VzID8gXCJidXR0b25cIiA6IFwiXCIpO1xuICAgIHNsaWRlRm9jdXMgJiYgcmVtb3ZlQXR0cmlidXRlKHNsaWRlLCBBUklBX1JPTEVERVNDUklQVElPTik7XG4gIH1cbiAgZnVuY3Rpb24gb25Nb3ZlKCkge1xuICAgIGlmICghZGVzdHJveWVkKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIGlmICghZGVzdHJveWVkKSB7XG4gICAgICB2YXIgY3VyciA9IFNwbGlkZTIyLmluZGV4O1xuICAgICAgdXBkYXRlQWN0aXZpdHkoKTtcbiAgICAgIHVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIHRvZ2dsZUNsYXNzKHNsaWRlLCBDTEFTU19QUkVWLCBpbmRleCA9PT0gY3VyciAtIDEpO1xuICAgICAgdG9nZ2xlQ2xhc3Moc2xpZGUsIENMQVNTX05FWFQsIGluZGV4ID09PSBjdXJyICsgMSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUFjdGl2aXR5KCkge1xuICAgIHZhciBhY3RpdmUgPSBpc0FjdGl2ZSgpO1xuICAgIGlmIChhY3RpdmUgIT09IGhhc0NsYXNzKHNsaWRlLCBDTEFTU19BQ1RJVkUpKSB7XG4gICAgICB0b2dnbGVDbGFzcyhzbGlkZSwgQ0xBU1NfQUNUSVZFLCBhY3RpdmUpO1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0NVUlJFTlQsIGlzTmF2aWdhdGlvbiAmJiBhY3RpdmUgfHwgXCJcIik7XG4gICAgICBlbWl0KGFjdGl2ZSA/IEVWRU5UX0FDVElWRSA6IEVWRU5UX0lOQUNUSVZFLCBzZWxmKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgdmlzaWJsZSA9IGlzVmlzaWJsZSgpO1xuICAgIHZhciBoaWRkZW4gPSAhdmlzaWJsZSAmJiAoIWlzQWN0aXZlKCkgfHwgaXNDbG9uZSk7XG4gICAgaWYgKCFTcGxpZGUyMi5zdGF0ZS5pcyhbTU9WSU5HLCBTQ1JPTExJTkddKSkge1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0hJRERFTiwgaGlkZGVuIHx8IFwiXCIpO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUocXVlcnlBbGwoc2xpZGUsIG9wdGlvbnMuZm9jdXNhYmxlTm9kZXMgfHwgXCJcIiksIFRBQl9JTkRFWCwgaGlkZGVuID8gLTEgOiBcIlwiKTtcbiAgICBpZiAoc2xpZGVGb2N1cykge1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBUQUJfSU5ERVgsIGhpZGRlbiA/IC0xIDogMCk7XG4gICAgfVxuICAgIGlmICh2aXNpYmxlICE9PSBoYXNDbGFzcyhzbGlkZSwgQ0xBU1NfVklTSUJMRSkpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHNsaWRlLCBDTEFTU19WSVNJQkxFLCB2aXNpYmxlKTtcbiAgICAgIGVtaXQodmlzaWJsZSA/IEVWRU5UX1ZJU0lCTEUgOiBFVkVOVF9ISURERU4sIHNlbGYpO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gc2xpZGUpIHtcbiAgICAgIHZhciBTbGlkZTIgPSBDb21wb25lbnRzLlNsaWRlcy5nZXRBdChTcGxpZGUyMi5pbmRleCk7XG4gICAgICBTbGlkZTIgJiYgZm9jdXMoU2xpZGUyLnNsaWRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3R5bGUkMShwcm9wLCB2YWx1ZSwgdXNlQ29udGFpbmVyKSB7XG4gICAgc3R5bGUodXNlQ29udGFpbmVyICYmIGNvbnRhaW5lciB8fCBzbGlkZSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHZhciBjdXJyID0gU3BsaWRlMjIuaW5kZXg7XG4gICAgcmV0dXJuIGN1cnIgPT09IGluZGV4IHx8IG9wdGlvbnMuY2xvbmVTdGF0dXMgJiYgY3VyciA9PT0gc2xpZGVJbmRleDtcbiAgfVxuICBmdW5jdGlvbiBpc1Zpc2libGUoKSB7XG4gICAgaWYgKFNwbGlkZTIyLmlzKEZBREUpKSB7XG4gICAgICByZXR1cm4gaXNBY3RpdmUoKTtcbiAgICB9XG4gICAgdmFyIHRyYWNrUmVjdCA9IHJlY3QoQ29tcG9uZW50cy5FbGVtZW50cy50cmFjayk7XG4gICAgdmFyIHNsaWRlUmVjdCA9IHJlY3Qoc2xpZGUpO1xuICAgIHZhciBsZWZ0ID0gcmVzb2x2ZShcImxlZnRcIiwgdHJ1ZSk7XG4gICAgdmFyIHJpZ2h0ID0gcmVzb2x2ZShcInJpZ2h0XCIsIHRydWUpO1xuICAgIHJldHVybiBmbG9vcih0cmFja1JlY3RbbGVmdF0pIDw9IGNlaWwoc2xpZGVSZWN0W2xlZnRdKSAmJiBmbG9vcihzbGlkZVJlY3RbcmlnaHRdKSA8PSBjZWlsKHRyYWNrUmVjdFtyaWdodF0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzV2l0aGluKGZyb20sIGRpc3RhbmNlKSB7XG4gICAgdmFyIGRpZmYgPSBhYnMoZnJvbSAtIGluZGV4KTtcbiAgICBpZiAoIWlzQ2xvbmUgJiYgKG9wdGlvbnMucmV3aW5kIHx8IFNwbGlkZTIyLmlzKExPT1ApKSkge1xuICAgICAgZGlmZiA9IG1pbihkaWZmLCBTcGxpZGUyMi5sZW5ndGggLSBkaWZmKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmYgPD0gZGlzdGFuY2U7XG4gIH1cbiAgdmFyIHNlbGYgPSB7XG4gICAgaW5kZXgsXG4gICAgc2xpZGVJbmRleCxcbiAgICBzbGlkZSxcbiAgICBjb250YWluZXIsXG4gICAgaXNDbG9uZSxcbiAgICBtb3VudCxcbiAgICBkZXN0cm95LFxuICAgIHVwZGF0ZSxcbiAgICBzdHlsZTogc3R5bGUkMSxcbiAgICBpc1dpdGhpblxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIFNsaWRlcyhTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgdmFyIF9FdmVudEludGVyZmFjZTIgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMiksIG9uID0gX0V2ZW50SW50ZXJmYWNlMi5vbiwgZW1pdCA9IF9FdmVudEludGVyZmFjZTIuZW1pdCwgYmluZCA9IF9FdmVudEludGVyZmFjZTIuYmluZDtcbiAgdmFyIF9Db21wb25lbnRzMiRFbGVtZW50cyA9IENvbXBvbmVudHMyLkVsZW1lbnRzLCBzbGlkZXMgPSBfQ29tcG9uZW50czIkRWxlbWVudHMuc2xpZGVzLCBsaXN0ID0gX0NvbXBvbmVudHMyJEVsZW1lbnRzLmxpc3Q7XG4gIHZhciBTbGlkZXMyID0gW107XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGluaXQoKTtcbiAgICBvbihFVkVOVF9SRUZSRVNILCBkZXN0cm95KTtcbiAgICBvbihFVkVOVF9SRUZSRVNILCBpbml0KTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKHNsaWRlLCBpbmRleCkge1xuICAgICAgcmVnaXN0ZXIoc2xpZGUsIGluZGV4LCAtMSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBmb3JFYWNoJDEoZnVuY3Rpb24oU2xpZGUyKSB7XG4gICAgICBTbGlkZTIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIGVtcHR5KFNsaWRlczIpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBmb3JFYWNoJDEoZnVuY3Rpb24oU2xpZGUyKSB7XG4gICAgICBTbGlkZTIudXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXIoc2xpZGUsIGluZGV4LCBzbGlkZUluZGV4KSB7XG4gICAgdmFyIG9iamVjdCA9IFNsaWRlJDEoU3BsaWRlMjIsIGluZGV4LCBzbGlkZUluZGV4LCBzbGlkZSk7XG4gICAgb2JqZWN0Lm1vdW50KCk7XG4gICAgU2xpZGVzMi5wdXNoKG9iamVjdCk7XG4gICAgU2xpZGVzMi5zb3J0KGZ1bmN0aW9uKFNsaWRlMSwgU2xpZGUyKSB7XG4gICAgICByZXR1cm4gU2xpZGUxLmluZGV4IC0gU2xpZGUyLmluZGV4O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldChleGNsdWRlQ2xvbmVzKSB7XG4gICAgcmV0dXJuIGV4Y2x1ZGVDbG9uZXMgPyBmaWx0ZXIoZnVuY3Rpb24oU2xpZGUyKSB7XG4gICAgICByZXR1cm4gIVNsaWRlMi5pc0Nsb25lO1xuICAgIH0pIDogU2xpZGVzMjtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbihwYWdlKSB7XG4gICAgdmFyIENvbnRyb2xsZXIyID0gQ29tcG9uZW50czIuQ29udHJvbGxlcjtcbiAgICB2YXIgaW5kZXggPSBDb250cm9sbGVyMi50b0luZGV4KHBhZ2UpO1xuICAgIHZhciBtYXgyID0gQ29udHJvbGxlcjIuaGFzRm9jdXMoKSA/IDEgOiBvcHRpb25zLnBlclBhZ2U7XG4gICAgcmV0dXJuIGZpbHRlcihmdW5jdGlvbihTbGlkZTIpIHtcbiAgICAgIHJldHVybiBiZXR3ZWVuKFNsaWRlMi5pbmRleCwgaW5kZXgsIGluZGV4ICsgbWF4MiAtIDEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0KGluZGV4KSB7XG4gICAgcmV0dXJuIGZpbHRlcihpbmRleClbMF07XG4gIH1cbiAgZnVuY3Rpb24gYWRkKGl0ZW1zLCBpbmRleCkge1xuICAgIGZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKHNsaWRlKSB7XG4gICAgICBpZiAoaXNTdHJpbmcoc2xpZGUpKSB7XG4gICAgICAgIHNsaWRlID0gcGFyc2VIdG1sKHNsaWRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KHNsaWRlKSkge1xuICAgICAgICB2YXIgcmVmID0gc2xpZGVzW2luZGV4XTtcbiAgICAgICAgcmVmID8gYmVmb3JlKHNsaWRlLCByZWYpIDogYXBwZW5kKGxpc3QsIHNsaWRlKTtcbiAgICAgICAgYWRkQ2xhc3Moc2xpZGUsIG9wdGlvbnMuY2xhc3Nlcy5zbGlkZSk7XG4gICAgICAgIG9ic2VydmVJbWFnZXMoc2xpZGUsIGFwcGx5KGVtaXQsIEVWRU5UX1JFU0laRSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVtaXQoRVZFTlRfUkVGUkVTSCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlJDEobWF0Y2hlcikge1xuICAgIHJlbW92ZShmaWx0ZXIobWF0Y2hlcikubWFwKGZ1bmN0aW9uKFNsaWRlMikge1xuICAgICAgcmV0dXJuIFNsaWRlMi5zbGlkZTtcbiAgICB9KSk7XG4gICAgZW1pdChFVkVOVF9SRUZSRVNIKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JFYWNoJDEoaXRlcmF0ZWUsIGV4Y2x1ZGVDbG9uZXMpIHtcbiAgICBnZXQoZXhjbHVkZUNsb25lcykuZm9yRWFjaChpdGVyYXRlZSk7XG4gIH1cbiAgZnVuY3Rpb24gZmlsdGVyKG1hdGNoZXIpIHtcbiAgICByZXR1cm4gU2xpZGVzMi5maWx0ZXIoaXNGdW5jdGlvbihtYXRjaGVyKSA/IG1hdGNoZXIgOiBmdW5jdGlvbihTbGlkZTIpIHtcbiAgICAgIHJldHVybiBpc1N0cmluZyhtYXRjaGVyKSA/IG1hdGNoZXMoU2xpZGUyLnNsaWRlLCBtYXRjaGVyKSA6IGluY2x1ZGVzKHRvQXJyYXkobWF0Y2hlciksIFNsaWRlMi5pbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3R5bGUyKHByb3AsIHZhbHVlLCB1c2VDb250YWluZXIpIHtcbiAgICBmb3JFYWNoJDEoZnVuY3Rpb24oU2xpZGUyKSB7XG4gICAgICBTbGlkZTIuc3R5bGUocHJvcCwgdmFsdWUsIHVzZUNvbnRhaW5lcik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb2JzZXJ2ZUltYWdlcyhlbG0sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGltYWdlcyA9IHF1ZXJ5QWxsKGVsbSwgXCJpbWdcIik7XG4gICAgdmFyIGxlbmd0aCA9IGltYWdlcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIGJpbmQoaW1nLCBcImxvYWQgZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCEtLWxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldExlbmd0aChleGNsdWRlQ2xvbmVzKSB7XG4gICAgcmV0dXJuIGV4Y2x1ZGVDbG9uZXMgPyBzbGlkZXMubGVuZ3RoIDogU2xpZGVzMi5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gaXNFbm91Z2goKSB7XG4gICAgcmV0dXJuIFNsaWRlczIubGVuZ3RoID4gb3B0aW9ucy5wZXJQYWdlO1xuICB9XG4gIHJldHVybiB7XG4gICAgbW91bnQsXG4gICAgZGVzdHJveSxcbiAgICB1cGRhdGUsXG4gICAgcmVnaXN0ZXIsXG4gICAgZ2V0LFxuICAgIGdldEluLFxuICAgIGdldEF0LFxuICAgIGFkZCxcbiAgICByZW1vdmU6IHJlbW92ZSQxLFxuICAgIGZvckVhY2g6IGZvckVhY2gkMSxcbiAgICBmaWx0ZXIsXG4gICAgc3R5bGU6IHN0eWxlMixcbiAgICBnZXRMZW5ndGgsXG4gICAgaXNFbm91Z2hcbiAgfTtcbn1cbmZ1bmN0aW9uIExheW91dChTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgdmFyIF9FdmVudEludGVyZmFjZTMgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMiksIG9uID0gX0V2ZW50SW50ZXJmYWNlMy5vbiwgYmluZCA9IF9FdmVudEludGVyZmFjZTMuYmluZCwgZW1pdCA9IF9FdmVudEludGVyZmFjZTMuZW1pdDtcbiAgdmFyIFNsaWRlczIgPSBDb21wb25lbnRzMi5TbGlkZXM7XG4gIHZhciByZXNvbHZlID0gQ29tcG9uZW50czIuRGlyZWN0aW9uLnJlc29sdmU7XG4gIHZhciBfQ29tcG9uZW50czIkRWxlbWVudHMyID0gQ29tcG9uZW50czIuRWxlbWVudHMsIHJvb3QgPSBfQ29tcG9uZW50czIkRWxlbWVudHMyLnJvb3QsIHRyYWNrID0gX0NvbXBvbmVudHMyJEVsZW1lbnRzMi50cmFjaywgbGlzdCA9IF9Db21wb25lbnRzMiRFbGVtZW50czIubGlzdDtcbiAgdmFyIGdldEF0ID0gU2xpZGVzMi5nZXRBdCwgc3R5bGVTbGlkZXMgPSBTbGlkZXMyLnN0eWxlO1xuICB2YXIgdmVydGljYWw7XG4gIHZhciByb290UmVjdDtcbiAgdmFyIG92ZXJmbG93O1xuICBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBpbml0KCk7XG4gICAgYmluZCh3aW5kb3csIFwicmVzaXplIGxvYWRcIiwgVGhyb3R0bGUoYXBwbHkoZW1pdCwgRVZFTlRfUkVTSVpFKSkpO1xuICAgIG9uKFtFVkVOVF9VUERBVEVELCBFVkVOVF9SRUZSRVNIXSwgaW5pdCk7XG4gICAgb24oRVZFTlRfUkVTSVpFLCByZXNpemUpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmVydGljYWwgPSBvcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCO1xuICAgIHN0eWxlKHJvb3QsIFwibWF4V2lkdGhcIiwgdW5pdChvcHRpb25zLndpZHRoKSk7XG4gICAgc3R5bGUodHJhY2ssIHJlc29sdmUoXCJwYWRkaW5nTGVmdFwiKSwgY3NzUGFkZGluZyhmYWxzZSkpO1xuICAgIHN0eWxlKHRyYWNrLCByZXNvbHZlKFwicGFkZGluZ1JpZ2h0XCIpLCBjc3NQYWRkaW5nKHRydWUpKTtcbiAgICByZXNpemUodHJ1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzaXplKGZvcmNlKSB7XG4gICAgdmFyIG5ld1JlY3QgPSByZWN0KHJvb3QpO1xuICAgIGlmIChmb3JjZSB8fCByb290UmVjdC53aWR0aCAhPT0gbmV3UmVjdC53aWR0aCB8fCByb290UmVjdC5oZWlnaHQgIT09IG5ld1JlY3QuaGVpZ2h0KSB7XG4gICAgICBzdHlsZSh0cmFjaywgXCJoZWlnaHRcIiwgY3NzVHJhY2tIZWlnaHQoKSk7XG4gICAgICBzdHlsZVNsaWRlcyhyZXNvbHZlKFwibWFyZ2luUmlnaHRcIiksIHVuaXQob3B0aW9ucy5nYXApKTtcbiAgICAgIHN0eWxlU2xpZGVzKFwid2lkdGhcIiwgY3NzU2xpZGVXaWR0aCgpKTtcbiAgICAgIHN0eWxlU2xpZGVzKFwiaGVpZ2h0XCIsIGNzc1NsaWRlSGVpZ2h0KCksIHRydWUpO1xuICAgICAgcm9vdFJlY3QgPSBuZXdSZWN0O1xuICAgICAgZW1pdChFVkVOVF9SRVNJWkVEKTtcbiAgICAgIGlmIChvdmVyZmxvdyAhPT0gKG92ZXJmbG93ID0gaXNPdmVyZmxvdygpKSkge1xuICAgICAgICB0b2dnbGVDbGFzcyhyb290LCBDTEFTU19PVkVSRkxPVywgb3ZlcmZsb3cpO1xuICAgICAgICBlbWl0KEVWRU5UX09WRVJGTE9XLCBvdmVyZmxvdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNzc1BhZGRpbmcocmlnaHQpIHtcbiAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcbiAgICB2YXIgcHJvcCA9IHJlc29sdmUocmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgcmV0dXJuIHBhZGRpbmcgJiYgdW5pdChwYWRkaW5nW3Byb3BdIHx8IChpc09iamVjdChwYWRkaW5nKSA/IDAgOiBwYWRkaW5nKSkgfHwgXCIwcHhcIjtcbiAgfVxuICBmdW5jdGlvbiBjc3NUcmFja0hlaWdodCgpIHtcbiAgICB2YXIgaGVpZ2h0ID0gXCJcIjtcbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGhlaWdodCA9IGNzc0hlaWdodCgpO1xuICAgICAgYXNzZXJ0KGhlaWdodCwgXCJoZWlnaHQgb3IgaGVpZ2h0UmF0aW8gaXMgbWlzc2luZy5cIik7XG4gICAgICBoZWlnaHQgPSBcImNhbGMoXCIgKyBoZWlnaHQgKyBcIiAtIFwiICsgY3NzUGFkZGluZyhmYWxzZSkgKyBcIiAtIFwiICsgY3NzUGFkZGluZyh0cnVlKSArIFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGNzc0hlaWdodCgpIHtcbiAgICByZXR1cm4gdW5pdChvcHRpb25zLmhlaWdodCB8fCByZWN0KGxpc3QpLndpZHRoICogb3B0aW9ucy5oZWlnaHRSYXRpbyk7XG4gIH1cbiAgZnVuY3Rpb24gY3NzU2xpZGVXaWR0aCgpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5hdXRvV2lkdGggPyBudWxsIDogdW5pdChvcHRpb25zLmZpeGVkV2lkdGgpIHx8ICh2ZXJ0aWNhbCA/IFwiXCIgOiBjc3NTbGlkZVNpemUoKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3NzU2xpZGVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHVuaXQob3B0aW9ucy5maXhlZEhlaWdodCkgfHwgKHZlcnRpY2FsID8gb3B0aW9ucy5hdXRvSGVpZ2h0ID8gbnVsbCA6IGNzc1NsaWRlU2l6ZSgpIDogY3NzSGVpZ2h0KCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNzc1NsaWRlU2l6ZSgpIHtcbiAgICB2YXIgZ2FwID0gdW5pdChvcHRpb25zLmdhcCk7XG4gICAgcmV0dXJuIFwiY2FsYygoMTAwJVwiICsgKGdhcCAmJiBcIiArIFwiICsgZ2FwKSArIFwiKS9cIiArIChvcHRpb25zLnBlclBhZ2UgfHwgMSkgKyAoZ2FwICYmIFwiIC0gXCIgKyBnYXApICsgXCIpXCI7XG4gIH1cbiAgZnVuY3Rpb24gbGlzdFNpemUoKSB7XG4gICAgcmV0dXJuIHJlY3QobGlzdClbcmVzb2x2ZShcIndpZHRoXCIpXTtcbiAgfVxuICBmdW5jdGlvbiBzbGlkZVNpemUoaW5kZXgsIHdpdGhvdXRHYXApIHtcbiAgICB2YXIgU2xpZGUyID0gZ2V0QXQoaW5kZXggfHwgMCk7XG4gICAgcmV0dXJuIFNsaWRlMiA/IHJlY3QoU2xpZGUyLnNsaWRlKVtyZXNvbHZlKFwid2lkdGhcIildICsgKHdpdGhvdXRHYXAgPyAwIDogZ2V0R2FwKCkpIDogMDtcbiAgfVxuICBmdW5jdGlvbiB0b3RhbFNpemUoaW5kZXgsIHdpdGhvdXRHYXApIHtcbiAgICB2YXIgU2xpZGUyID0gZ2V0QXQoaW5kZXgpO1xuICAgIGlmIChTbGlkZTIpIHtcbiAgICAgIHZhciByaWdodCA9IHJlY3QoU2xpZGUyLnNsaWRlKVtyZXNvbHZlKFwicmlnaHRcIildO1xuICAgICAgdmFyIGxlZnQgPSByZWN0KGxpc3QpW3Jlc29sdmUoXCJsZWZ0XCIpXTtcbiAgICAgIHJldHVybiBhYnMocmlnaHQgLSBsZWZ0KSArICh3aXRob3V0R2FwID8gMCA6IGdldEdhcCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gc2xpZGVyU2l6ZSh3aXRob3V0R2FwKSB7XG4gICAgcmV0dXJuIHRvdGFsU2l6ZShTcGxpZGUyMi5sZW5ndGggLSAxKSAtIHRvdGFsU2l6ZSgwKSArIHNsaWRlU2l6ZSgwLCB3aXRob3V0R2FwKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHYXAoKSB7XG4gICAgdmFyIFNsaWRlMiA9IGdldEF0KDApO1xuICAgIHJldHVybiBTbGlkZTIgJiYgcGFyc2VGbG9hdChzdHlsZShTbGlkZTIuc2xpZGUsIHJlc29sdmUoXCJtYXJnaW5SaWdodFwiKSkpIHx8IDA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGFkZGluZyhyaWdodCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlKHRyYWNrLCByZXNvbHZlKFwicGFkZGluZ1wiICsgKHJpZ2h0ID8gXCJSaWdodFwiIDogXCJMZWZ0XCIpKSkpIHx8IDA7XG4gIH1cbiAgZnVuY3Rpb24gaXNPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gU3BsaWRlMjIuaXMoRkFERSkgfHwgc2xpZGVyU2l6ZSh0cnVlKSA+IGxpc3RTaXplKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb3VudCxcbiAgICByZXNpemUsXG4gICAgbGlzdFNpemUsXG4gICAgc2xpZGVTaXplLFxuICAgIHNsaWRlclNpemUsXG4gICAgdG90YWxTaXplLFxuICAgIGdldFBhZGRpbmcsXG4gICAgaXNPdmVyZmxvd1xuICB9O1xufVxudmFyIE1VTFRJUExJRVIgPSAyO1xuZnVuY3Rpb24gQ2xvbmVzKFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgZXZlbnQgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMik7XG4gIHZhciBvbiA9IGV2ZW50Lm9uO1xuICB2YXIgRWxlbWVudHMyID0gQ29tcG9uZW50czIuRWxlbWVudHMsIFNsaWRlczIgPSBDb21wb25lbnRzMi5TbGlkZXM7XG4gIHZhciByZXNvbHZlID0gQ29tcG9uZW50czIuRGlyZWN0aW9uLnJlc29sdmU7XG4gIHZhciBjbG9uZXMgPSBbXTtcbiAgdmFyIGNsb25lQ291bnQ7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIG9uKEVWRU5UX1JFRlJFU0gsIHJlbW91bnQpO1xuICAgIG9uKFtFVkVOVF9VUERBVEVELCBFVkVOVF9SRVNJWkVdLCBvYnNlcnZlKTtcbiAgICBpZiAoY2xvbmVDb3VudCA9IGNvbXB1dGVDbG9uZUNvdW50KCkpIHtcbiAgICAgIGdlbmVyYXRlKGNsb25lQ291bnQpO1xuICAgICAgQ29tcG9uZW50czIuTGF5b3V0LnJlc2l6ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3VudCgpIHtcbiAgICBkZXN0cm95KCk7XG4gICAgbW91bnQoKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHJlbW92ZShjbG9uZXMpO1xuICAgIGVtcHR5KGNsb25lcyk7XG4gICAgZXZlbnQuZGVzdHJveSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9ic2VydmUoKSB7XG4gICAgdmFyIGNvdW50ID0gY29tcHV0ZUNsb25lQ291bnQoKTtcbiAgICBpZiAoY2xvbmVDb3VudCAhPT0gY291bnQpIHtcbiAgICAgIGlmIChjbG9uZUNvdW50IDwgY291bnQgfHwgIWNvdW50KSB7XG4gICAgICAgIGV2ZW50LmVtaXQoRVZFTlRfUkVGUkVTSCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlKGNvdW50KSB7XG4gICAgdmFyIHNsaWRlcyA9IFNsaWRlczIuZ2V0KCkuc2xpY2UoKTtcbiAgICB2YXIgbGVuZ3RoID0gc2xpZGVzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICB3aGlsZSAoc2xpZGVzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIHB1c2goc2xpZGVzLCBzbGlkZXMpO1xuICAgICAgfVxuICAgICAgcHVzaChzbGlkZXMuc2xpY2UoLWNvdW50KSwgc2xpZGVzLnNsaWNlKDAsIGNvdW50KSkuZm9yRWFjaChmdW5jdGlvbihTbGlkZTIsIGluZGV4KSB7XG4gICAgICAgIHZhciBpc0hlYWQgPSBpbmRleCA8IGNvdW50O1xuICAgICAgICB2YXIgY2xvbmUgPSBjbG9uZURlZXAoU2xpZGUyLnNsaWRlLCBpbmRleCk7XG4gICAgICAgIGlzSGVhZCA/IGJlZm9yZShjbG9uZSwgc2xpZGVzWzBdLnNsaWRlKSA6IGFwcGVuZChFbGVtZW50czIubGlzdCwgY2xvbmUpO1xuICAgICAgICBwdXNoKGNsb25lcywgY2xvbmUpO1xuICAgICAgICBTbGlkZXMyLnJlZ2lzdGVyKGNsb25lLCBpbmRleCAtIGNvdW50ICsgKGlzSGVhZCA/IDAgOiBsZW5ndGgpLCBTbGlkZTIuaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNsb25lRGVlcChlbG0sIGluZGV4KSB7XG4gICAgdmFyIGNsb25lID0gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICBhZGRDbGFzcyhjbG9uZSwgb3B0aW9ucy5jbGFzc2VzLmNsb25lKTtcbiAgICBjbG9uZS5pZCA9IFNwbGlkZTIyLnJvb3QuaWQgKyBcIi1jbG9uZVwiICsgcGFkKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXB1dGVDbG9uZUNvdW50KCkge1xuICAgIHZhciBjbG9uZXMyID0gb3B0aW9ucy5jbG9uZXM7XG4gICAgaWYgKCFTcGxpZGUyMi5pcyhMT09QKSkge1xuICAgICAgY2xvbmVzMiA9IDA7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmaW5lZChjbG9uZXMyKSkge1xuICAgICAgdmFyIGZpeGVkU2l6ZSA9IG9wdGlvbnNbcmVzb2x2ZShcImZpeGVkV2lkdGhcIildICYmIENvbXBvbmVudHMyLkxheW91dC5zbGlkZVNpemUoMCk7XG4gICAgICB2YXIgZml4ZWRDb3VudCA9IGZpeGVkU2l6ZSAmJiBjZWlsKHJlY3QoRWxlbWVudHMyLnRyYWNrKVtyZXNvbHZlKFwid2lkdGhcIildIC8gZml4ZWRTaXplKTtcbiAgICAgIGNsb25lczIgPSBmaXhlZENvdW50IHx8IG9wdGlvbnNbcmVzb2x2ZShcImF1dG9XaWR0aFwiKV0gJiYgU3BsaWRlMjIubGVuZ3RoIHx8IG9wdGlvbnMucGVyUGFnZSAqIE1VTFRJUExJRVI7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZXMyO1xuICB9XG4gIHJldHVybiB7XG4gICAgbW91bnQsXG4gICAgZGVzdHJveVxuICB9O1xufVxuZnVuY3Rpb24gTW92ZShTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgdmFyIF9FdmVudEludGVyZmFjZTQgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMiksIG9uID0gX0V2ZW50SW50ZXJmYWNlNC5vbiwgZW1pdCA9IF9FdmVudEludGVyZmFjZTQuZW1pdDtcbiAgdmFyIHNldCA9IFNwbGlkZTIyLnN0YXRlLnNldDtcbiAgdmFyIF9Db21wb25lbnRzMiRMYXlvdXQgPSBDb21wb25lbnRzMi5MYXlvdXQsIHNsaWRlU2l6ZSA9IF9Db21wb25lbnRzMiRMYXlvdXQuc2xpZGVTaXplLCBnZXRQYWRkaW5nID0gX0NvbXBvbmVudHMyJExheW91dC5nZXRQYWRkaW5nLCB0b3RhbFNpemUgPSBfQ29tcG9uZW50czIkTGF5b3V0LnRvdGFsU2l6ZSwgbGlzdFNpemUgPSBfQ29tcG9uZW50czIkTGF5b3V0Lmxpc3RTaXplLCBzbGlkZXJTaXplID0gX0NvbXBvbmVudHMyJExheW91dC5zbGlkZXJTaXplO1xuICB2YXIgX0NvbXBvbmVudHMyJERpcmVjdGlvID0gQ29tcG9uZW50czIuRGlyZWN0aW9uLCByZXNvbHZlID0gX0NvbXBvbmVudHMyJERpcmVjdGlvLnJlc29sdmUsIG9yaWVudCA9IF9Db21wb25lbnRzMiREaXJlY3Rpby5vcmllbnQ7XG4gIHZhciBfQ29tcG9uZW50czIkRWxlbWVudHMzID0gQ29tcG9uZW50czIuRWxlbWVudHMsIGxpc3QgPSBfQ29tcG9uZW50czIkRWxlbWVudHMzLmxpc3QsIHRyYWNrID0gX0NvbXBvbmVudHMyJEVsZW1lbnRzMy50cmFjaztcbiAgdmFyIFRyYW5zaXRpb247XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIFRyYW5zaXRpb24gPSBDb21wb25lbnRzMi5UcmFuc2l0aW9uO1xuICAgIG9uKFtFVkVOVF9NT1VOVEVELCBFVkVOVF9SRVNJWkVELCBFVkVOVF9VUERBVEVELCBFVkVOVF9SRUZSRVNIXSwgcmVwb3NpdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gcmVwb3NpdGlvbigpIHtcbiAgICBpZiAoIUNvbXBvbmVudHMyLkNvbnRyb2xsZXIuaXNCdXN5KCkpIHtcbiAgICAgIENvbXBvbmVudHMyLlNjcm9sbC5jYW5jZWwoKTtcbiAgICAgIGp1bXAoU3BsaWRlMjIuaW5kZXgpO1xuICAgICAgQ29tcG9uZW50czIuU2xpZGVzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtb3ZlKGRlc3QsIGluZGV4LCBwcmV2LCBjYWxsYmFjaykge1xuICAgIGlmIChkZXN0ICE9PSBpbmRleCAmJiBjYW5TaGlmdChkZXN0ID4gcHJldikpIHtcbiAgICAgIGNhbmNlbCgpO1xuICAgICAgdHJhbnNsYXRlKHNoaWZ0KGdldFBvc2l0aW9uKCksIGRlc3QgPiBwcmV2KSwgdHJ1ZSk7XG4gICAgfVxuICAgIHNldChNT1ZJTkcpO1xuICAgIGVtaXQoRVZFTlRfTU9WRSwgaW5kZXgsIHByZXYsIGRlc3QpO1xuICAgIFRyYW5zaXRpb24uc3RhcnQoaW5kZXgsIGZ1bmN0aW9uKCkge1xuICAgICAgc2V0KElETEUpO1xuICAgICAgZW1pdChFVkVOVF9NT1ZFRCwgaW5kZXgsIHByZXYsIGRlc3QpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBqdW1wKGluZGV4KSB7XG4gICAgdHJhbnNsYXRlKHRvUG9zaXRpb24oaW5kZXgsIHRydWUpKTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGUocG9zaXRpb24sIHByZXZlbnRMb29wKSB7XG4gICAgaWYgKCFTcGxpZGUyMi5pcyhGQURFKSkge1xuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcHJldmVudExvb3AgPyBwb3NpdGlvbiA6IGxvb3AocG9zaXRpb24pO1xuICAgICAgc3R5bGUobGlzdCwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVcIiArIHJlc29sdmUoXCJYXCIpICsgXCIoXCIgKyBkZXN0aW5hdGlvbiArIFwicHgpXCIpO1xuICAgICAgcG9zaXRpb24gIT09IGRlc3RpbmF0aW9uICYmIGVtaXQoRVZFTlRfU0hJRlRFRCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxvb3AocG9zaXRpb24pIHtcbiAgICBpZiAoU3BsaWRlMjIuaXMoTE9PUCkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRvSW5kZXgocG9zaXRpb24pO1xuICAgICAgdmFyIGV4Y2VlZGVkTWF4ID0gaW5kZXggPiBDb21wb25lbnRzMi5Db250cm9sbGVyLmdldEVuZCgpO1xuICAgICAgdmFyIGV4Y2VlZGVkTWluID0gaW5kZXggPCAwO1xuICAgICAgaWYgKGV4Y2VlZGVkTWluIHx8IGV4Y2VlZGVkTWF4KSB7XG4gICAgICAgIHBvc2l0aW9uID0gc2hpZnQocG9zaXRpb24sIGV4Y2VlZGVkTWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHNoaWZ0KHBvc2l0aW9uLCBiYWNrd2FyZHMpIHtcbiAgICB2YXIgZXhjZXNzID0gcG9zaXRpb24gLSBnZXRMaW1pdChiYWNrd2FyZHMpO1xuICAgIHZhciBzaXplID0gc2xpZGVyU2l6ZSgpO1xuICAgIHBvc2l0aW9uIC09IG9yaWVudChzaXplICogKGNlaWwoYWJzKGV4Y2VzcykgLyBzaXplKSB8fCAxKSkgKiAoYmFja3dhcmRzID8gMSA6IC0xKTtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHRyYW5zbGF0ZShnZXRQb3NpdGlvbigpLCB0cnVlKTtcbiAgICBUcmFuc2l0aW9uLmNhbmNlbCgpO1xuICB9XG4gIGZ1bmN0aW9uIHRvSW5kZXgocG9zaXRpb24pIHtcbiAgICB2YXIgU2xpZGVzMiA9IENvbXBvbmVudHMyLlNsaWRlcy5nZXQoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU2xpZGVzMi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNsaWRlSW5kZXggPSBTbGlkZXMyW2ldLmluZGV4O1xuICAgICAgdmFyIGRpc3RhbmNlID0gYWJzKHRvUG9zaXRpb24oc2xpZGVJbmRleCwgdHJ1ZSkgLSBwb3NpdGlvbik7XG4gICAgICBpZiAoZGlzdGFuY2UgPD0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgaW5kZXggPSBzbGlkZUluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBmdW5jdGlvbiB0b1Bvc2l0aW9uKGluZGV4LCB0cmltbWluZykge1xuICAgIHZhciBwb3NpdGlvbiA9IG9yaWVudCh0b3RhbFNpemUoaW5kZXggLSAxKSAtIG9mZnNldChpbmRleCkpO1xuICAgIHJldHVybiB0cmltbWluZyA/IHRyaW0ocG9zaXRpb24pIDogcG9zaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgdmFyIGxlZnQgPSByZXNvbHZlKFwibGVmdFwiKTtcbiAgICByZXR1cm4gcmVjdChsaXN0KVtsZWZ0XSAtIHJlY3QodHJhY2spW2xlZnRdICsgb3JpZW50KGdldFBhZGRpbmcoZmFsc2UpKTtcbiAgfVxuICBmdW5jdGlvbiB0cmltKHBvc2l0aW9uKSB7XG4gICAgaWYgKG9wdGlvbnMudHJpbVNwYWNlICYmIFNwbGlkZTIyLmlzKFNMSURFKSkge1xuICAgICAgcG9zaXRpb24gPSBjbGFtcChwb3NpdGlvbiwgMCwgb3JpZW50KHNsaWRlclNpemUodHJ1ZSkgLSBsaXN0U2l6ZSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBvZmZzZXQoaW5kZXgpIHtcbiAgICB2YXIgZm9jdXMyID0gb3B0aW9ucy5mb2N1cztcbiAgICByZXR1cm4gZm9jdXMyID09PSBcImNlbnRlclwiID8gKGxpc3RTaXplKCkgLSBzbGlkZVNpemUoaW5kZXgsIHRydWUpKSAvIDIgOiArZm9jdXMyICogc2xpZGVTaXplKGluZGV4KSB8fCAwO1xuICB9XG4gIGZ1bmN0aW9uIGdldExpbWl0KG1heDIpIHtcbiAgICByZXR1cm4gdG9Qb3NpdGlvbihtYXgyID8gQ29tcG9uZW50czIuQ29udHJvbGxlci5nZXRFbmQoKSA6IDAsICEhb3B0aW9ucy50cmltU3BhY2UpO1xuICB9XG4gIGZ1bmN0aW9uIGNhblNoaWZ0KGJhY2t3YXJkcykge1xuICAgIHZhciBzaGlmdGVkID0gb3JpZW50KHNoaWZ0KGdldFBvc2l0aW9uKCksIGJhY2t3YXJkcykpO1xuICAgIHJldHVybiBiYWNrd2FyZHMgPyBzaGlmdGVkID49IDAgOiBzaGlmdGVkIDw9IGxpc3RbcmVzb2x2ZShcInNjcm9sbFdpZHRoXCIpXSAtIHJlY3QodHJhY2spW3Jlc29sdmUoXCJ3aWR0aFwiKV07XG4gIH1cbiAgZnVuY3Rpb24gZXhjZWVkZWRMaW1pdChtYXgyLCBwb3NpdGlvbikge1xuICAgIHBvc2l0aW9uID0gaXNVbmRlZmluZWQocG9zaXRpb24pID8gZ2V0UG9zaXRpb24oKSA6IHBvc2l0aW9uO1xuICAgIHZhciBleGNlZWRlZE1pbiA9IG1heDIgIT09IHRydWUgJiYgb3JpZW50KHBvc2l0aW9uKSA8IG9yaWVudChnZXRMaW1pdChmYWxzZSkpO1xuICAgIHZhciBleGNlZWRlZE1heCA9IG1heDIgIT09IGZhbHNlICYmIG9yaWVudChwb3NpdGlvbikgPiBvcmllbnQoZ2V0TGltaXQodHJ1ZSkpO1xuICAgIHJldHVybiBleGNlZWRlZE1pbiB8fCBleGNlZWRlZE1heDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1vdW50LFxuICAgIG1vdmUsXG4gICAganVtcCxcbiAgICB0cmFuc2xhdGUsXG4gICAgc2hpZnQsXG4gICAgY2FuY2VsLFxuICAgIHRvSW5kZXgsXG4gICAgdG9Qb3NpdGlvbixcbiAgICBnZXRQb3NpdGlvbixcbiAgICBnZXRMaW1pdCxcbiAgICBleGNlZWRlZExpbWl0LFxuICAgIHJlcG9zaXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIENvbnRyb2xsZXIoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBfRXZlbnRJbnRlcmZhY2U1ID0gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLCBvbiA9IF9FdmVudEludGVyZmFjZTUub24sIGVtaXQgPSBfRXZlbnRJbnRlcmZhY2U1LmVtaXQ7XG4gIHZhciBNb3ZlMiA9IENvbXBvbmVudHMyLk1vdmU7XG4gIHZhciBnZXRQb3NpdGlvbiA9IE1vdmUyLmdldFBvc2l0aW9uLCBnZXRMaW1pdCA9IE1vdmUyLmdldExpbWl0LCB0b1Bvc2l0aW9uID0gTW92ZTIudG9Qb3NpdGlvbjtcbiAgdmFyIF9Db21wb25lbnRzMiRTbGlkZXMgPSBDb21wb25lbnRzMi5TbGlkZXMsIGlzRW5vdWdoID0gX0NvbXBvbmVudHMyJFNsaWRlcy5pc0Vub3VnaCwgZ2V0TGVuZ3RoID0gX0NvbXBvbmVudHMyJFNsaWRlcy5nZXRMZW5ndGg7XG4gIHZhciBvbWl0RW5kID0gb3B0aW9ucy5vbWl0RW5kO1xuICB2YXIgaXNMb29wID0gU3BsaWRlMjIuaXMoTE9PUCk7XG4gIHZhciBpc1NsaWRlID0gU3BsaWRlMjIuaXMoU0xJREUpO1xuICB2YXIgZ2V0TmV4dCA9IGFwcGx5KGdldEFkamFjZW50LCBmYWxzZSk7XG4gIHZhciBnZXRQcmV2ID0gYXBwbHkoZ2V0QWRqYWNlbnQsIHRydWUpO1xuICB2YXIgY3VyckluZGV4ID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuICB2YXIgZW5kSW5kZXg7XG4gIHZhciBwcmV2SW5kZXggPSBjdXJySW5kZXg7XG4gIHZhciBzbGlkZUNvdW50O1xuICB2YXIgcGVyTW92ZTtcbiAgdmFyIHBlclBhZ2U7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGluaXQoKTtcbiAgICBvbihbRVZFTlRfVVBEQVRFRCwgRVZFTlRfUkVGUkVTSCwgRVZFTlRfRU5EX0lOREVYX0NIQU5HRURdLCBpbml0KTtcbiAgICBvbihFVkVOVF9SRVNJWkVELCBvblJlc2l6ZWQpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgc2xpZGVDb3VudCA9IGdldExlbmd0aCh0cnVlKTtcbiAgICBwZXJNb3ZlID0gb3B0aW9ucy5wZXJNb3ZlO1xuICAgIHBlclBhZ2UgPSBvcHRpb25zLnBlclBhZ2U7XG4gICAgZW5kSW5kZXggPSBnZXRFbmQoKTtcbiAgICB2YXIgaW5kZXggPSBjbGFtcChjdXJySW5kZXgsIDAsIG9taXRFbmQgPyBlbmRJbmRleCA6IHNsaWRlQ291bnQgLSAxKTtcbiAgICBpZiAoaW5kZXggIT09IGN1cnJJbmRleCkge1xuICAgICAgY3VyckluZGV4ID0gaW5kZXg7XG4gICAgICBNb3ZlMi5yZXBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uUmVzaXplZCgpIHtcbiAgICBpZiAoZW5kSW5kZXggIT09IGdldEVuZCgpKSB7XG4gICAgICBlbWl0KEVWRU5UX0VORF9JTkRFWF9DSEFOR0VEKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ28oY29udHJvbCwgYWxsb3dTYW1lSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFpc0J1c3koKSkge1xuICAgICAgdmFyIGRlc3QgPSBwYXJzZShjb250cm9sKTtcbiAgICAgIHZhciBpbmRleCA9IGxvb3AoZGVzdCk7XG4gICAgICBpZiAoaW5kZXggPiAtMSAmJiAoYWxsb3dTYW1lSW5kZXggfHwgaW5kZXggIT09IGN1cnJJbmRleCkpIHtcbiAgICAgICAgc2V0SW5kZXgoaW5kZXgpO1xuICAgICAgICBNb3ZlMi5tb3ZlKGRlc3QsIGluZGV4LCBwcmV2SW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiwgc25hcCwgY2FsbGJhY2spIHtcbiAgICBDb21wb25lbnRzMi5TY3JvbGwuc2Nyb2xsKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiwgc25hcCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5kZXggPSBsb29wKE1vdmUyLnRvSW5kZXgoZ2V0UG9zaXRpb24oKSkpO1xuICAgICAgc2V0SW5kZXgob21pdEVuZCA/IG1pbihpbmRleCwgZW5kSW5kZXgpIDogaW5kZXgpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZShjb250cm9sKSB7XG4gICAgdmFyIGluZGV4ID0gY3VyckluZGV4O1xuICAgIGlmIChpc1N0cmluZyhjb250cm9sKSkge1xuICAgICAgdmFyIF9yZWYgPSBjb250cm9sLm1hdGNoKC8oWytcXC08Pl0pKFxcZCspPy8pIHx8IFtdLCBpbmRpY2F0b3IgPSBfcmVmWzFdLCBudW1iZXIgPSBfcmVmWzJdO1xuICAgICAgaWYgKGluZGljYXRvciA9PT0gXCIrXCIgfHwgaW5kaWNhdG9yID09PSBcIi1cIikge1xuICAgICAgICBpbmRleCA9IGNvbXB1dGVEZXN0SW5kZXgoY3VyckluZGV4ICsgKyhcIlwiICsgaW5kaWNhdG9yICsgKCtudW1iZXIgfHwgMSkpLCBjdXJySW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChpbmRpY2F0b3IgPT09IFwiPlwiKSB7XG4gICAgICAgIGluZGV4ID0gbnVtYmVyID8gdG9JbmRleCgrbnVtYmVyKSA6IGdldE5leHQodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGljYXRvciA9PT0gXCI8XCIpIHtcbiAgICAgICAgaW5kZXggPSBnZXRQcmV2KHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IGlzTG9vcCA/IGNvbnRyb2wgOiBjbGFtcChjb250cm9sLCAwLCBlbmRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBmdW5jdGlvbiBnZXRBZGphY2VudChwcmV2LCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBudW1iZXIgPSBwZXJNb3ZlIHx8IChoYXNGb2N1cygpID8gMSA6IHBlclBhZ2UpO1xuICAgIHZhciBkZXN0ID0gY29tcHV0ZURlc3RJbmRleChjdXJySW5kZXggKyBudW1iZXIgKiAocHJldiA/IC0xIDogMSksIGN1cnJJbmRleCwgIShwZXJNb3ZlIHx8IGhhc0ZvY3VzKCkpKTtcbiAgICBpZiAoZGVzdCA9PT0gLTEgJiYgaXNTbGlkZSkge1xuICAgICAgaWYgKCFhcHByb3hpbWF0ZWx5RXF1YWwoZ2V0UG9zaXRpb24oKSwgZ2V0TGltaXQoIXByZXYpLCAxKSkge1xuICAgICAgICByZXR1cm4gcHJldiA/IDAgOiBlbmRJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uID8gZGVzdCA6IGxvb3AoZGVzdCk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcHV0ZURlc3RJbmRleChkZXN0LCBmcm9tLCBzbmFwUGFnZSkge1xuICAgIGlmIChpc0Vub3VnaCgpIHx8IGhhc0ZvY3VzKCkpIHtcbiAgICAgIHZhciBpbmRleCA9IGNvbXB1dGVNb3ZhYmxlRGVzdEluZGV4KGRlc3QpO1xuICAgICAgaWYgKGluZGV4ICE9PSBkZXN0KSB7XG4gICAgICAgIGZyb20gPSBkZXN0O1xuICAgICAgICBkZXN0ID0gaW5kZXg7XG4gICAgICAgIHNuYXBQYWdlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZGVzdCA8IDAgfHwgZGVzdCA+IGVuZEluZGV4KSB7XG4gICAgICAgIGlmICghcGVyTW92ZSAmJiAoYmV0d2VlbigwLCBkZXN0LCBmcm9tLCB0cnVlKSB8fCBiZXR3ZWVuKGVuZEluZGV4LCBmcm9tLCBkZXN0LCB0cnVlKSkpIHtcbiAgICAgICAgICBkZXN0ID0gdG9JbmRleCh0b1BhZ2UoZGVzdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgIGRlc3QgPSBzbmFwUGFnZSA/IGRlc3QgPCAwID8gLShzbGlkZUNvdW50ICUgcGVyUGFnZSB8fCBwZXJQYWdlKSA6IHNsaWRlQ291bnQgOiBkZXN0O1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXdpbmQpIHtcbiAgICAgICAgICAgIGRlc3QgPSBkZXN0IDwgMCA/IGVuZEluZGV4IDogMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNuYXBQYWdlICYmIGRlc3QgIT09IGZyb20pIHtcbiAgICAgICAgICBkZXN0ID0gdG9JbmRleCh0b1BhZ2UoZnJvbSkgKyAoZGVzdCA8IGZyb20gPyAtMSA6IDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0ID0gLTE7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIGZ1bmN0aW9uIGNvbXB1dGVNb3ZhYmxlRGVzdEluZGV4KGRlc3QpIHtcbiAgICBpZiAoaXNTbGlkZSAmJiBvcHRpb25zLnRyaW1TcGFjZSA9PT0gXCJtb3ZlXCIgJiYgZGVzdCAhPT0gY3VyckluZGV4KSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbigpO1xuICAgICAgd2hpbGUgKHBvc2l0aW9uID09PSB0b1Bvc2l0aW9uKGRlc3QsIHRydWUpICYmIGJldHdlZW4oZGVzdCwgMCwgU3BsaWRlMjIubGVuZ3RoIC0gMSwgIW9wdGlvbnMucmV3aW5kKSkge1xuICAgICAgICBkZXN0IDwgY3VyckluZGV4ID8gLS1kZXN0IDogKytkZXN0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBmdW5jdGlvbiBsb29wKGluZGV4KSB7XG4gICAgcmV0dXJuIGlzTG9vcCA/IChpbmRleCArIHNsaWRlQ291bnQpICUgc2xpZGVDb3VudCB8fCAwIDogaW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW5kKCkge1xuICAgIHZhciBlbmQgPSBzbGlkZUNvdW50IC0gKGhhc0ZvY3VzKCkgfHwgaXNMb29wICYmIHBlck1vdmUgPyAxIDogcGVyUGFnZSk7XG4gICAgd2hpbGUgKG9taXRFbmQgJiYgZW5kLS0gPiAwKSB7XG4gICAgICBpZiAodG9Qb3NpdGlvbihzbGlkZUNvdW50IC0gMSwgdHJ1ZSkgIT09IHRvUG9zaXRpb24oZW5kLCB0cnVlKSkge1xuICAgICAgICBlbmQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGFtcChlbmQsIDAsIHNsaWRlQ291bnQgLSAxKTtcbiAgfVxuICBmdW5jdGlvbiB0b0luZGV4KHBhZ2UpIHtcbiAgICByZXR1cm4gY2xhbXAoaGFzRm9jdXMoKSA/IHBhZ2UgOiBwZXJQYWdlICogcGFnZSwgMCwgZW5kSW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIHRvUGFnZShpbmRleCkge1xuICAgIHJldHVybiBoYXNGb2N1cygpID8gbWluKGluZGV4LCBlbmRJbmRleCkgOiBmbG9vcigoaW5kZXggPj0gZW5kSW5kZXggPyBzbGlkZUNvdW50IC0gMSA6IGluZGV4KSAvIHBlclBhZ2UpO1xuICB9XG4gIGZ1bmN0aW9uIHRvRGVzdChkZXN0aW5hdGlvbikge1xuICAgIHZhciBjbG9zZXN0MiA9IE1vdmUyLnRvSW5kZXgoZGVzdGluYXRpb24pO1xuICAgIHJldHVybiBpc1NsaWRlID8gY2xhbXAoY2xvc2VzdDIsIDAsIGVuZEluZGV4KSA6IGNsb3Nlc3QyO1xuICB9XG4gIGZ1bmN0aW9uIHNldEluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICE9PSBjdXJySW5kZXgpIHtcbiAgICAgIHByZXZJbmRleCA9IGN1cnJJbmRleDtcbiAgICAgIGN1cnJJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRJbmRleChwcmV2KSB7XG4gICAgcmV0dXJuIHByZXYgPyBwcmV2SW5kZXggOiBjdXJySW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZChvcHRpb25zLmZvY3VzKSB8fCBvcHRpb25zLmlzTmF2aWdhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBpc0J1c3koKSB7XG4gICAgcmV0dXJuIFNwbGlkZTIyLnN0YXRlLmlzKFtNT1ZJTkcsIFNDUk9MTElOR10pICYmICEhb3B0aW9ucy53YWl0Rm9yVHJhbnNpdGlvbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1vdW50LFxuICAgIGdvLFxuICAgIHNjcm9sbCxcbiAgICBnZXROZXh0LFxuICAgIGdldFByZXYsXG4gICAgZ2V0QWRqYWNlbnQsXG4gICAgZ2V0RW5kLFxuICAgIHNldEluZGV4LFxuICAgIGdldEluZGV4LFxuICAgIHRvSW5kZXgsXG4gICAgdG9QYWdlLFxuICAgIHRvRGVzdCxcbiAgICBoYXNGb2N1cyxcbiAgICBpc0J1c3lcbiAgfTtcbn1cbnZhciBYTUxfTkFNRV9TUEFDRSA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbnZhciBQQVRIID0gXCJtMTUuNSAwLjkzMi00LjMgNC4zOCAxNC41IDE0LjYtMTQuNSAxNC41IDQuMyA0LjQgMTQuNi0xNC42IDQuNC00LjMtNC40LTQuNC0xNC42LTE0LjZ6XCI7XG52YXIgU0laRSA9IDQwO1xuZnVuY3Rpb24gQXJyb3dzKFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgZXZlbnQgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMik7XG4gIHZhciBvbiA9IGV2ZW50Lm9uLCBiaW5kID0gZXZlbnQuYmluZCwgZW1pdCA9IGV2ZW50LmVtaXQ7XG4gIHZhciBjbGFzc2VzID0gb3B0aW9ucy5jbGFzc2VzLCBpMThuID0gb3B0aW9ucy5pMThuO1xuICB2YXIgRWxlbWVudHMyID0gQ29tcG9uZW50czIuRWxlbWVudHMsIENvbnRyb2xsZXIyID0gQ29tcG9uZW50czIuQ29udHJvbGxlcjtcbiAgdmFyIHBsYWNlaG9sZGVyID0gRWxlbWVudHMyLmFycm93cywgdHJhY2sgPSBFbGVtZW50czIudHJhY2s7XG4gIHZhciB3cmFwcGVyID0gcGxhY2Vob2xkZXI7XG4gIHZhciBwcmV2ID0gRWxlbWVudHMyLnByZXY7XG4gIHZhciBuZXh0ID0gRWxlbWVudHMyLm5leHQ7XG4gIHZhciBjcmVhdGVkO1xuICB2YXIgd3JhcHBlckNsYXNzZXM7XG4gIHZhciBhcnJvd3MgPSB7fTtcbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgaW5pdCgpO1xuICAgIG9uKEVWRU5UX1VQREFURUQsIHJlbW91bnQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW91bnQoKSB7XG4gICAgZGVzdHJveSgpO1xuICAgIG1vdW50KCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgZW5hYmxlZCA9IG9wdGlvbnMuYXJyb3dzO1xuICAgIGlmIChlbmFibGVkICYmICEocHJldiAmJiBuZXh0KSkge1xuICAgICAgY3JlYXRlQXJyb3dzKCk7XG4gICAgfVxuICAgIGlmIChwcmV2ICYmIG5leHQpIHtcbiAgICAgIGFzc2lnbihhcnJvd3MsIHtcbiAgICAgICAgcHJldixcbiAgICAgICAgbmV4dFxuICAgICAgfSk7XG4gICAgICBkaXNwbGF5KHdyYXBwZXIsIGVuYWJsZWQgPyBcIlwiIDogXCJub25lXCIpO1xuICAgICAgYWRkQ2xhc3Mod3JhcHBlciwgd3JhcHBlckNsYXNzZXMgPSBDTEFTU19BUlJPV1MgKyBcIi0tXCIgKyBvcHRpb25zLmRpcmVjdGlvbik7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBsaXN0ZW4oKTtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIHNldEF0dHJpYnV0ZShbcHJldiwgbmV4dF0sIEFSSUFfQ09OVFJPTFMsIHRyYWNrLmlkKTtcbiAgICAgICAgZW1pdChFVkVOVF9BUlJPV1NfTU9VTlRFRCwgcHJldiwgbmV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZXZlbnQuZGVzdHJveSgpO1xuICAgIHJlbW92ZUNsYXNzKHdyYXBwZXIsIHdyYXBwZXJDbGFzc2VzKTtcbiAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyID8gW3ByZXYsIG5leHRdIDogd3JhcHBlcik7XG4gICAgICBwcmV2ID0gbmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShbcHJldiwgbmV4dF0sIEFMTF9BVFRSSUJVVEVTKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgIG9uKFtFVkVOVF9NT1VOVEVELCBFVkVOVF9NT1ZFRCwgRVZFTlRfUkVGUkVTSCwgRVZFTlRfU0NST0xMRUQsIEVWRU5UX0VORF9JTkRFWF9DSEFOR0VEXSwgdXBkYXRlKTtcbiAgICBiaW5kKG5leHQsIFwiY2xpY2tcIiwgYXBwbHkoZ28sIFwiPlwiKSk7XG4gICAgYmluZChwcmV2LCBcImNsaWNrXCIsIGFwcGx5KGdvLCBcIjxcIikpO1xuICB9XG4gIGZ1bmN0aW9uIGdvKGNvbnRyb2wpIHtcbiAgICBDb250cm9sbGVyMi5nbyhjb250cm9sLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVBcnJvd3MoKSB7XG4gICAgd3JhcHBlciA9IHBsYWNlaG9sZGVyIHx8IGNyZWF0ZShcImRpdlwiLCBjbGFzc2VzLmFycm93cyk7XG4gICAgcHJldiA9IGNyZWF0ZUFycm93KHRydWUpO1xuICAgIG5leHQgPSBjcmVhdGVBcnJvdyhmYWxzZSk7XG4gICAgY3JlYXRlZCA9IHRydWU7XG4gICAgYXBwZW5kKHdyYXBwZXIsIFtwcmV2LCBuZXh0XSk7XG4gICAgIXBsYWNlaG9sZGVyICYmIGJlZm9yZSh3cmFwcGVyLCB0cmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQXJyb3cocHJldjIpIHtcbiAgICB2YXIgYXJyb3cgPSAnPGJ1dHRvbiBjbGFzcz1cIicgKyBjbGFzc2VzLmFycm93ICsgXCIgXCIgKyAocHJldjIgPyBjbGFzc2VzLnByZXYgOiBjbGFzc2VzLm5leHQpICsgJ1wiIHR5cGU9XCJidXR0b25cIj48c3ZnIHhtbG5zPVwiJyArIFhNTF9OQU1FX1NQQUNFICsgJ1wiIHZpZXdCb3g9XCIwIDAgJyArIFNJWkUgKyBcIiBcIiArIFNJWkUgKyAnXCIgd2lkdGg9XCInICsgU0laRSArICdcIiBoZWlnaHQ9XCInICsgU0laRSArICdcIiBmb2N1c2FibGU9XCJmYWxzZVwiPjxwYXRoIGQ9XCInICsgKG9wdGlvbnMuYXJyb3dQYXRoIHx8IFBBVEgpICsgJ1wiIC8+JztcbiAgICByZXR1cm4gcGFyc2VIdG1sKGFycm93KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgaWYgKHByZXYgJiYgbmV4dCkge1xuICAgICAgdmFyIGluZGV4ID0gU3BsaWRlMjIuaW5kZXg7XG4gICAgICB2YXIgcHJldkluZGV4ID0gQ29udHJvbGxlcjIuZ2V0UHJldigpO1xuICAgICAgdmFyIG5leHRJbmRleCA9IENvbnRyb2xsZXIyLmdldE5leHQoKTtcbiAgICAgIHZhciBwcmV2TGFiZWwgPSBwcmV2SW5kZXggPiAtMSAmJiBpbmRleCA8IHByZXZJbmRleCA/IGkxOG4ubGFzdCA6IGkxOG4ucHJldjtcbiAgICAgIHZhciBuZXh0TGFiZWwgPSBuZXh0SW5kZXggPiAtMSAmJiBpbmRleCA+IG5leHRJbmRleCA/IGkxOG4uZmlyc3QgOiBpMThuLm5leHQ7XG4gICAgICBwcmV2LmRpc2FibGVkID0gcHJldkluZGV4IDwgMDtcbiAgICAgIG5leHQuZGlzYWJsZWQgPSBuZXh0SW5kZXggPCAwO1xuICAgICAgc2V0QXR0cmlidXRlKHByZXYsIEFSSUFfTEFCRUwsIHByZXZMYWJlbCk7XG4gICAgICBzZXRBdHRyaWJ1dGUobmV4dCwgQVJJQV9MQUJFTCwgbmV4dExhYmVsKTtcbiAgICAgIGVtaXQoRVZFTlRfQVJST1dTX1VQREFURUQsIHByZXYsIG5leHQsIHByZXZJbmRleCwgbmV4dEluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhcnJvd3MsXG4gICAgbW91bnQsXG4gICAgZGVzdHJveSxcbiAgICB1cGRhdGVcbiAgfTtcbn1cbnZhciBJTlRFUlZBTF9EQVRBX0FUVFJJQlVURSA9IERBVEFfQVRUUklCVVRFICsgXCItaW50ZXJ2YWxcIjtcbmZ1bmN0aW9uIEF1dG9wbGF5KFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgX0V2ZW50SW50ZXJmYWNlNiA9IEV2ZW50SW50ZXJmYWNlKFNwbGlkZTIyKSwgb24gPSBfRXZlbnRJbnRlcmZhY2U2Lm9uLCBiaW5kID0gX0V2ZW50SW50ZXJmYWNlNi5iaW5kLCBlbWl0ID0gX0V2ZW50SW50ZXJmYWNlNi5lbWl0O1xuICB2YXIgaW50ZXJ2YWwgPSBSZXF1ZXN0SW50ZXJ2YWwob3B0aW9ucy5pbnRlcnZhbCwgU3BsaWRlMjIuZ28uYmluZChTcGxpZGUyMiwgXCI+XCIpLCBvbkFuaW1hdGlvbkZyYW1lKTtcbiAgdmFyIGlzUGF1c2VkID0gaW50ZXJ2YWwuaXNQYXVzZWQ7XG4gIHZhciBFbGVtZW50czIgPSBDb21wb25lbnRzMi5FbGVtZW50cywgX0NvbXBvbmVudHMyJEVsZW1lbnRzNCA9IENvbXBvbmVudHMyLkVsZW1lbnRzLCByb290ID0gX0NvbXBvbmVudHMyJEVsZW1lbnRzNC5yb290LCB0b2dnbGUgPSBfQ29tcG9uZW50czIkRWxlbWVudHM0LnRvZ2dsZTtcbiAgdmFyIGF1dG9wbGF5ID0gb3B0aW9ucy5hdXRvcGxheTtcbiAgdmFyIGhvdmVyZWQ7XG4gIHZhciBmb2N1c2VkO1xuICB2YXIgc3RvcHBlZCA9IGF1dG9wbGF5ID09PSBcInBhdXNlXCI7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgbGlzdGVuKCk7XG4gICAgICB0b2dnbGUgJiYgc2V0QXR0cmlidXRlKHRvZ2dsZSwgQVJJQV9DT05UUk9MUywgRWxlbWVudHMyLnRyYWNrLmlkKTtcbiAgICAgIHN0b3BwZWQgfHwgcGxheSgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICBpZiAob3B0aW9ucy5wYXVzZU9uSG92ZXIpIHtcbiAgICAgIGJpbmQocm9vdCwgXCJtb3VzZWVudGVyIG1vdXNlbGVhdmVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBob3ZlcmVkID0gZS50eXBlID09PSBcIm1vdXNlZW50ZXJcIjtcbiAgICAgICAgYXV0b1RvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhdXNlT25Gb2N1cykge1xuICAgICAgYmluZChyb290LCBcImZvY3VzaW4gZm9jdXNvdXRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBmb2N1c2VkID0gZS50eXBlID09PSBcImZvY3VzaW5cIjtcbiAgICAgICAgYXV0b1RvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b2dnbGUpIHtcbiAgICAgIGJpbmQodG9nZ2xlLCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdG9wcGVkID8gcGxheSgpIDogcGF1c2UodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgb24oW0VWRU5UX01PVkUsIEVWRU5UX1NDUk9MTCwgRVZFTlRfUkVGUkVTSF0sIGludGVydmFsLnJld2luZCk7XG4gICAgb24oRVZFTlRfTU9WRSwgb25Nb3ZlKTtcbiAgfVxuICBmdW5jdGlvbiBwbGF5KCkge1xuICAgIGlmIChpc1BhdXNlZCgpICYmIENvbXBvbmVudHMyLlNsaWRlcy5pc0Vub3VnaCgpKSB7XG4gICAgICBpbnRlcnZhbC5zdGFydCghb3B0aW9ucy5yZXNldFByb2dyZXNzKTtcbiAgICAgIGZvY3VzZWQgPSBob3ZlcmVkID0gc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBlbWl0KEVWRU5UX0FVVE9QTEFZX1BMQVkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXVzZShzdG9wKSB7XG4gICAgaWYgKHN0b3AgPT09IHZvaWQgMCkge1xuICAgICAgc3RvcCA9IHRydWU7XG4gICAgfVxuICAgIHN0b3BwZWQgPSAhIXN0b3A7XG4gICAgdXBkYXRlKCk7XG4gICAgaWYgKCFpc1BhdXNlZCgpKSB7XG4gICAgICBpbnRlcnZhbC5wYXVzZSgpO1xuICAgICAgZW1pdChFVkVOVF9BVVRPUExBWV9QQVVTRSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGF1dG9Ub2dnbGUoKSB7XG4gICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICBob3ZlcmVkIHx8IGZvY3VzZWQgPyBwYXVzZShmYWxzZSkgOiBwbGF5KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAodG9nZ2xlKSB7XG4gICAgICB0b2dnbGVDbGFzcyh0b2dnbGUsIENMQVNTX0FDVElWRSwgIXN0b3BwZWQpO1xuICAgICAgc2V0QXR0cmlidXRlKHRvZ2dsZSwgQVJJQV9MQUJFTCwgb3B0aW9ucy5pMThuW3N0b3BwZWQgPyBcInBsYXlcIiA6IFwicGF1c2VcIl0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKHJhdGUpIHtcbiAgICB2YXIgYmFyID0gRWxlbWVudHMyLmJhcjtcbiAgICBiYXIgJiYgc3R5bGUoYmFyLCBcIndpZHRoXCIsIHJhdGUgKiAxMDAgKyBcIiVcIik7XG4gICAgZW1pdChFVkVOVF9BVVRPUExBWV9QTEFZSU5HLCByYXRlKTtcbiAgfVxuICBmdW5jdGlvbiBvbk1vdmUoaW5kZXgpIHtcbiAgICB2YXIgU2xpZGUyID0gQ29tcG9uZW50czIuU2xpZGVzLmdldEF0KGluZGV4KTtcbiAgICBpbnRlcnZhbC5zZXQoU2xpZGUyICYmICtnZXRBdHRyaWJ1dGUoU2xpZGUyLnNsaWRlLCBJTlRFUlZBTF9EQVRBX0FUVFJJQlVURSkgfHwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb3VudCxcbiAgICBkZXN0cm95OiBpbnRlcnZhbC5jYW5jZWwsXG4gICAgcGxheSxcbiAgICBwYXVzZSxcbiAgICBpc1BhdXNlZFxuICB9O1xufVxuZnVuY3Rpb24gQ292ZXIoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBfRXZlbnRJbnRlcmZhY2U3ID0gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLCBvbiA9IF9FdmVudEludGVyZmFjZTcub247XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGlmIChvcHRpb25zLmNvdmVyKSB7XG4gICAgICBvbihFVkVOVF9MQVpZTE9BRF9MT0FERUQsIGFwcGx5KHRvZ2dsZSwgdHJ1ZSkpO1xuICAgICAgb24oW0VWRU5UX01PVU5URUQsIEVWRU5UX1VQREFURUQsIEVWRU5UX1JFRlJFU0hdLCBhcHBseShjb3ZlciwgdHJ1ZSkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjb3Zlcihjb3ZlcjIpIHtcbiAgICBDb21wb25lbnRzMi5TbGlkZXMuZm9yRWFjaChmdW5jdGlvbihTbGlkZTIpIHtcbiAgICAgIHZhciBpbWcgPSBjaGlsZChTbGlkZTIuY29udGFpbmVyIHx8IFNsaWRlMi5zbGlkZSwgXCJpbWdcIik7XG4gICAgICBpZiAoaW1nICYmIGltZy5zcmMpIHtcbiAgICAgICAgdG9nZ2xlKGNvdmVyMiwgaW1nLCBTbGlkZTIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZShjb3ZlcjIsIGltZywgU2xpZGUyKSB7XG4gICAgU2xpZGUyLnN0eWxlKFwiYmFja2dyb3VuZFwiLCBjb3ZlcjIgPyAnY2VudGVyL2NvdmVyIG5vLXJlcGVhdCB1cmwoXCInICsgaW1nLnNyYyArICdcIiknIDogXCJcIiwgdHJ1ZSk7XG4gICAgZGlzcGxheShpbWcsIGNvdmVyMiA/IFwibm9uZVwiIDogXCJcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb3VudCxcbiAgICBkZXN0cm95OiBhcHBseShjb3ZlciwgZmFsc2UpXG4gIH07XG59XG52YXIgQk9VTkNFX0RJRkZfVEhSRVNIT0xEID0gMTA7XG52YXIgQk9VTkNFX0RVUkFUSU9OID0gNjAwO1xudmFyIEZSSUNUSU9OX0ZBQ1RPUiA9IDAuNjtcbnZhciBCQVNFX1ZFTE9DSVRZID0gMS41O1xudmFyIE1JTl9EVVJBVElPTiA9IDgwMDtcbmZ1bmN0aW9uIFNjcm9sbChTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgdmFyIF9FdmVudEludGVyZmFjZTggPSBFdmVudEludGVyZmFjZShTcGxpZGUyMiksIG9uID0gX0V2ZW50SW50ZXJmYWNlOC5vbiwgZW1pdCA9IF9FdmVudEludGVyZmFjZTguZW1pdDtcbiAgdmFyIHNldCA9IFNwbGlkZTIyLnN0YXRlLnNldDtcbiAgdmFyIE1vdmUyID0gQ29tcG9uZW50czIuTW92ZTtcbiAgdmFyIGdldFBvc2l0aW9uID0gTW92ZTIuZ2V0UG9zaXRpb24sIGdldExpbWl0ID0gTW92ZTIuZ2V0TGltaXQsIGV4Y2VlZGVkTGltaXQgPSBNb3ZlMi5leGNlZWRlZExpbWl0LCB0cmFuc2xhdGUgPSBNb3ZlMi50cmFuc2xhdGU7XG4gIHZhciBpc1NsaWRlID0gU3BsaWRlMjIuaXMoU0xJREUpO1xuICB2YXIgaW50ZXJ2YWw7XG4gIHZhciBjYWxsYmFjaztcbiAgdmFyIGZyaWN0aW9uID0gMTtcbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgb24oRVZFTlRfTU9WRSwgY2xlYXIpO1xuICAgIG9uKFtFVkVOVF9VUERBVEVELCBFVkVOVF9SRUZSRVNIXSwgY2FuY2VsKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGwoZGVzdGluYXRpb24sIGR1cmF0aW9uLCBzbmFwLCBvblNjcm9sbGVkLCBub0NvbnN0cmFpbikge1xuICAgIHZhciBmcm9tID0gZ2V0UG9zaXRpb24oKTtcbiAgICBjbGVhcigpO1xuICAgIGlmIChzbmFwICYmICghaXNTbGlkZSB8fCAhZXhjZWVkZWRMaW1pdCgpKSkge1xuICAgICAgdmFyIHNpemUgPSBDb21wb25lbnRzMi5MYXlvdXQuc2xpZGVyU2l6ZSgpO1xuICAgICAgdmFyIG9mZnNldCA9IHNpZ24oZGVzdGluYXRpb24pICogc2l6ZSAqIGZsb29yKGFicyhkZXN0aW5hdGlvbikgLyBzaXplKSB8fCAwO1xuICAgICAgZGVzdGluYXRpb24gPSBNb3ZlMi50b1Bvc2l0aW9uKENvbXBvbmVudHMyLkNvbnRyb2xsZXIudG9EZXN0KGRlc3RpbmF0aW9uICUgc2l6ZSkpICsgb2Zmc2V0O1xuICAgIH1cbiAgICB2YXIgbm9EaXN0YW5jZSA9IGFwcHJveGltYXRlbHlFcXVhbChmcm9tLCBkZXN0aW5hdGlvbiwgMSk7XG4gICAgZnJpY3Rpb24gPSAxO1xuICAgIGR1cmF0aW9uID0gbm9EaXN0YW5jZSA/IDAgOiBkdXJhdGlvbiB8fCBtYXgoYWJzKGRlc3RpbmF0aW9uIC0gZnJvbSkgLyBCQVNFX1ZFTE9DSVRZLCBNSU5fRFVSQVRJT04pO1xuICAgIGNhbGxiYWNrID0gb25TY3JvbGxlZDtcbiAgICBpbnRlcnZhbCA9IFJlcXVlc3RJbnRlcnZhbChkdXJhdGlvbiwgb25FbmQsIGFwcGx5KHVwZGF0ZSwgZnJvbSwgZGVzdGluYXRpb24sIG5vQ29uc3RyYWluKSwgMSk7XG4gICAgc2V0KFNDUk9MTElORyk7XG4gICAgZW1pdChFVkVOVF9TQ1JPTEwpO1xuICAgIGludGVydmFsLnN0YXJ0KCk7XG4gIH1cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgc2V0KElETEUpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgZW1pdChFVkVOVF9TQ1JPTExFRCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGZyb20sIHRvLCBub0NvbnN0cmFpbiwgcmF0ZSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKCk7XG4gICAgdmFyIHRhcmdldCA9IGZyb20gKyAodG8gLSBmcm9tKSAqIGVhc2luZyhyYXRlKTtcbiAgICB2YXIgZGlmZiA9ICh0YXJnZXQgLSBwb3NpdGlvbikgKiBmcmljdGlvbjtcbiAgICB0cmFuc2xhdGUocG9zaXRpb24gKyBkaWZmKTtcbiAgICBpZiAoaXNTbGlkZSAmJiAhbm9Db25zdHJhaW4gJiYgZXhjZWVkZWRMaW1pdCgpKSB7XG4gICAgICBmcmljdGlvbiAqPSBGUklDVElPTl9GQUNUT1I7XG4gICAgICBpZiAoYWJzKGRpZmYpIDwgQk9VTkNFX0RJRkZfVEhSRVNIT0xEKSB7XG4gICAgICAgIHNjcm9sbChnZXRMaW1pdChleGNlZWRlZExpbWl0KHRydWUpKSwgQk9VTkNFX0RVUkFUSU9OLCBmYWxzZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgIGludGVydmFsLmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKGludGVydmFsICYmICFpbnRlcnZhbC5pc1BhdXNlZCgpKSB7XG4gICAgICBjbGVhcigpO1xuICAgICAgb25FbmQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZWFzaW5nKHQpIHtcbiAgICB2YXIgZWFzaW5nRnVuYyA9IG9wdGlvbnMuZWFzaW5nRnVuYztcbiAgICByZXR1cm4gZWFzaW5nRnVuYyA/IGVhc2luZ0Z1bmModCkgOiAxIC0gTWF0aC5wb3coMSAtIHQsIDQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbW91bnQsXG4gICAgZGVzdHJveTogY2xlYXIsXG4gICAgc2Nyb2xsLFxuICAgIGNhbmNlbFxuICB9O1xufVxudmFyIFNDUk9MTF9MSVNURU5FUl9PUFRJT05TID0ge1xuICBwYXNzaXZlOiBmYWxzZSxcbiAgY2FwdHVyZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIERyYWcoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBfRXZlbnRJbnRlcmZhY2U5ID0gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLCBvbiA9IF9FdmVudEludGVyZmFjZTkub24sIGVtaXQgPSBfRXZlbnRJbnRlcmZhY2U5LmVtaXQsIGJpbmQgPSBfRXZlbnRJbnRlcmZhY2U5LmJpbmQsIHVuYmluZCA9IF9FdmVudEludGVyZmFjZTkudW5iaW5kO1xuICB2YXIgc3RhdGUgPSBTcGxpZGUyMi5zdGF0ZTtcbiAgdmFyIE1vdmUyID0gQ29tcG9uZW50czIuTW92ZSwgU2Nyb2xsMiA9IENvbXBvbmVudHMyLlNjcm9sbCwgQ29udHJvbGxlcjIgPSBDb21wb25lbnRzMi5Db250cm9sbGVyLCB0cmFjayA9IENvbXBvbmVudHMyLkVsZW1lbnRzLnRyYWNrLCByZWR1Y2UgPSBDb21wb25lbnRzMi5NZWRpYS5yZWR1Y2U7XG4gIHZhciBfQ29tcG9uZW50czIkRGlyZWN0aW8yID0gQ29tcG9uZW50czIuRGlyZWN0aW9uLCByZXNvbHZlID0gX0NvbXBvbmVudHMyJERpcmVjdGlvMi5yZXNvbHZlLCBvcmllbnQgPSBfQ29tcG9uZW50czIkRGlyZWN0aW8yLm9yaWVudDtcbiAgdmFyIGdldFBvc2l0aW9uID0gTW92ZTIuZ2V0UG9zaXRpb24sIGV4Y2VlZGVkTGltaXQgPSBNb3ZlMi5leGNlZWRlZExpbWl0O1xuICB2YXIgYmFzZVBvc2l0aW9uO1xuICB2YXIgYmFzZUV2ZW50O1xuICB2YXIgcHJldkJhc2VFdmVudDtcbiAgdmFyIGlzRnJlZTtcbiAgdmFyIGRyYWdnaW5nO1xuICB2YXIgZXhjZWVkZWQgPSBmYWxzZTtcbiAgdmFyIGNsaWNrUHJldmVudGVkO1xuICB2YXIgZGlzYWJsZWQ7XG4gIHZhciB0YXJnZXQ7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGJpbmQodHJhY2ssIFBPSU5URVJfTU9WRV9FVkVOVFMsIG5vb3AsIFNDUk9MTF9MSVNURU5FUl9PUFRJT05TKTtcbiAgICBiaW5kKHRyYWNrLCBQT0lOVEVSX1VQX0VWRU5UUywgbm9vcCwgU0NST0xMX0xJU1RFTkVSX09QVElPTlMpO1xuICAgIGJpbmQodHJhY2ssIFBPSU5URVJfRE9XTl9FVkVOVFMsIG9uUG9pbnRlckRvd24sIFNDUk9MTF9MSVNURU5FUl9PUFRJT05TKTtcbiAgICBiaW5kKHRyYWNrLCBcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICBiaW5kKHRyYWNrLCBcImRyYWdzdGFydFwiLCBwcmV2ZW50KTtcbiAgICBvbihbRVZFTlRfTU9VTlRFRCwgRVZFTlRfVVBEQVRFRF0sIGluaXQpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIGRyYWcgPSBvcHRpb25zLmRyYWc7XG4gICAgZGlzYWJsZSghZHJhZyk7XG4gICAgaXNGcmVlID0gZHJhZyA9PT0gXCJmcmVlXCI7XG4gIH1cbiAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihlKSB7XG4gICAgY2xpY2tQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICB2YXIgaXNUb3VjaCA9IGlzVG91Y2hFdmVudChlKTtcbiAgICAgIGlmIChpc0RyYWdnYWJsZShlLnRhcmdldCkgJiYgKGlzVG91Y2ggfHwgIWUuYnV0dG9uKSkge1xuICAgICAgICBpZiAoIUNvbnRyb2xsZXIyLmlzQnVzeSgpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gaXNUb3VjaCA/IHRyYWNrIDogd2luZG93O1xuICAgICAgICAgIGRyYWdnaW5nID0gc3RhdGUuaXMoW01PVklORywgU0NST0xMSU5HXSk7XG4gICAgICAgICAgcHJldkJhc2VFdmVudCA9IG51bGw7XG4gICAgICAgICAgYmluZCh0YXJnZXQsIFBPSU5URVJfTU9WRV9FVkVOVFMsIG9uUG9pbnRlck1vdmUsIFNDUk9MTF9MSVNURU5FUl9PUFRJT05TKTtcbiAgICAgICAgICBiaW5kKHRhcmdldCwgUE9JTlRFUl9VUF9FVkVOVFMsIG9uUG9pbnRlclVwLCBTQ1JPTExfTElTVEVORVJfT1BUSU9OUyk7XG4gICAgICAgICAgTW92ZTIuY2FuY2VsKCk7XG4gICAgICAgICAgU2Nyb2xsMi5jYW5jZWwoKTtcbiAgICAgICAgICBzYXZlKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZlbnQoZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShlKSB7XG4gICAgaWYgKCFzdGF0ZS5pcyhEUkFHR0lORykpIHtcbiAgICAgIHN0YXRlLnNldChEUkFHR0lORyk7XG4gICAgICBlbWl0KEVWRU5UX0RSQUcpO1xuICAgIH1cbiAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgTW92ZTIudHJhbnNsYXRlKGJhc2VQb3NpdGlvbiArIGNvbnN0cmFpbihkaWZmQ29vcmQoZSkpKTtcbiAgICAgICAgdmFyIGV4cGlyZWQgPSBkaWZmVGltZShlKSA+IExPR19JTlRFUlZBTDtcbiAgICAgICAgdmFyIGhhc0V4Y2VlZGVkID0gZXhjZWVkZWQgIT09IChleGNlZWRlZCA9IGV4Y2VlZGVkTGltaXQoKSk7XG4gICAgICAgIGlmIChleHBpcmVkIHx8IGhhc0V4Y2VlZGVkKSB7XG4gICAgICAgICAgc2F2ZShlKTtcbiAgICAgICAgfVxuICAgICAgICBjbGlja1ByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIGVtaXQoRVZFTlRfRFJBR0dJTkcpO1xuICAgICAgICBwcmV2ZW50KGUpO1xuICAgICAgfSBlbHNlIGlmIChpc1NsaWRlckRpcmVjdGlvbihlKSkge1xuICAgICAgICBkcmFnZ2luZyA9IHNob3VsZFN0YXJ0KGUpO1xuICAgICAgICBwcmV2ZW50KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblBvaW50ZXJVcChlKSB7XG4gICAgaWYgKHN0YXRlLmlzKERSQUdHSU5HKSkge1xuICAgICAgc3RhdGUuc2V0KElETEUpO1xuICAgICAgZW1pdChFVkVOVF9EUkFHR0VEKTtcbiAgICB9XG4gICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICBtb3ZlKGUpO1xuICAgICAgcHJldmVudChlKTtcbiAgICB9XG4gICAgdW5iaW5kKHRhcmdldCwgUE9JTlRFUl9NT1ZFX0VWRU5UUywgb25Qb2ludGVyTW92ZSk7XG4gICAgdW5iaW5kKHRhcmdldCwgUE9JTlRFUl9VUF9FVkVOVFMsIG9uUG9pbnRlclVwKTtcbiAgICBkcmFnZ2luZyA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIGlmICghZGlzYWJsZWQgJiYgY2xpY2tQcmV2ZW50ZWQpIHtcbiAgICAgIHByZXZlbnQoZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNhdmUoZSkge1xuICAgIHByZXZCYXNlRXZlbnQgPSBiYXNlRXZlbnQ7XG4gICAgYmFzZUV2ZW50ID0gZTtcbiAgICBiYXNlUG9zaXRpb24gPSBnZXRQb3NpdGlvbigpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZSkge1xuICAgIHZhciB2ZWxvY2l0eSA9IGNvbXB1dGVWZWxvY2l0eShlKTtcbiAgICB2YXIgZGVzdGluYXRpb24gPSBjb21wdXRlRGVzdGluYXRpb24odmVsb2NpdHkpO1xuICAgIHZhciByZXdpbmQgPSBvcHRpb25zLnJld2luZCAmJiBvcHRpb25zLnJld2luZEJ5RHJhZztcbiAgICByZWR1Y2UoZmFsc2UpO1xuICAgIGlmIChpc0ZyZWUpIHtcbiAgICAgIENvbnRyb2xsZXIyLnNjcm9sbChkZXN0aW5hdGlvbiwgMCwgb3B0aW9ucy5zbmFwKTtcbiAgICB9IGVsc2UgaWYgKFNwbGlkZTIyLmlzKEZBREUpKSB7XG4gICAgICBDb250cm9sbGVyMi5nbyhvcmllbnQoc2lnbih2ZWxvY2l0eSkpIDwgMCA/IHJld2luZCA/IFwiPFwiIDogXCItXCIgOiByZXdpbmQgPyBcIj5cIiA6IFwiK1wiKTtcbiAgICB9IGVsc2UgaWYgKFNwbGlkZTIyLmlzKFNMSURFKSAmJiBleGNlZWRlZCAmJiByZXdpbmQpIHtcbiAgICAgIENvbnRyb2xsZXIyLmdvKGV4Y2VlZGVkTGltaXQodHJ1ZSkgPyBcIj5cIiA6IFwiPFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29udHJvbGxlcjIuZ28oQ29udHJvbGxlcjIudG9EZXN0KGRlc3RpbmF0aW9uKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJlZHVjZSh0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRTdGFydChlKSB7XG4gICAgdmFyIHRocmVzaG9sZHMgPSBvcHRpb25zLmRyYWdNaW5UaHJlc2hvbGQ7XG4gICAgdmFyIGlzT2JqID0gaXNPYmplY3QodGhyZXNob2xkcyk7XG4gICAgdmFyIG1vdXNlID0gaXNPYmogJiYgdGhyZXNob2xkcy5tb3VzZSB8fCAwO1xuICAgIHZhciB0b3VjaCA9IChpc09iaiA/IHRocmVzaG9sZHMudG91Y2ggOiArdGhyZXNob2xkcykgfHwgMTA7XG4gICAgcmV0dXJuIGFicyhkaWZmQ29vcmQoZSkpID4gKGlzVG91Y2hFdmVudChlKSA/IHRvdWNoIDogbW91c2UpO1xuICB9XG4gIGZ1bmN0aW9uIGlzU2xpZGVyRGlyZWN0aW9uKGUpIHtcbiAgICByZXR1cm4gYWJzKGRpZmZDb29yZChlKSkgPiBhYnMoZGlmZkNvb3JkKGUsIHRydWUpKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlVmVsb2NpdHkoZSkge1xuICAgIGlmIChTcGxpZGUyMi5pcyhMT09QKSB8fCAhZXhjZWVkZWQpIHtcbiAgICAgIHZhciB0aW1lID0gZGlmZlRpbWUoZSk7XG4gICAgICBpZiAodGltZSAmJiB0aW1lIDwgTE9HX0lOVEVSVkFMKSB7XG4gICAgICAgIHJldHVybiBkaWZmQ29vcmQoZSkgLyB0aW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlRGVzdGluYXRpb24odmVsb2NpdHkpIHtcbiAgICByZXR1cm4gZ2V0UG9zaXRpb24oKSArIHNpZ24odmVsb2NpdHkpICogbWluKGFicyh2ZWxvY2l0eSkgKiAob3B0aW9ucy5mbGlja1Bvd2VyIHx8IDYwMCksIGlzRnJlZSA/IEluZmluaXR5IDogQ29tcG9uZW50czIuTGF5b3V0Lmxpc3RTaXplKCkgKiAob3B0aW9ucy5mbGlja01heFBhZ2VzIHx8IDEpKTtcbiAgfVxuICBmdW5jdGlvbiBkaWZmQ29vcmQoZSwgb3J0aG9nb25hbCkge1xuICAgIHJldHVybiBjb29yZE9mKGUsIG9ydGhvZ29uYWwpIC0gY29vcmRPZihnZXRCYXNlRXZlbnQoZSksIG9ydGhvZ29uYWwpO1xuICB9XG4gIGZ1bmN0aW9uIGRpZmZUaW1lKGUpIHtcbiAgICByZXR1cm4gdGltZU9mKGUpIC0gdGltZU9mKGdldEJhc2VFdmVudChlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QmFzZUV2ZW50KGUpIHtcbiAgICByZXR1cm4gYmFzZUV2ZW50ID09PSBlICYmIHByZXZCYXNlRXZlbnQgfHwgYmFzZUV2ZW50O1xuICB9XG4gIGZ1bmN0aW9uIGNvb3JkT2YoZSwgb3J0aG9nb25hbCkge1xuICAgIHJldHVybiAoaXNUb3VjaEV2ZW50KGUpID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGUpW1wicGFnZVwiICsgcmVzb2x2ZShvcnRob2dvbmFsID8gXCJZXCIgOiBcIlhcIildO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihkaWZmKSB7XG4gICAgcmV0dXJuIGRpZmYgLyAoZXhjZWVkZWQgJiYgU3BsaWRlMjIuaXMoU0xJREUpID8gRlJJQ1RJT04gOiAxKTtcbiAgfVxuICBmdW5jdGlvbiBpc0RyYWdnYWJsZSh0YXJnZXQyKSB7XG4gICAgdmFyIG5vRHJhZyA9IG9wdGlvbnMubm9EcmFnO1xuICAgIHJldHVybiAhbWF0Y2hlcyh0YXJnZXQyLCBcIi5cIiArIENMQVNTX1BBR0lOQVRJT05fUEFHRSArIFwiLCAuXCIgKyBDTEFTU19BUlJPVykgJiYgKCFub0RyYWcgfHwgIW1hdGNoZXModGFyZ2V0Miwgbm9EcmFnKSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIFRvdWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG4gIH1cbiAgZnVuY3Rpb24gZGlzYWJsZSh2YWx1ZSkge1xuICAgIGRpc2FibGVkID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb3VudCxcbiAgICBkaXNhYmxlLFxuICAgIGlzRHJhZ2dpbmdcbiAgfTtcbn1cbnZhciBOT1JNQUxJWkFUSU9OX01BUCA9IHtcbiAgU3BhY2ViYXI6IFwiIFwiLFxuICBSaWdodDogQVJST1dfUklHSFQsXG4gIExlZnQ6IEFSUk9XX0xFRlQsXG4gIFVwOiBBUlJPV19VUCxcbiAgRG93bjogQVJST1dfRE9XTlxufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleShrZXkpIHtcbiAga2V5ID0gaXNTdHJpbmcoa2V5KSA/IGtleSA6IGtleS5rZXk7XG4gIHJldHVybiBOT1JNQUxJWkFUSU9OX01BUFtrZXldIHx8IGtleTtcbn1cbnZhciBLRVlCT0FSRF9FVkVOVCA9IFwia2V5ZG93blwiO1xuZnVuY3Rpb24gS2V5Ym9hcmQoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBfRXZlbnRJbnRlcmZhY2UxMCA9IEV2ZW50SW50ZXJmYWNlKFNwbGlkZTIyKSwgb24gPSBfRXZlbnRJbnRlcmZhY2UxMC5vbiwgYmluZCA9IF9FdmVudEludGVyZmFjZTEwLmJpbmQsIHVuYmluZCA9IF9FdmVudEludGVyZmFjZTEwLnVuYmluZDtcbiAgdmFyIHJvb3QgPSBTcGxpZGUyMi5yb290O1xuICB2YXIgcmVzb2x2ZSA9IENvbXBvbmVudHMyLkRpcmVjdGlvbi5yZXNvbHZlO1xuICB2YXIgdGFyZ2V0O1xuICB2YXIgZGlzYWJsZWQ7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGluaXQoKTtcbiAgICBvbihFVkVOVF9VUERBVEVELCBkZXN0cm95KTtcbiAgICBvbihFVkVOVF9VUERBVEVELCBpbml0KTtcbiAgICBvbihFVkVOVF9NT1ZFLCBvbk1vdmUpO1xuICB9XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIGtleWJvYXJkID0gb3B0aW9ucy5rZXlib2FyZDtcbiAgICBpZiAoa2V5Ym9hcmQpIHtcbiAgICAgIHRhcmdldCA9IGtleWJvYXJkID09PSBcImdsb2JhbFwiID8gd2luZG93IDogcm9vdDtcbiAgICAgIGJpbmQodGFyZ2V0LCBLRVlCT0FSRF9FVkVOVCwgb25LZXlkb3duKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB1bmJpbmQodGFyZ2V0LCBLRVlCT0FSRF9FVkVOVCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzYWJsZSh2YWx1ZSkge1xuICAgIGRpc2FibGVkID0gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gb25Nb3ZlKCkge1xuICAgIHZhciBfZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBkaXNhYmxlZCA9IF9kaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvbktleWRvd24oZSkge1xuICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXkoZSk7XG4gICAgICBpZiAoa2V5ID09PSByZXNvbHZlKEFSUk9XX0xFRlQpKSB7XG4gICAgICAgIFNwbGlkZTIyLmdvKFwiPFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSByZXNvbHZlKEFSUk9XX1JJR0hUKSkge1xuICAgICAgICBTcGxpZGUyMi5nbyhcIj5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbW91bnQsXG4gICAgZGVzdHJveSxcbiAgICBkaXNhYmxlXG4gIH07XG59XG52YXIgU1JDX0RBVEFfQVRUUklCVVRFID0gREFUQV9BVFRSSUJVVEUgKyBcIi1sYXp5XCI7XG52YXIgU1JDU0VUX0RBVEFfQVRUUklCVVRFID0gU1JDX0RBVEFfQVRUUklCVVRFICsgXCItc3Jjc2V0XCI7XG52YXIgSU1BR0VfU0VMRUNUT1IgPSBcIltcIiArIFNSQ19EQVRBX0FUVFJJQlVURSArIFwiXSwgW1wiICsgU1JDU0VUX0RBVEFfQVRUUklCVVRFICsgXCJdXCI7XG5mdW5jdGlvbiBMYXp5TG9hZChTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgdmFyIF9FdmVudEludGVyZmFjZTExID0gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLCBvbiA9IF9FdmVudEludGVyZmFjZTExLm9uLCBvZmYgPSBfRXZlbnRJbnRlcmZhY2UxMS5vZmYsIGJpbmQgPSBfRXZlbnRJbnRlcmZhY2UxMS5iaW5kLCBlbWl0ID0gX0V2ZW50SW50ZXJmYWNlMTEuZW1pdDtcbiAgdmFyIGlzU2VxdWVudGlhbCA9IG9wdGlvbnMubGF6eUxvYWQgPT09IFwic2VxdWVudGlhbFwiO1xuICB2YXIgZXZlbnRzID0gW0VWRU5UX01PVkVELCBFVkVOVF9TQ1JPTExFRF07XG4gIHZhciBlbnRyaWVzID0gW107XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGlmIChvcHRpb25zLmxhenlMb2FkKSB7XG4gICAgICBpbml0KCk7XG4gICAgICBvbihFVkVOVF9SRUZSRVNILCBpbml0KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBlbXB0eShlbnRyaWVzKTtcbiAgICByZWdpc3RlcigpO1xuICAgIGlmIChpc1NlcXVlbnRpYWwpIHtcbiAgICAgIGxvYWROZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZihldmVudHMpO1xuICAgICAgb24oZXZlbnRzLCBjaGVjayk7XG4gICAgICBjaGVjaygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICBDb21wb25lbnRzMi5TbGlkZXMuZm9yRWFjaChmdW5jdGlvbihTbGlkZTIpIHtcbiAgICAgIHF1ZXJ5QWxsKFNsaWRlMi5zbGlkZSwgSU1BR0VfU0VMRUNUT1IpLmZvckVhY2goZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgIHZhciBzcmMgPSBnZXRBdHRyaWJ1dGUoaW1nLCBTUkNfREFUQV9BVFRSSUJVVEUpO1xuICAgICAgICB2YXIgc3Jjc2V0ID0gZ2V0QXR0cmlidXRlKGltZywgU1JDU0VUX0RBVEFfQVRUUklCVVRFKTtcbiAgICAgICAgaWYgKHNyYyAhPT0gaW1nLnNyYyB8fCBzcmNzZXQgIT09IGltZy5zcmNzZXQpIHtcbiAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc2VzLnNwaW5uZXI7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGltZy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIHZhciBzcGlubmVyID0gY2hpbGQocGFyZW50LCBcIi5cIiArIGNsYXNzTmFtZSkgfHwgY3JlYXRlKFwic3BhblwiLCBjbGFzc05hbWUsIHBhcmVudCk7XG4gICAgICAgICAgZW50cmllcy5wdXNoKFtpbWcsIFNsaWRlMiwgc3Bpbm5lcl0pO1xuICAgICAgICAgIGltZy5zcmMgfHwgZGlzcGxheShpbWcsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgZW50cmllcyA9IGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBkaXN0YW5jZSA9IG9wdGlvbnMucGVyUGFnZSAqICgob3B0aW9ucy5wcmVsb2FkUGFnZXMgfHwgMSkgKyAxKSAtIDE7XG4gICAgICByZXR1cm4gZGF0YVsxXS5pc1dpdGhpbihTcGxpZGUyMi5pbmRleCwgZGlzdGFuY2UpID8gbG9hZChkYXRhKSA6IHRydWU7XG4gICAgfSk7XG4gICAgZW50cmllcy5sZW5ndGggfHwgb2ZmKGV2ZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZChkYXRhKSB7XG4gICAgdmFyIGltZyA9IGRhdGFbMF07XG4gICAgYWRkQ2xhc3MoZGF0YVsxXS5zbGlkZSwgQ0xBU1NfTE9BRElORyk7XG4gICAgYmluZChpbWcsIFwibG9hZCBlcnJvclwiLCBhcHBseShvbkxvYWQsIGRhdGEpKTtcbiAgICBzZXRBdHRyaWJ1dGUoaW1nLCBcInNyY1wiLCBnZXRBdHRyaWJ1dGUoaW1nLCBTUkNfREFUQV9BVFRSSUJVVEUpKTtcbiAgICBzZXRBdHRyaWJ1dGUoaW1nLCBcInNyY3NldFwiLCBnZXRBdHRyaWJ1dGUoaW1nLCBTUkNTRVRfREFUQV9BVFRSSUJVVEUpKTtcbiAgICByZW1vdmVBdHRyaWJ1dGUoaW1nLCBTUkNfREFUQV9BVFRSSUJVVEUpO1xuICAgIHJlbW92ZUF0dHJpYnV0ZShpbWcsIFNSQ1NFVF9EQVRBX0FUVFJJQlVURSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Mb2FkKGRhdGEsIGUpIHtcbiAgICB2YXIgaW1nID0gZGF0YVswXSwgU2xpZGUyID0gZGF0YVsxXTtcbiAgICByZW1vdmVDbGFzcyhTbGlkZTIuc2xpZGUsIENMQVNTX0xPQURJTkcpO1xuICAgIGlmIChlLnR5cGUgIT09IFwiZXJyb3JcIikge1xuICAgICAgcmVtb3ZlKGRhdGFbMl0pO1xuICAgICAgZGlzcGxheShpbWcsIFwiXCIpO1xuICAgICAgZW1pdChFVkVOVF9MQVpZTE9BRF9MT0FERUQsIGltZywgU2xpZGUyKTtcbiAgICAgIGVtaXQoRVZFTlRfUkVTSVpFKTtcbiAgICB9XG4gICAgaXNTZXF1ZW50aWFsICYmIGxvYWROZXh0KCk7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZE5leHQoKSB7XG4gICAgZW50cmllcy5sZW5ndGggJiYgbG9hZChlbnRyaWVzLnNoaWZ0KCkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbW91bnQsXG4gICAgZGVzdHJveTogYXBwbHkoZW1wdHksIGVudHJpZXMpLFxuICAgIGNoZWNrXG4gIH07XG59XG5mdW5jdGlvbiBQYWdpbmF0aW9uKFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgZXZlbnQgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMik7XG4gIHZhciBvbiA9IGV2ZW50Lm9uLCBlbWl0ID0gZXZlbnQuZW1pdCwgYmluZCA9IGV2ZW50LmJpbmQ7XG4gIHZhciBTbGlkZXMyID0gQ29tcG9uZW50czIuU2xpZGVzLCBFbGVtZW50czIgPSBDb21wb25lbnRzMi5FbGVtZW50cywgQ29udHJvbGxlcjIgPSBDb21wb25lbnRzMi5Db250cm9sbGVyO1xuICB2YXIgaGFzRm9jdXMgPSBDb250cm9sbGVyMi5oYXNGb2N1cywgZ2V0SW5kZXggPSBDb250cm9sbGVyMi5nZXRJbmRleCwgZ28gPSBDb250cm9sbGVyMi5nbztcbiAgdmFyIHJlc29sdmUgPSBDb21wb25lbnRzMi5EaXJlY3Rpb24ucmVzb2x2ZTtcbiAgdmFyIHBsYWNlaG9sZGVyID0gRWxlbWVudHMyLnBhZ2luYXRpb247XG4gIHZhciBpdGVtcyA9IFtdO1xuICB2YXIgbGlzdDtcbiAgdmFyIHBhZ2luYXRpb25DbGFzc2VzO1xuICBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBkZXN0cm95KCk7XG4gICAgb24oW0VWRU5UX1VQREFURUQsIEVWRU5UX1JFRlJFU0gsIEVWRU5UX0VORF9JTkRFWF9DSEFOR0VEXSwgbW91bnQpO1xuICAgIHZhciBlbmFibGVkID0gb3B0aW9ucy5wYWdpbmF0aW9uO1xuICAgIHBsYWNlaG9sZGVyICYmIGRpc3BsYXkocGxhY2Vob2xkZXIsIGVuYWJsZWQgPyBcIlwiIDogXCJub25lXCIpO1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICBvbihbRVZFTlRfTU9WRSwgRVZFTlRfU0NST0xMLCBFVkVOVF9TQ1JPTExFRF0sIHVwZGF0ZSk7XG4gICAgICBjcmVhdGVQYWdpbmF0aW9uKCk7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIGVtaXQoRVZFTlRfUEFHSU5BVElPTl9NT1VOVEVELCB7XG4gICAgICAgIGxpc3QsXG4gICAgICAgIGl0ZW1zXG4gICAgICB9LCBnZXRBdChTcGxpZGUyMi5pbmRleCkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmIChsaXN0KSB7XG4gICAgICByZW1vdmUocGxhY2Vob2xkZXIgPyBzbGljZShsaXN0LmNoaWxkcmVuKSA6IGxpc3QpO1xuICAgICAgcmVtb3ZlQ2xhc3MobGlzdCwgcGFnaW5hdGlvbkNsYXNzZXMpO1xuICAgICAgZW1wdHkoaXRlbXMpO1xuICAgICAgbGlzdCA9IG51bGw7XG4gICAgfVxuICAgIGV2ZW50LmRlc3Ryb3koKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQYWdpbmF0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBTcGxpZGUyMi5sZW5ndGg7XG4gICAgdmFyIGNsYXNzZXMgPSBvcHRpb25zLmNsYXNzZXMsIGkxOG4gPSBvcHRpb25zLmkxOG4sIHBlclBhZ2UgPSBvcHRpb25zLnBlclBhZ2U7XG4gICAgdmFyIG1heDIgPSBoYXNGb2N1cygpID8gQ29udHJvbGxlcjIuZ2V0RW5kKCkgKyAxIDogY2VpbChsZW5ndGggLyBwZXJQYWdlKTtcbiAgICBsaXN0ID0gcGxhY2Vob2xkZXIgfHwgY3JlYXRlKFwidWxcIiwgY2xhc3Nlcy5wYWdpbmF0aW9uLCBFbGVtZW50czIudHJhY2sucGFyZW50RWxlbWVudCk7XG4gICAgYWRkQ2xhc3MobGlzdCwgcGFnaW5hdGlvbkNsYXNzZXMgPSBDTEFTU19QQUdJTkFUSU9OICsgXCItLVwiICsgZ2V0RGlyZWN0aW9uKCkpO1xuICAgIHNldEF0dHJpYnV0ZShsaXN0LCBST0xFLCBcInRhYmxpc3RcIik7XG4gICAgc2V0QXR0cmlidXRlKGxpc3QsIEFSSUFfTEFCRUwsIGkxOG4uc2VsZWN0KTtcbiAgICBzZXRBdHRyaWJ1dGUobGlzdCwgQVJJQV9PUklFTlRBVElPTiwgZ2V0RGlyZWN0aW9uKCkgPT09IFRUQiA/IFwidmVydGljYWxcIiA6IFwiXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4MjsgaSsrKSB7XG4gICAgICB2YXIgbGkgPSBjcmVhdGUoXCJsaVwiLCBudWxsLCBsaXN0KTtcbiAgICAgIHZhciBidXR0b24gPSBjcmVhdGUoXCJidXR0b25cIiwge1xuICAgICAgICBjbGFzczogY2xhc3Nlcy5wYWdlLFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICB9LCBsaSk7XG4gICAgICB2YXIgY29udHJvbHMgPSBTbGlkZXMyLmdldEluKGkpLm1hcChmdW5jdGlvbihTbGlkZTIpIHtcbiAgICAgICAgcmV0dXJuIFNsaWRlMi5zbGlkZS5pZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRleHQgPSAhaGFzRm9jdXMoKSAmJiBwZXJQYWdlID4gMSA/IGkxOG4ucGFnZVggOiBpMThuLnNsaWRlWDtcbiAgICAgIGJpbmQoYnV0dG9uLCBcImNsaWNrXCIsIGFwcGx5KG9uQ2xpY2ssIGkpKTtcbiAgICAgIGlmIChvcHRpb25zLnBhZ2luYXRpb25LZXlib2FyZCkge1xuICAgICAgICBiaW5kKGJ1dHRvbiwgXCJrZXlkb3duXCIsIGFwcGx5KG9uS2V5ZG93biwgaSkpO1xuICAgICAgfVxuICAgICAgc2V0QXR0cmlidXRlKGxpLCBST0xFLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHNldEF0dHJpYnV0ZShidXR0b24sIFJPTEUsIFwidGFiXCIpO1xuICAgICAgc2V0QXR0cmlidXRlKGJ1dHRvbiwgQVJJQV9DT05UUk9MUywgY29udHJvbHMuam9pbihcIiBcIikpO1xuICAgICAgc2V0QXR0cmlidXRlKGJ1dHRvbiwgQVJJQV9MQUJFTCwgZm9ybWF0KHRleHQsIGkgKyAxKSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoYnV0dG9uLCBUQUJfSU5ERVgsIC0xKTtcbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICBsaSxcbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBwYWdlOiBpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25DbGljayhwYWdlKSB7XG4gICAgZ28oXCI+XCIgKyBwYWdlLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBvbktleWRvd24ocGFnZSwgZSkge1xuICAgIHZhciBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleShlKTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uKCk7XG4gICAgdmFyIG5leHRQYWdlID0gLTE7XG4gICAgaWYgKGtleSA9PT0gcmVzb2x2ZShBUlJPV19SSUdIVCwgZmFsc2UsIGRpcikpIHtcbiAgICAgIG5leHRQYWdlID0gKytwYWdlICUgbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSByZXNvbHZlKEFSUk9XX0xFRlQsIGZhbHNlLCBkaXIpKSB7XG4gICAgICBuZXh0UGFnZSA9ICgtLXBhZ2UgKyBsZW5ndGgpICUgbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIkhvbWVcIikge1xuICAgICAgbmV4dFBhZ2UgPSAwO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIkVuZFwiKSB7XG4gICAgICBuZXh0UGFnZSA9IGxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHZhciBpdGVtID0gaXRlbXNbbmV4dFBhZ2VdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBmb2N1cyhpdGVtLmJ1dHRvbik7XG4gICAgICBnbyhcIj5cIiArIG5leHRQYWdlKTtcbiAgICAgIHByZXZlbnQoZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5wYWdpbmF0aW9uRGlyZWN0aW9uIHx8IG9wdGlvbnMuZGlyZWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0KGluZGV4KSB7XG4gICAgcmV0dXJuIGl0ZW1zW0NvbnRyb2xsZXIyLnRvUGFnZShpbmRleCldO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgcHJldiA9IGdldEF0KGdldEluZGV4KHRydWUpKTtcbiAgICB2YXIgY3VyciA9IGdldEF0KGdldEluZGV4KCkpO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICB2YXIgYnV0dG9uID0gcHJldi5idXR0b247XG4gICAgICByZW1vdmVDbGFzcyhidXR0b24sIENMQVNTX0FDVElWRSk7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoYnV0dG9uLCBBUklBX1NFTEVDVEVEKTtcbiAgICAgIHNldEF0dHJpYnV0ZShidXR0b24sIFRBQl9JTkRFWCwgLTEpO1xuICAgIH1cbiAgICBpZiAoY3Vycikge1xuICAgICAgdmFyIF9idXR0b24gPSBjdXJyLmJ1dHRvbjtcbiAgICAgIGFkZENsYXNzKF9idXR0b24sIENMQVNTX0FDVElWRSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoX2J1dHRvbiwgQVJJQV9TRUxFQ1RFRCwgdHJ1ZSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoX2J1dHRvbiwgVEFCX0lOREVYLCBcIlwiKTtcbiAgICB9XG4gICAgZW1pdChFVkVOVF9QQUdJTkFUSU9OX1VQREFURUQsIHtcbiAgICAgIGxpc3QsXG4gICAgICBpdGVtc1xuICAgIH0sIHByZXYsIGN1cnIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXRlbXMsXG4gICAgbW91bnQsXG4gICAgZGVzdHJveSxcbiAgICBnZXRBdCxcbiAgICB1cGRhdGVcbiAgfTtcbn1cbnZhciBUUklHR0VSX0tFWVMgPSBbXCIgXCIsIFwiRW50ZXJcIl07XG5mdW5jdGlvbiBTeW5jKFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgaXNOYXZpZ2F0aW9uID0gb3B0aW9ucy5pc05hdmlnYXRpb24sIHNsaWRlRm9jdXMgPSBvcHRpb25zLnNsaWRlRm9jdXM7XG4gIHZhciBldmVudHMgPSBbXTtcbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgU3BsaWRlMjIuc3BsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQuaXNQYXJlbnQpIHtcbiAgICAgICAgc3luYyhTcGxpZGUyMiwgdGFyZ2V0LnNwbGlkZSk7XG4gICAgICAgIHN5bmModGFyZ2V0LnNwbGlkZSwgU3BsaWRlMjIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChpc05hdmlnYXRpb24pIHtcbiAgICAgIG5hdmlnYXRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGV2ZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBlbXB0eShldmVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW91bnQoKSB7XG4gICAgZGVzdHJveSgpO1xuICAgIG1vdW50KCk7XG4gIH1cbiAgZnVuY3Rpb24gc3luYyhzcGxpZGUsIHRhcmdldCkge1xuICAgIHZhciBldmVudCA9IEV2ZW50SW50ZXJmYWNlKHNwbGlkZSk7XG4gICAgZXZlbnQub24oRVZFTlRfTU9WRSwgZnVuY3Rpb24oaW5kZXgsIHByZXYsIGRlc3QpIHtcbiAgICAgIHRhcmdldC5nbyh0YXJnZXQuaXMoTE9PUCkgPyBkZXN0IDogaW5kZXgpO1xuICAgIH0pO1xuICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBuYXZpZ2F0ZSgpIHtcbiAgICB2YXIgZXZlbnQgPSBFdmVudEludGVyZmFjZShTcGxpZGUyMik7XG4gICAgdmFyIG9uID0gZXZlbnQub247XG4gICAgb24oRVZFTlRfQ0xJQ0ssIG9uQ2xpY2spO1xuICAgIG9uKEVWRU5UX1NMSURFX0tFWURPV04sIG9uS2V5ZG93bik7XG4gICAgb24oW0VWRU5UX01PVU5URUQsIEVWRU5UX1VQREFURURdLCB1cGRhdGUpO1xuICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICBldmVudC5lbWl0KEVWRU5UX05BVklHQVRJT05fTU9VTlRFRCwgU3BsaWRlMjIuc3BsaWRlcyk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHNldEF0dHJpYnV0ZShDb21wb25lbnRzMi5FbGVtZW50cy5saXN0LCBBUklBX09SSUVOVEFUSU9OLCBvcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCID8gXCJ2ZXJ0aWNhbFwiIDogXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gb25DbGljayhTbGlkZTIpIHtcbiAgICBTcGxpZGUyMi5nbyhTbGlkZTIuaW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uS2V5ZG93bihTbGlkZTIsIGUpIHtcbiAgICBpZiAoaW5jbHVkZXMoVFJJR0dFUl9LRVlTLCBub3JtYWxpemVLZXkoZSkpKSB7XG4gICAgICBvbkNsaWNrKFNsaWRlMik7XG4gICAgICBwcmV2ZW50KGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNldHVwOiBhcHBseShDb21wb25lbnRzMi5NZWRpYS5zZXQsIHtcbiAgICAgIHNsaWRlRm9jdXM6IGlzVW5kZWZpbmVkKHNsaWRlRm9jdXMpID8gaXNOYXZpZ2F0aW9uIDogc2xpZGVGb2N1c1xuICAgIH0sIHRydWUpLFxuICAgIG1vdW50LFxuICAgIGRlc3Ryb3ksXG4gICAgcmVtb3VudFxuICB9O1xufVxuZnVuY3Rpb24gV2hlZWwoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBfRXZlbnRJbnRlcmZhY2UxMiA9IEV2ZW50SW50ZXJmYWNlKFNwbGlkZTIyKSwgYmluZCA9IF9FdmVudEludGVyZmFjZTEyLmJpbmQ7XG4gIHZhciBsYXN0VGltZSA9IDA7XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGlmIChvcHRpb25zLndoZWVsKSB7XG4gICAgICBiaW5kKENvbXBvbmVudHMyLkVsZW1lbnRzLnRyYWNrLCBcIndoZWVsXCIsIG9uV2hlZWwsIFNDUk9MTF9MSVNURU5FUl9PUFRJT05TKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG4gICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgdmFyIGRlbHRhWSA9IGUuZGVsdGFZO1xuICAgICAgdmFyIGJhY2t3YXJkcyA9IGRlbHRhWSA8IDA7XG4gICAgICB2YXIgdGltZVN0YW1wID0gdGltZU9mKGUpO1xuICAgICAgdmFyIF9taW4gPSBvcHRpb25zLndoZWVsTWluVGhyZXNob2xkIHx8IDA7XG4gICAgICB2YXIgc2xlZXAgPSBvcHRpb25zLndoZWVsU2xlZXAgfHwgMDtcbiAgICAgIGlmIChhYnMoZGVsdGFZKSA+IF9taW4gJiYgdGltZVN0YW1wIC0gbGFzdFRpbWUgPiBzbGVlcCkge1xuICAgICAgICBTcGxpZGUyMi5nbyhiYWNrd2FyZHMgPyBcIjxcIiA6IFwiPlwiKTtcbiAgICAgICAgbGFzdFRpbWUgPSB0aW1lU3RhbXA7XG4gICAgICB9XG4gICAgICBzaG91bGRQcmV2ZW50KGJhY2t3YXJkcykgJiYgcHJldmVudChlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkUHJldmVudChiYWNrd2FyZHMpIHtcbiAgICByZXR1cm4gIW9wdGlvbnMucmVsZWFzZVdoZWVsIHx8IFNwbGlkZTIyLnN0YXRlLmlzKE1PVklORykgfHwgQ29tcG9uZW50czIuQ29udHJvbGxlci5nZXRBZGphY2VudChiYWNrd2FyZHMpICE9PSAtMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1vdW50XG4gIH07XG59XG52YXIgU1JfUkVNT1ZBTF9ERUxBWSA9IDkwO1xuZnVuY3Rpb24gTGl2ZShTcGxpZGUyMiwgQ29tcG9uZW50czIsIG9wdGlvbnMpIHtcbiAgdmFyIF9FdmVudEludGVyZmFjZTEzID0gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLCBvbiA9IF9FdmVudEludGVyZmFjZTEzLm9uO1xuICB2YXIgdHJhY2sgPSBDb21wb25lbnRzMi5FbGVtZW50cy50cmFjaztcbiAgdmFyIGVuYWJsZWQgPSBvcHRpb25zLmxpdmUgJiYgIW9wdGlvbnMuaXNOYXZpZ2F0aW9uO1xuICB2YXIgc3IgPSBjcmVhdGUoXCJzcGFuXCIsIENMQVNTX1NSKTtcbiAgdmFyIGludGVydmFsID0gUmVxdWVzdEludGVydmFsKFNSX1JFTU9WQUxfREVMQVksIGFwcGx5KHRvZ2dsZSwgZmFsc2UpKTtcbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIGRpc2FibGUoIUNvbXBvbmVudHMyLkF1dG9wbGF5LmlzUGF1c2VkKCkpO1xuICAgICAgc2V0QXR0cmlidXRlKHRyYWNrLCBBUklBX0FUT01JQywgdHJ1ZSk7XG4gICAgICBzci50ZXh0Q29udGVudCA9IFwiXFx1MjAyNlwiO1xuICAgICAgb24oRVZFTlRfQVVUT1BMQVlfUExBWSwgYXBwbHkoZGlzYWJsZSwgdHJ1ZSkpO1xuICAgICAgb24oRVZFTlRfQVVUT1BMQVlfUEFVU0UsIGFwcGx5KGRpc2FibGUsIGZhbHNlKSk7XG4gICAgICBvbihbRVZFTlRfTU9WRUQsIEVWRU5UX1NDUk9MTEVEXSwgYXBwbHkodG9nZ2xlLCB0cnVlKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZShhY3RpdmUpIHtcbiAgICBzZXRBdHRyaWJ1dGUodHJhY2ssIEFSSUFfQlVTWSwgYWN0aXZlKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBhcHBlbmQodHJhY2ssIHNyKTtcbiAgICAgIGludGVydmFsLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZShzcik7XG4gICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICByZW1vdmVBdHRyaWJ1dGUodHJhY2ssIFtBUklBX0xJVkUsIEFSSUFfQVRPTUlDLCBBUklBX0JVU1ldKTtcbiAgICByZW1vdmUoc3IpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGUoZGlzYWJsZWQpIHtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgc2V0QXR0cmlidXRlKHRyYWNrLCBBUklBX0xJVkUsIGRpc2FibGVkID8gXCJvZmZcIiA6IFwicG9saXRlXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1vdW50LFxuICAgIGRpc2FibGUsXG4gICAgZGVzdHJveVxuICB9O1xufVxudmFyIENvbXBvbmVudENvbnN0cnVjdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBNZWRpYSxcbiAgRGlyZWN0aW9uLFxuICBFbGVtZW50cyxcbiAgU2xpZGVzLFxuICBMYXlvdXQsXG4gIENsb25lcyxcbiAgTW92ZSxcbiAgQ29udHJvbGxlcixcbiAgQXJyb3dzLFxuICBBdXRvcGxheSxcbiAgQ292ZXIsXG4gIFNjcm9sbCxcbiAgRHJhZyxcbiAgS2V5Ym9hcmQsXG4gIExhenlMb2FkLFxuICBQYWdpbmF0aW9uLFxuICBTeW5jLFxuICBXaGVlbCxcbiAgTGl2ZVxufSk7XG52YXIgSTE4TiA9IHtcbiAgcHJldjogXCJQcmV2aW91cyBzbGlkZVwiLFxuICBuZXh0OiBcIk5leHQgc2xpZGVcIixcbiAgZmlyc3Q6IFwiR28gdG8gZmlyc3Qgc2xpZGVcIixcbiAgbGFzdDogXCJHbyB0byBsYXN0IHNsaWRlXCIsXG4gIHNsaWRlWDogXCJHbyB0byBzbGlkZSAlc1wiLFxuICBwYWdlWDogXCJHbyB0byBwYWdlICVzXCIsXG4gIHBsYXk6IFwiU3RhcnQgYXV0b3BsYXlcIixcbiAgcGF1c2U6IFwiUGF1c2UgYXV0b3BsYXlcIixcbiAgY2Fyb3VzZWw6IFwiY2Fyb3VzZWxcIixcbiAgc2xpZGU6IFwic2xpZGVcIixcbiAgc2VsZWN0OiBcIlNlbGVjdCBhIHNsaWRlIHRvIHNob3dcIixcbiAgc2xpZGVMYWJlbDogXCIlcyBvZiAlc1wiXG59O1xudmFyIERFRkFVTFRTID0ge1xuICB0eXBlOiBcInNsaWRlXCIsXG4gIHJvbGU6IFwicmVnaW9uXCIsXG4gIHNwZWVkOiA0MDAsXG4gIHBlclBhZ2U6IDEsXG4gIGNsb25lU3RhdHVzOiB0cnVlLFxuICBhcnJvd3M6IHRydWUsXG4gIHBhZ2luYXRpb246IHRydWUsXG4gIHBhZ2luYXRpb25LZXlib2FyZDogdHJ1ZSxcbiAgaW50ZXJ2YWw6IDVlMyxcbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICBwYXVzZU9uRm9jdXM6IHRydWUsXG4gIHJlc2V0UHJvZ3Jlc3M6IHRydWUsXG4gIGVhc2luZzogXCJjdWJpYy1iZXppZXIoMC4yNSwgMSwgMC41LCAxKVwiLFxuICBkcmFnOiB0cnVlLFxuICBkaXJlY3Rpb246IFwibHRyXCIsXG4gIHRyaW1TcGFjZTogdHJ1ZSxcbiAgZm9jdXNhYmxlTm9kZXM6IFwiYSwgYnV0dG9uLCB0ZXh0YXJlYSwgaW5wdXQsIHNlbGVjdCwgaWZyYW1lXCIsXG4gIGxpdmU6IHRydWUsXG4gIGNsYXNzZXM6IENMQVNTRVMsXG4gIGkxOG46IEkxOE4sXG4gIHJlZHVjZWRNb3Rpb246IHtcbiAgICBzcGVlZDogMCxcbiAgICByZXdpbmRTcGVlZDogMCxcbiAgICBhdXRvcGxheTogXCJwYXVzZVwiXG4gIH1cbn07XG5mdW5jdGlvbiBGYWRlKFNwbGlkZTIyLCBDb21wb25lbnRzMiwgb3B0aW9ucykge1xuICB2YXIgU2xpZGVzMiA9IENvbXBvbmVudHMyLlNsaWRlcztcbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLm9uKFtFVkVOVF9NT1VOVEVELCBFVkVOVF9SRUZSRVNIXSwgaW5pdCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBTbGlkZXMyLmZvckVhY2goZnVuY3Rpb24oU2xpZGUyKSB7XG4gICAgICBTbGlkZTIuc3R5bGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVYKC1cIiArIDEwMCAqIFNsaWRlMi5pbmRleCArIFwiJSlcIik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoaW5kZXgsIGRvbmUpIHtcbiAgICBTbGlkZXMyLnN0eWxlKFwidHJhbnNpdGlvblwiLCBcIm9wYWNpdHkgXCIgKyBvcHRpb25zLnNwZWVkICsgXCJtcyBcIiArIG9wdGlvbnMuZWFzaW5nKTtcbiAgICBuZXh0VGljayhkb25lKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1vdW50LFxuICAgIHN0YXJ0LFxuICAgIGNhbmNlbDogbm9vcFxuICB9O1xufVxuZnVuY3Rpb24gU2xpZGUoU3BsaWRlMjIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIHZhciBNb3ZlMiA9IENvbXBvbmVudHMyLk1vdmUsIENvbnRyb2xsZXIyID0gQ29tcG9uZW50czIuQ29udHJvbGxlciwgU2Nyb2xsMiA9IENvbXBvbmVudHMyLlNjcm9sbDtcbiAgdmFyIGxpc3QgPSBDb21wb25lbnRzMi5FbGVtZW50cy5saXN0O1xuICB2YXIgdHJhbnNpdGlvbiA9IGFwcGx5KHN0eWxlLCBsaXN0LCBcInRyYW5zaXRpb25cIik7XG4gIHZhciBlbmRDYWxsYmFjaztcbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgRXZlbnRJbnRlcmZhY2UoU3BsaWRlMjIpLmJpbmQobGlzdCwgXCJ0cmFuc2l0aW9uZW5kXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gbGlzdCAmJiBlbmRDYWxsYmFjaykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgZW5kQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydChpbmRleCwgZG9uZSkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IE1vdmUyLnRvUG9zaXRpb24oaW5kZXgsIHRydWUpO1xuICAgIHZhciBwb3NpdGlvbiA9IE1vdmUyLmdldFBvc2l0aW9uKCk7XG4gICAgdmFyIHNwZWVkID0gZ2V0U3BlZWQoaW5kZXgpO1xuICAgIGlmIChhYnMoZGVzdGluYXRpb24gLSBwb3NpdGlvbikgPj0gMSAmJiBzcGVlZCA+PSAxKSB7XG4gICAgICBpZiAob3B0aW9ucy51c2VTY3JvbGwpIHtcbiAgICAgICAgU2Nyb2xsMi5zY3JvbGwoZGVzdGluYXRpb24sIHNwZWVkLCBmYWxzZSwgZG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uKFwidHJhbnNmb3JtIFwiICsgc3BlZWQgKyBcIm1zIFwiICsgb3B0aW9ucy5lYXNpbmcpO1xuICAgICAgICBNb3ZlMi50cmFuc2xhdGUoZGVzdGluYXRpb24sIHRydWUpO1xuICAgICAgICBlbmRDYWxsYmFjayA9IGRvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE1vdmUyLmp1bXAoaW5kZXgpO1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgdHJhbnNpdGlvbihcIlwiKTtcbiAgICBTY3JvbGwyLmNhbmNlbCgpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNwZWVkKGluZGV4KSB7XG4gICAgdmFyIHJld2luZFNwZWVkID0gb3B0aW9ucy5yZXdpbmRTcGVlZDtcbiAgICBpZiAoU3BsaWRlMjIuaXMoU0xJREUpICYmIHJld2luZFNwZWVkKSB7XG4gICAgICB2YXIgcHJldiA9IENvbnRyb2xsZXIyLmdldEluZGV4KHRydWUpO1xuICAgICAgdmFyIGVuZCA9IENvbnRyb2xsZXIyLmdldEVuZCgpO1xuICAgICAgaWYgKHByZXYgPT09IDAgJiYgaW5kZXggPj0gZW5kIHx8IHByZXYgPj0gZW5kICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZXdpbmRTcGVlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuc3BlZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb3VudCxcbiAgICBzdGFydCxcbiAgICBjYW5jZWxcbiAgfTtcbn1cbnZhciBfU3BsaWRlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBfU3BsaWRlMih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmV2ZW50ID0gRXZlbnRJbnRlcmZhY2UoKTtcbiAgICB0aGlzLkNvbXBvbmVudHMgPSB7fTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUoQ1JFQVRFRCk7XG4gICAgdGhpcy5zcGxpZGVzID0gW107XG4gICAgdGhpcy5fbyA9IHt9O1xuICAgIHRoaXMuX0UgPSB7fTtcbiAgICB2YXIgcm9vdCA9IGlzU3RyaW5nKHRhcmdldCkgPyBxdWVyeShkb2N1bWVudCwgdGFyZ2V0KSA6IHRhcmdldDtcbiAgICBhc3NlcnQocm9vdCwgcm9vdCArIFwiIGlzIGludmFsaWQuXCIpO1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgb3B0aW9ucyA9IG1lcmdlKHtcbiAgICAgIGxhYmVsOiBnZXRBdHRyaWJ1dGUocm9vdCwgQVJJQV9MQUJFTCkgfHwgXCJcIixcbiAgICAgIGxhYmVsbGVkYnk6IGdldEF0dHJpYnV0ZShyb290LCBBUklBX0xBQkVMTEVEQlkpIHx8IFwiXCJcbiAgICB9LCBERUZBVUxUUywgX1NwbGlkZTIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuICAgIHRyeSB7XG4gICAgICBtZXJnZShvcHRpb25zLCBKU09OLnBhcnNlKGdldEF0dHJpYnV0ZShyb290LCBEQVRBX0FUVFJJQlVURSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsIFwiSW52YWxpZCBKU09OXCIpO1xuICAgIH1cbiAgICB0aGlzLl9vID0gT2JqZWN0LmNyZWF0ZShtZXJnZSh7fSwgb3B0aW9ucykpO1xuICB9XG4gIHZhciBfcHJvdG8gPSBfU3BsaWRlMi5wcm90b3R5cGU7XG4gIF9wcm90by5tb3VudCA9IGZ1bmN0aW9uIG1vdW50KEV4dGVuc2lvbnMsIFRyYW5zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUsIENvbXBvbmVudHMyID0gdGhpcy5Db21wb25lbnRzO1xuICAgIGFzc2VydChzdGF0ZS5pcyhbQ1JFQVRFRCwgREVTVFJPWUVEXSksIFwiQWxyZWFkeSBtb3VudGVkIVwiKTtcbiAgICBzdGF0ZS5zZXQoQ1JFQVRFRCk7XG4gICAgdGhpcy5fQyA9IENvbXBvbmVudHMyO1xuICAgIHRoaXMuX1QgPSBUcmFuc2l0aW9uIHx8IHRoaXMuX1QgfHwgKHRoaXMuaXMoRkFERSkgPyBGYWRlIDogU2xpZGUpO1xuICAgIHRoaXMuX0UgPSBFeHRlbnNpb25zIHx8IHRoaXMuX0U7XG4gICAgdmFyIENvbnN0cnVjdG9ycyA9IGFzc2lnbih7fSwgQ29tcG9uZW50Q29uc3RydWN0b3JzLCB0aGlzLl9FLCB7XG4gICAgICBUcmFuc2l0aW9uOiB0aGlzLl9UXG4gICAgfSk7XG4gICAgZm9yT3duKENvbnN0cnVjdG9ycywgZnVuY3Rpb24oQ29tcG9uZW50LCBrZXkpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBDb21wb25lbnQoX3RoaXMsIENvbXBvbmVudHMyLCBfdGhpcy5fbyk7XG4gICAgICBDb21wb25lbnRzMltrZXldID0gY29tcG9uZW50O1xuICAgICAgY29tcG9uZW50LnNldHVwICYmIGNvbXBvbmVudC5zZXR1cCgpO1xuICAgIH0pO1xuICAgIGZvck93bihDb21wb25lbnRzMiwgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICBjb21wb25lbnQubW91bnQgJiYgY29tcG9uZW50Lm1vdW50KCk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KEVWRU5UX01PVU5URUQpO1xuICAgIGFkZENsYXNzKHRoaXMucm9vdCwgQ0xBU1NfSU5JVElBTElaRUQpO1xuICAgIHN0YXRlLnNldChJRExFKTtcbiAgICB0aGlzLmVtaXQoRVZFTlRfUkVBRFkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoc3BsaWRlKSB7XG4gICAgdGhpcy5zcGxpZGVzLnB1c2goe1xuICAgICAgc3BsaWRlXG4gICAgfSk7XG4gICAgc3BsaWRlLnNwbGlkZXMucHVzaCh7XG4gICAgICBzcGxpZGU6IHRoaXMsXG4gICAgICBpc1BhcmVudDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnN0YXRlLmlzKElETEUpKSB7XG4gICAgICB0aGlzLl9DLlN5bmMucmVtb3VudCgpO1xuICAgICAgc3BsaWRlLkNvbXBvbmVudHMuU3luYy5yZW1vdW50KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uZ28gPSBmdW5jdGlvbiBnbyhjb250cm9sKSB7XG4gICAgdGhpcy5fQy5Db250cm9sbGVyLmdvKGNvbnRyb2wpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudHMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ldmVudC5vbihldmVudHMsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudHMpIHtcbiAgICB0aGlzLmV2ZW50Lm9mZihldmVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMkZXZlbnQ7XG4gICAgKF90aGlzJGV2ZW50ID0gdGhpcy5ldmVudCkuZW1pdC5hcHBseShfdGhpcyRldmVudCwgW2V2ZW50XS5jb25jYXQoc2xpY2UoYXJndW1lbnRzLCAxKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHNsaWRlcywgaW5kZXgpIHtcbiAgICB0aGlzLl9DLlNsaWRlcy5hZGQoc2xpZGVzLCBpbmRleCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUyKG1hdGNoZXIpIHtcbiAgICB0aGlzLl9DLlNsaWRlcy5yZW1vdmUobWF0Y2hlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5pcyA9IGZ1bmN0aW9uIGlzKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5fby50eXBlID09PSB0eXBlO1xuICB9O1xuICBfcHJvdG8ucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgdGhpcy5lbWl0KEVWRU5UX1JFRlJFU0gpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koY29tcGxldGVseSkge1xuICAgIGlmIChjb21wbGV0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbXBsZXRlbHkgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50LCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmlzKENSRUFURUQpKSB7XG4gICAgICBFdmVudEludGVyZmFjZSh0aGlzKS5vbihFVkVOVF9SRUFEWSwgdGhpcy5kZXN0cm95LmJpbmQodGhpcywgY29tcGxldGVseSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPd24odGhpcy5fQywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5kZXN0cm95ICYmIGNvbXBvbmVudC5kZXN0cm95KGNvbXBsZXRlbHkpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBldmVudC5lbWl0KEVWRU5UX0RFU1RST1kpO1xuICAgICAgZXZlbnQuZGVzdHJveSgpO1xuICAgICAgY29tcGxldGVseSAmJiBlbXB0eSh0aGlzLnNwbGlkZXMpO1xuICAgICAgc3RhdGUuc2V0KERFU1RST1lFRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfY3JlYXRlQ2xhc3MoX1NwbGlkZTIsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgdGhpcy5fQy5NZWRpYS5zZXQob3B0aW9ucywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX0MuU2xpZGVzLmdldExlbmd0aCh0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5kZXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9DLkNvbnRyb2xsZXIuZ2V0SW5kZXgoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIF9TcGxpZGUyO1xufSgpO1xudmFyIFNwbGlkZSA9IF9TcGxpZGU7XG5TcGxpZGUuZGVmYXVsdHMgPSB7fTtcblNwbGlkZS5TVEFURVMgPSBTVEFURVM7XG5cbi8vIHNyYy9qcy9jb21wb25lbnRzL1NwbGlkZS9TcGxpZGUudHN4XG5pbXBvcnQgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvanMvY29uc3RhbnRzL2V2ZW50cy50c1xudmFyIEVWRU5UUyA9IFtcbiAgW0VWRU5UX01PVU5URUQsIFwib25Nb3VudGVkXCJdLFxuICBbRVZFTlRfUkVBRFksIFwib25SZWFkeVwiXSxcbiAgW0VWRU5UX01PVkUsIFwib25Nb3ZlXCJdLFxuICBbRVZFTlRfTU9WRUQsIFwib25Nb3ZlZFwiXSxcbiAgW0VWRU5UX0NMSUNLLCBcIm9uQ2xpY2tcIl0sXG4gIFtFVkVOVF9BQ1RJVkUsIFwib25BY3RpdmVcIl0sXG4gIFtFVkVOVF9JTkFDVElWRSwgXCJvbkluYWN0aXZlXCJdLFxuICBbRVZFTlRfVklTSUJMRSwgXCJvblZpc2libGVcIl0sXG4gIFtFVkVOVF9ISURERU4sIFwib25IaWRkZW5cIl0sXG4gIFtFVkVOVF9SRUZSRVNILCBcIm9uUmVmcmVzaFwiXSxcbiAgW0VWRU5UX1VQREFURUQsIFwib25VcGRhdGVkXCJdLFxuICBbRVZFTlRfUkVTSVpFLCBcIm9uUmVzaXplXCJdLFxuICBbRVZFTlRfUkVTSVpFRCwgXCJvblJlc2l6ZWRcIl0sXG4gIFtFVkVOVF9EUkFHLCBcIm9uRHJhZ1wiXSxcbiAgW0VWRU5UX0RSQUdHSU5HLCBcIm9uRHJhZ2dpbmdcIl0sXG4gIFtFVkVOVF9EUkFHR0VELCBcIm9uRHJhZ2dlZFwiXSxcbiAgW0VWRU5UX1NDUk9MTCwgXCJvblNjcm9sbFwiXSxcbiAgW0VWRU5UX1NDUk9MTEVELCBcIm9uU2Nyb2xsZWRcIl0sXG4gIFtFVkVOVF9ERVNUUk9ZLCBcIm9uRGVzdHJveVwiXSxcbiAgW0VWRU5UX0FSUk9XU19NT1VOVEVELCBcIm9uQXJyb3dzTW91bnRlZFwiXSxcbiAgW0VWRU5UX0FSUk9XU19VUERBVEVELCBcIm9uQXJyb3dzVXBkYXRlZFwiXSxcbiAgW0VWRU5UX1BBR0lOQVRJT05fTU9VTlRFRCwgXCJvblBhZ2luYXRpb25Nb3VudGVkXCJdLFxuICBbRVZFTlRfUEFHSU5BVElPTl9VUERBVEVELCBcIm9uUGFnaW5hdGlvblVwZGF0ZWRcIl0sXG4gIFtFVkVOVF9OQVZJR0FUSU9OX01PVU5URUQsIFwib25OYXZpZ2F0aW9uTW91bnRlZFwiXSxcbiAgW0VWRU5UX0FVVE9QTEFZX1BMQVksIFwib25BdXRvcGxheVBsYXlcIl0sXG4gIFtFVkVOVF9BVVRPUExBWV9QTEFZSU5HLCBcIm9uQXV0b3BsYXlQbGF5aW5nXCJdLFxuICBbRVZFTlRfQVVUT1BMQVlfUEFVU0UsIFwib25BdXRvcGxheVBhdXNlXCJdLFxuICBbRVZFTlRfTEFaWUxPQURfTE9BREVELCBcIm9uTGF6eUxvYWRMb2FkZWRcIl1cbl07XG5cbi8vIHNyYy9qcy91dGlscy9jbGFzc05hbWVzL2NsYXNzTmFtZXMudHNcbmZ1bmN0aW9uIGNsYXNzTmFtZXMoLi4uY2xhc3Nlcykge1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG59XG5cbi8vIHNyYy9qcy91dGlscy9pc09iamVjdC9pc09iamVjdC50c1xuZnVuY3Rpb24gaXNPYmplY3QyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgIT09IG51bGwgJiYgdHlwZW9mIHN1YmplY3QgPT09IFwib2JqZWN0XCI7XG59XG5cbi8vIHNyYy9qcy91dGlscy9pc0VxdWFsRGVlcC9pc0VxdWFsRGVlcC50c1xuZnVuY3Rpb24gaXNFcXVhbERlZXAoc3ViamVjdDEsIHN1YmplY3QyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YmplY3QxKSAmJiBBcnJheS5pc0FycmF5KHN1YmplY3QyKSkge1xuICAgIHJldHVybiBzdWJqZWN0MS5sZW5ndGggPT09IHN1YmplY3QyLmxlbmd0aCAmJiAhc3ViamVjdDEuc29tZSgoZWxtLCBpbmRleCkgPT4gIWlzRXF1YWxEZWVwKGVsbSwgc3ViamVjdDJbaW5kZXhdKSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0MihzdWJqZWN0MSkgJiYgaXNPYmplY3QyKHN1YmplY3QyKSkge1xuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMoc3ViamVjdDEpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMoc3ViamVjdDIpO1xuICAgIHJldHVybiBrZXlzMS5sZW5ndGggPT09IGtleXMyLmxlbmd0aCAmJiAha2V5czEuc29tZSgoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdWJqZWN0Miwga2V5KSB8fCAhaXNFcXVhbERlZXAoc3ViamVjdDFba2V5XSwgc3ViamVjdDJba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN1YmplY3QxID09PSBzdWJqZWN0Mjtcbn1cblxuLy8gc3JjL2pzL3V0aWxzL2lzRXF1YWxTaGFsbG93L2lzRXF1YWxTaGFsbG93LnRzXG5mdW5jdGlvbiBpc0VxdWFsU2hhbGxvdyhhcnJheTEsIGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkxLmxlbmd0aCA9PT0gYXJyYXkyLmxlbmd0aCAmJiAhYXJyYXkxLnNvbWUoKGVsbSwgaW5kZXgpID0+IGVsbSAhPT0gYXJyYXkyW2luZGV4XSk7XG59XG5cbi8vIHNyYy9qcy91dGlscy9mb3JPd24vZm9yT3duLnRzXG5mdW5jdGlvbiBmb3JPd24yKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgaWYgKG9iamVjdCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgIT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKG9iamVjdFtrZXldLCBrZXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8vIHNyYy9qcy91dGlscy9tZXJnZS9tZXJnZS50c1xuZnVuY3Rpb24gbWVyZ2UyKG9iamVjdCwgc291cmNlKSB7XG4gIGNvbnN0IG1lcmdlZCA9IG9iamVjdDtcbiAgZm9yT3duMihzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBtZXJnZWRba2V5XSA9IHZhbHVlLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdDIodmFsdWUpKSB7XG4gICAgICBtZXJnZWRba2V5XSA9IG1lcmdlMihpc09iamVjdDIobWVyZ2VkW2tleV0pID8gbWVyZ2VkW2tleV0gOiB7fSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbi8vIHNyYy9qcy9jb21wb25lbnRzL1NwbGlkZVRyYWNrL1NwbGlkZVRyYWNrLnRzeFxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIFNwbGlkZVRyYWNrID0gKHsgY2hpbGRyZW46IGNoaWxkcmVuMiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwic3BsaWRlX190cmFja1wiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xuICAgIGNsYXNzTmFtZTogXCJzcGxpZGVfX2xpc3RcIlxuICB9LCBjaGlsZHJlbjIpKTtcbn07XG5cbi8vIHNyYy9qcy9jb21wb25lbnRzL1NwbGlkZS9TcGxpZGUudHN4XG52YXIgU3BsaWRlMiA9IGNsYXNzIGV4dGVuZHMgUmVhY3QyLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zcGxpZGVSZWYgPSBSZWFjdDIuY3JlYXRlUmVmKCk7XG4gICAgdGhpcy5zbGlkZXMgPSBbXTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIGV4dGVuc2lvbnMsIHRyYW5zaXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzLnNwbGlkZVJlZjtcbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgdGhpcy5zcGxpZGUgPSBuZXcgU3BsaWRlKGN1cnJlbnQsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iaW5kKHRoaXMuc3BsaWRlKTtcbiAgICAgIHRoaXMuc3BsaWRlLm1vdW50KGV4dGVuc2lvbnMsIHRyYW5zaXRpb24pO1xuICAgICAgdGhpcy5vcHRpb25zID0gbWVyZ2UyKHt9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHRoaXMuc2xpZGVzID0gdGhpcy5nZXRTbGlkZXMoKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3BsaWRlKSB7XG4gICAgICB0aGlzLnNwbGlkZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLnNwbGlkZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuc2xpZGVzLmxlbmd0aCA9IDA7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5zcGxpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvcHRpb25zICYmICFpc0VxdWFsRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpKSB7XG4gICAgICB0aGlzLnNwbGlkZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlMih7fSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NsaWRlcyA9IHRoaXMuZ2V0U2xpZGVzKCk7XG4gICAgaWYgKCFpc0VxdWFsU2hhbGxvdyh0aGlzLnNsaWRlcywgbmV3U2xpZGVzKSkge1xuICAgICAgdGhpcy5zcGxpZGUucmVmcmVzaCgpO1xuICAgICAgdGhpcy5zbGlkZXMgPSBuZXdTbGlkZXM7XG4gICAgfVxuICB9XG4gIHN5bmMoc3BsaWRlKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuc3BsaWRlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3luYyhzcGxpZGUpO1xuICB9XG4gIGdvKGNvbnRyb2wpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5zcGxpZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nbyhjb250cm9sKTtcbiAgfVxuICBnZXRTbGlkZXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLnNwbGlkZSkge1xuICAgICAgY29uc3QgY2hpbGRyZW4yID0gKF9hID0gdGhpcy5zcGxpZGUuQ29tcG9uZW50cy5FbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxpc3QuY2hpbGRyZW47XG4gICAgICByZXR1cm4gY2hpbGRyZW4yICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNoaWxkcmVuMikgfHwgW107XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBiaW5kKHNwbGlkZSkge1xuICAgIEVWRU5UUy5mb3JFYWNoKChbZXZlbnQsIG5hbWVdKSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wcm9wc1tuYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNwbGlkZS5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBoYW5kbGVyKHNwbGlkZSwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9taXQocHJvcHMsIGtleXMpIHtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywga2V5KSkge1xuICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCB0YWc6IFJvb3QgPSBcImRpdlwiLCBoYXNUcmFjayA9IHRydWUsIGNoaWxkcmVuOiBjaGlsZHJlbjIsIC4uLnByb3BzIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm9vdCwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwic3BsaWRlXCIsIGNsYXNzTmFtZSksXG4gICAgICByZWY6IHRoaXMuc3BsaWRlUmVmLFxuICAgICAgLi4udGhpcy5vbWl0KHByb3BzLCBbXCJvcHRpb25zXCIsIC4uLkVWRU5UUy5tYXAoKGV2ZW50KSA9PiBldmVudFsxXSldKVxuICAgIH0sIGhhc1RyYWNrID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFNwbGlkZVRyYWNrLCBudWxsLCBjaGlsZHJlbjIpIDogY2hpbGRyZW4yKTtcbiAgfVxufTtcblxuLy8gc3JjL2pzL2NvbXBvbmVudHMvU3BsaWRlU2xpZGUvU3BsaWRlU2xpZGUudHN4XG5pbXBvcnQgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xudmFyIFNwbGlkZVNsaWRlID0gKHsgY2hpbGRyZW46IGNoaWxkcmVuMiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKFwic3BsaWRlX19zbGlkZVwiLCBjbGFzc05hbWUpLFxuICAgIC4uLnByb3BzXG4gIH0sIGNoaWxkcmVuMik7XG59O1xuZXhwb3J0IHtcbiAgU3BsaWRlMiBhcyBTcGxpZGUsXG4gIFNwbGlkZVNsaWRlLFxuICBTcGxpZGVUcmFja1xufTtcbi8qIVxuICogU3BsaWRlLmpzXG4gKiBWZXJzaW9uICA6IDQuMS4zXG4gKiBMaWNlbnNlICA6IE1JVFxuICogQ29weXJpZ2h0OiAyMDIyIE5hb3Rvc2hpIEZ1aml0YVxuICovXG4iXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIk1FRElBX1BSRUZFUlNfUkVEVUNFRF9NT1RJT04iLCJDUkVBVEVEIiwiTU9VTlRFRCIsIklETEUiLCJNT1ZJTkciLCJTQ1JPTExJTkciLCJEUkFHR0lORyIsIkRFU1RST1lFRCIsIlNUQVRFUyIsImVtcHR5IiwiYXJyYXkiLCJzbGljZSIsImFycmF5TGlrZSIsInN0YXJ0IiwiZW5kIiwiQXJyYXkiLCJjYWxsIiwiYXBwbHkiLCJmdW5jIiwiYmluZCIsImNvbmNhdCIsImFyZ3VtZW50cyIsIm5leHRUaWNrIiwic2V0VGltZW91dCIsIm5vb3AiLCJub29wMiIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInR5cGVPZiIsInR5cGUiLCJzdWJqZWN0IiwiaXNPYmplY3QiLCJpc051bGwiLCJpc0FycmF5IiwiaXNGdW5jdGlvbiIsImlzU3RyaW5nIiwiaXNVbmRlZmluZWQiLCJpc0hUTUxFbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiSFRNTEVsZW1lbnQiLCJlIiwidG9BcnJheSIsInZhbHVlIiwiZm9yRWFjaCIsInZhbHVlcyIsIml0ZXJhdGVlIiwiaW5jbHVkZXMiLCJpbmRleE9mIiwicHVzaCIsIml0ZW1zIiwidG9nZ2xlQ2xhc3MiLCJlbG0iLCJjbGFzc2VzIiwiYWRkIiwibmFtZSIsImNsYXNzTGlzdCIsImFkZENsYXNzIiwic3BsaXQiLCJhcHBlbmQiLCJwYXJlbnQiLCJjaGlsZHJlbjIiLCJhcHBlbmRDaGlsZCIsImJlZm9yZSIsIm5vZGVzIiwicmVmIiwibm9kZSIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJtYXRjaGVzIiwic2VsZWN0b3IiLCJjaGlsZHJlbiIsImZpbHRlciIsImNoaWxkMiIsImNoaWxkIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJvd25LZXlzIiwia2V5cyIsImZvck93biIsIm9iamVjdCIsInJpZ2h0IiwicmV2ZXJzZSIsImFzc2lnbiIsInNvdXJjZSIsIm1lcmdlIiwib21pdCIsInJlbW92ZUF0dHJpYnV0ZSIsImVsbXMiLCJhdHRycyIsImF0dHIiLCJzZXRBdHRyaWJ1dGUiLCJ2YWx1ZTIiLCJTdHJpbmciLCJjcmVhdGUiLCJ0YWciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInByb3AiLCJnZXRDb21wdXRlZFN0eWxlIiwiZGlzcGxheSIsImRpc3BsYXkyIiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwiZ2V0QXR0cmlidXRlIiwiaGFzQ2xhc3MiLCJjbGFzc05hbWUiLCJjb250YWlucyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZW1vdmUiLCJyZW1vdmVDaGlsZCIsInBhcnNlSHRtbCIsImh0bWwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwicHJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicXVlcnkiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlBbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlQ2xhc3MiLCJ0aW1lT2YiLCJ0aW1lU3RhbXAiLCJ1bml0IiwiUFJPSkVDVF9DT0RFIiwiREFUQV9BVFRSSUJVVEUiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJtaW4iLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJjZWlsIiwiYWJzIiwiYXBwcm94aW1hdGVseUVxdWFsIiwieCIsInkiLCJlcHNpbG9uIiwiYmV0d2VlbiIsIm51bWJlciIsImV4Y2x1c2l2ZSIsIm1pbmltdW0iLCJtYXhpbXVtIiwiY2xhbXAiLCJzaWduIiwiZm9ybWF0Iiwic3RyaW5nIiwicmVwbGFjZW1lbnRzIiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlIiwicGFkIiwiaWRzIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJFdmVudEJpbmRlciIsImxpc3RlbmVycyIsInRhcmdldHMiLCJldmVudHMiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJmb3JFYWNoRXZlbnQiLCJldmVudCIsIm5hbWVzcGFjZSIsImlzRXZlbnRUYXJnZXQiLCJyZW1vdmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1bmJpbmQiLCJsaXN0ZW5lciIsImRpc3BhdGNoIiwiZGV0YWlsIiwiYnViYmxlcyIsIkN1c3RvbUV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnRzMiIsImV2ZW50TlMiLCJmcmFnbWVudCIsImRlc3Ryb3kiLCJkYXRhIiwiRVZFTlRfTU9VTlRFRCIsIkVWRU5UX1JFQURZIiwiRVZFTlRfTU9WRSIsIkVWRU5UX01PVkVEIiwiRVZFTlRfQ0xJQ0siLCJFVkVOVF9BQ1RJVkUiLCJFVkVOVF9JTkFDVElWRSIsIkVWRU5UX1ZJU0lCTEUiLCJFVkVOVF9ISURERU4iLCJFVkVOVF9SRUZSRVNIIiwiRVZFTlRfVVBEQVRFRCIsIkVWRU5UX1JFU0laRSIsIkVWRU5UX1JFU0laRUQiLCJFVkVOVF9EUkFHIiwiRVZFTlRfRFJBR0dJTkciLCJFVkVOVF9EUkFHR0VEIiwiRVZFTlRfU0NST0xMIiwiRVZFTlRfU0NST0xMRUQiLCJFVkVOVF9PVkVSRkxPVyIsIkVWRU5UX0RFU1RST1kiLCJFVkVOVF9BUlJPV1NfTU9VTlRFRCIsIkVWRU5UX0FSUk9XU19VUERBVEVEIiwiRVZFTlRfUEFHSU5BVElPTl9NT1VOVEVEIiwiRVZFTlRfUEFHSU5BVElPTl9VUERBVEVEIiwiRVZFTlRfTkFWSUdBVElPTl9NT1VOVEVEIiwiRVZFTlRfQVVUT1BMQVlfUExBWSIsIkVWRU5UX0FVVE9QTEFZX1BMQVlJTkciLCJFVkVOVF9BVVRPUExBWV9QQVVTRSIsIkVWRU5UX0xBWllMT0FEX0xPQURFRCIsIkVWRU5UX1NMSURFX0tFWURPV04iLCJFVkVOVF9TSElGVEVEIiwiRVZFTlRfRU5EX0lOREVYX0NIQU5HRUQiLCJFdmVudEludGVyZmFjZSIsIlNwbGlkZTIyIiwiYnVzIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImJpbmRlciIsIm9uIiwiam9pbiIsImVtaXQiLCJvZmYiLCJSZXF1ZXN0SW50ZXJ2YWwiLCJpbnRlcnZhbCIsIm9uSW50ZXJ2YWwiLCJvblVwZGF0ZSIsImxpbWl0Iiwibm93IiwiRGF0ZSIsInN0YXJ0VGltZSIsInJhdGUiLCJpZCIsInBhdXNlZCIsImNvdW50IiwidXBkYXRlIiwicGF1c2UiLCJyZXN1bWUiLCJjYW5jZWwiLCJyZXdpbmQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNldCIsInRpbWUiLCJpc1BhdXNlZCIsIlN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic3RhdGUiLCJpcyIsInN0YXRlcyIsIlRocm90dGxlIiwiZHVyYXRpb24iLCJNZWRpYSIsIkNvbXBvbmVudHMyIiwiYnJlYWtwb2ludHMiLCJyZWR1Y2VkTW90aW9uIiwicXVlcmllcyIsInNldHVwIiwiaXNNaW4iLCJtZWRpYVF1ZXJ5Iiwic29ydCIsIm4iLCJtIiwicmVnaXN0ZXIiLCJjb21wbGV0ZWx5Iiwib3B0aW9uczIiLCJxdWVyeTIiLCJxdWVyeUxpc3QiLCJtYXRjaE1lZGlhIiwiZGVzdHJveWVkIiwiZGlyZWN0aW9uIiwibWVyZ2VkIiwicmVkdWNlIiwibWVyZ2VkMiIsImVudHJ5IiwibW91bnQiLCJyZWZyZXNoIiwiZW5hYmxlIiwib3B0cyIsImJhc2UiLCJub3RpZnkiLCJnZXRQcm90b3R5cGVPZiIsIkFSUk9XIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwiUlRMIiwiVFRCIiwiT1JJRU5UQVRJT05fTUFQIiwid2lkdGgiLCJsZWZ0IiwiWCIsIlkiLCJBcnJvd0xlZnQiLCJBcnJvd1JpZ2h0IiwiRGlyZWN0aW9uIiwicmVzb2x2ZSIsImF4aXNPbmx5IiwiaW5kZXgiLCJtYXRjaCIsIm9mZnNldCIsInRvTG93ZXJDYXNlIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJvcmllbnQiLCJST0xFIiwiVEFCX0lOREVYIiwiRElTQUJMRUQiLCJBUklBX1BSRUZJWCIsIkFSSUFfQ09OVFJPTFMiLCJBUklBX0NVUlJFTlQiLCJBUklBX1NFTEVDVEVEIiwiQVJJQV9MQUJFTCIsIkFSSUFfTEFCRUxMRURCWSIsIkFSSUFfSElEREVOIiwiQVJJQV9PUklFTlRBVElPTiIsIkFSSUFfUk9MRURFU0NSSVBUSU9OIiwiQVJJQV9MSVZFIiwiQVJJQV9CVVNZIiwiQVJJQV9BVE9NSUMiLCJBTExfQVRUUklCVVRFUyIsIkNMQVNTX1BSRUZJWCIsIlNUQVRVU19DTEFTU19QUkVGSVgiLCJDTEFTU19ST09UIiwiQ0xBU1NfVFJBQ0siLCJDTEFTU19MSVNUIiwiQ0xBU1NfU0xJREUiLCJDTEFTU19DTE9ORSIsIkNMQVNTX0NPTlRBSU5FUiIsIkNMQVNTX0FSUk9XUyIsIkNMQVNTX0FSUk9XIiwiQ0xBU1NfQVJST1dfUFJFViIsIkNMQVNTX0FSUk9XX05FWFQiLCJDTEFTU19QQUdJTkFUSU9OIiwiQ0xBU1NfUEFHSU5BVElPTl9QQUdFIiwiQ0xBU1NfUFJPR1JFU1MiLCJDTEFTU19QUk9HUkVTU19CQVIiLCJDTEFTU19UT0dHTEUiLCJDTEFTU19UT0dHTEVfUExBWSIsIkNMQVNTX1RPR0dMRV9QQVVTRSIsIkNMQVNTX1NQSU5ORVIiLCJDTEFTU19TUiIsIkNMQVNTX0lOSVRJQUxJWkVEIiwiQ0xBU1NfQUNUSVZFIiwiQ0xBU1NfUFJFViIsIkNMQVNTX05FWFQiLCJDTEFTU19WSVNJQkxFIiwiQ0xBU1NfTE9BRElORyIsIkNMQVNTX0ZPQ1VTX0lOIiwiQ0xBU1NfT1ZFUkZMT1ciLCJTVEFUVVNfQ0xBU1NFUyIsIkNMQVNTRVMiLCJzbGlkZSIsImNsb25lIiwiYXJyb3dzIiwiYXJyb3ciLCJwcmV2IiwibmV4dCIsInBhZ2luYXRpb24iLCJwYWdlIiwic3Bpbm5lciIsImNsb3Nlc3QiLCJmcm9tIiwibm9kZVR5cGUiLCJwYXJlbnRFbGVtZW50IiwiRlJJQ1RJT04iLCJMT0dfSU5URVJWQUwiLCJQT0lOVEVSX0RPV05fRVZFTlRTIiwiUE9JTlRFUl9NT1ZFX0VWRU5UUyIsIlBPSU5URVJfVVBfRVZFTlRTIiwiRWxlbWVudHMiLCJfRXZlbnRJbnRlcmZhY2UiLCJyb290IiwiaTE4biIsImVsZW1lbnRzIiwic2xpZGVzIiwicm9vdENsYXNzZXMiLCJ0cmFja0NsYXNzZXMiLCJ0cmFjayIsImxpc3QiLCJpc1VzaW5nS2V5IiwiY29sbGVjdCIsImluaXQiLCJjYXB0dXJlIiwiZ2V0Q2xhc3NlcyIsImxhYmVsIiwibGFiZWxsZWRieSIsImZpbmQiLCJiYXIiLCJ0b2dnbGUiLCJyb2xlIiwidGFnTmFtZSIsImNhcm91c2VsIiwiZHJhZyIsImlzTmF2aWdhdGlvbiIsIlNMSURFIiwiTE9PUCIsIkZBREUiLCJTbGlkZSQxIiwic2xpZGVJbmRleCIsIkNvbXBvbmVudHMiLCJ1cGRhdGVPbk1vdmUiLCJzbGlkZUZvY3VzIiwic3R5bGVzIiwiaXNDbG9uZSIsImNvbnRhaW5lciIsInNsaWRlTGFiZWwiLCJsaXN0ZW4iLCJzZWxmIiwiaW5pdE5hdmlnYXRpb24iLCJvbk1vdmUiLCJjb250cm9scyIsInNwbGlkZXMiLCJtYXAiLCJTbGlkZTIiLCJzcGxpZGUiLCJTbGlkZXMiLCJnZXRBdCIsInNsaWRlWCIsImN1cnIiLCJ1cGRhdGVBY3Rpdml0eSIsInVwZGF0ZVZpc2liaWxpdHkiLCJhY3RpdmUiLCJpc0FjdGl2ZSIsInZpc2libGUiLCJpc1Zpc2libGUiLCJoaWRkZW4iLCJmb2N1c2FibGVOb2RlcyIsImFjdGl2ZUVsZW1lbnQiLCJzdHlsZSQxIiwidXNlQ29udGFpbmVyIiwiY2xvbmVTdGF0dXMiLCJ0cmFja1JlY3QiLCJzbGlkZVJlY3QiLCJpc1dpdGhpbiIsImRpc3RhbmNlIiwiZGlmZiIsIl9FdmVudEludGVyZmFjZTIiLCJfQ29tcG9uZW50czIkRWxlbWVudHMiLCJTbGlkZXMyIiwiZm9yRWFjaCQxIiwiU2xpZGUxIiwiZ2V0IiwiZXhjbHVkZUNsb25lcyIsImdldEluIiwiQ29udHJvbGxlcjIiLCJDb250cm9sbGVyIiwidG9JbmRleCIsIm1heDIiLCJoYXNGb2N1cyIsInBlclBhZ2UiLCJvYnNlcnZlSW1hZ2VzIiwicmVtb3ZlJDEiLCJtYXRjaGVyIiwic3R5bGUyIiwiaW1hZ2VzIiwiaW1nIiwiZ2V0TGVuZ3RoIiwiaXNFbm91Z2giLCJMYXlvdXQiLCJfRXZlbnRJbnRlcmZhY2UzIiwiX0NvbXBvbmVudHMyJEVsZW1lbnRzMiIsInN0eWxlU2xpZGVzIiwidmVydGljYWwiLCJyb290UmVjdCIsIm92ZXJmbG93IiwicmVzaXplIiwiY3NzUGFkZGluZyIsImZvcmNlIiwibmV3UmVjdCIsImhlaWdodCIsImNzc1RyYWNrSGVpZ2h0IiwiZ2FwIiwiY3NzU2xpZGVXaWR0aCIsImNzc1NsaWRlSGVpZ2h0IiwiaXNPdmVyZmxvdyIsInBhZGRpbmciLCJjc3NIZWlnaHQiLCJoZWlnaHRSYXRpbyIsImF1dG9XaWR0aCIsImZpeGVkV2lkdGgiLCJjc3NTbGlkZVNpemUiLCJmaXhlZEhlaWdodCIsImF1dG9IZWlnaHQiLCJsaXN0U2l6ZSIsInNsaWRlU2l6ZSIsIndpdGhvdXRHYXAiLCJnZXRHYXAiLCJ0b3RhbFNpemUiLCJzbGlkZXJTaXplIiwicGFyc2VGbG9hdCIsImdldFBhZGRpbmciLCJNVUxUSVBMSUVSIiwiQ2xvbmVzIiwiRWxlbWVudHMyIiwiY2xvbmVzIiwiY2xvbmVDb3VudCIsInJlbW91bnQiLCJvYnNlcnZlIiwiY29tcHV0ZUNsb25lQ291bnQiLCJnZW5lcmF0ZSIsImlzSGVhZCIsImNsb25lRGVlcCIsImNsb25lTm9kZSIsImNsb25lczIiLCJmaXhlZFNpemUiLCJmaXhlZENvdW50IiwiTW92ZSIsIl9FdmVudEludGVyZmFjZTQiLCJfQ29tcG9uZW50czIkTGF5b3V0IiwiX0NvbXBvbmVudHMyJERpcmVjdGlvIiwiX0NvbXBvbmVudHMyJEVsZW1lbnRzMyIsIlRyYW5zaXRpb24iLCJyZXBvc2l0aW9uIiwiaXNCdXN5IiwiU2Nyb2xsIiwianVtcCIsIm1vdmUiLCJkZXN0IiwiY2FuU2hpZnQiLCJ0cmFuc2xhdGUiLCJzaGlmdCIsImdldFBvc2l0aW9uIiwidG9Qb3NpdGlvbiIsInBvc2l0aW9uIiwicHJldmVudExvb3AiLCJkZXN0aW5hdGlvbiIsImxvb3AiLCJleGNlZWRlZE1heCIsImdldEVuZCIsImV4Y2VlZGVkTWluIiwiYmFja3dhcmRzIiwiZXhjZXNzIiwiZ2V0TGltaXQiLCJzaXplIiwibWluRGlzdGFuY2UiLCJJbmZpbml0eSIsInRyaW1taW5nIiwidHJpbSIsInRyaW1TcGFjZSIsImZvY3VzMiIsInNoaWZ0ZWQiLCJleGNlZWRlZExpbWl0IiwiX0V2ZW50SW50ZXJmYWNlNSIsIk1vdmUyIiwiX0NvbXBvbmVudHMyJFNsaWRlcyIsIm9taXRFbmQiLCJpc0xvb3AiLCJpc1NsaWRlIiwiZ2V0TmV4dCIsImdldEFkamFjZW50IiwiZ2V0UHJldiIsImN1cnJJbmRleCIsImVuZEluZGV4IiwicHJldkluZGV4Iiwic2xpZGVDb3VudCIsInBlck1vdmUiLCJvblJlc2l6ZWQiLCJnbyIsImNvbnRyb2wiLCJhbGxvd1NhbWVJbmRleCIsInBhcnNlIiwic2V0SW5kZXgiLCJzY3JvbGwiLCJzbmFwIiwiX3JlZiIsImluZGljYXRvciIsImNvbXB1dGVEZXN0SW5kZXgiLCJzbmFwUGFnZSIsImNvbXB1dGVNb3ZhYmxlRGVzdEluZGV4IiwidG9QYWdlIiwidG9EZXN0IiwiY2xvc2VzdDIiLCJnZXRJbmRleCIsIndhaXRGb3JUcmFuc2l0aW9uIiwiWE1MX05BTUVfU1BBQ0UiLCJQQVRIIiwiU0laRSIsIkFycm93cyIsInBsYWNlaG9sZGVyIiwid3JhcHBlciIsImNyZWF0ZWQiLCJ3cmFwcGVyQ2xhc3NlcyIsImVuYWJsZWQiLCJjcmVhdGVBcnJvd3MiLCJjcmVhdGVBcnJvdyIsInByZXYyIiwiYXJyb3dQYXRoIiwibmV4dEluZGV4IiwicHJldkxhYmVsIiwibGFzdCIsIm5leHRMYWJlbCIsImZpcnN0IiwiZGlzYWJsZWQiLCJJTlRFUlZBTF9EQVRBX0FUVFJJQlVURSIsIkF1dG9wbGF5IiwiX0V2ZW50SW50ZXJmYWNlNiIsIm9uQW5pbWF0aW9uRnJhbWUiLCJfQ29tcG9uZW50czIkRWxlbWVudHM0IiwiYXV0b3BsYXkiLCJob3ZlcmVkIiwiZm9jdXNlZCIsInN0b3BwZWQiLCJwbGF5IiwicGF1c2VPbkhvdmVyIiwiYXV0b1RvZ2dsZSIsInBhdXNlT25Gb2N1cyIsInJlc2V0UHJvZ3Jlc3MiLCJzdG9wIiwiQ292ZXIiLCJfRXZlbnRJbnRlcmZhY2U3IiwiY292ZXIiLCJjb3ZlcjIiLCJzcmMiLCJCT1VOQ0VfRElGRl9USFJFU0hPTEQiLCJCT1VOQ0VfRFVSQVRJT04iLCJGUklDVElPTl9GQUNUT1IiLCJCQVNFX1ZFTE9DSVRZIiwiTUlOX0RVUkFUSU9OIiwiX0V2ZW50SW50ZXJmYWNlOCIsImZyaWN0aW9uIiwiY2xlYXIiLCJvblNjcm9sbGVkIiwibm9Db25zdHJhaW4iLCJub0Rpc3RhbmNlIiwib25FbmQiLCJ0byIsImVhc2luZyIsInQiLCJlYXNpbmdGdW5jIiwicG93IiwiU0NST0xMX0xJU1RFTkVSX09QVElPTlMiLCJwYXNzaXZlIiwiRHJhZyIsIl9FdmVudEludGVyZmFjZTkiLCJTY3JvbGwyIiwiX0NvbXBvbmVudHMyJERpcmVjdGlvMiIsImJhc2VQb3NpdGlvbiIsImJhc2VFdmVudCIsInByZXZCYXNlRXZlbnQiLCJpc0ZyZWUiLCJkcmFnZ2luZyIsImV4Y2VlZGVkIiwiY2xpY2tQcmV2ZW50ZWQiLCJvblBvaW50ZXJEb3duIiwib25DbGljayIsImRpc2FibGUiLCJpc1RvdWNoIiwiaXNUb3VjaEV2ZW50IiwiaXNEcmFnZ2FibGUiLCJidXR0b24iLCJvblBvaW50ZXJNb3ZlIiwib25Qb2ludGVyVXAiLCJzYXZlIiwiY2FuY2VsYWJsZSIsImNvbnN0cmFpbiIsImRpZmZDb29yZCIsImV4cGlyZWQiLCJkaWZmVGltZSIsImhhc0V4Y2VlZGVkIiwiaXNTbGlkZXJEaXJlY3Rpb24iLCJzaG91bGRTdGFydCIsInZlbG9jaXR5IiwiY29tcHV0ZVZlbG9jaXR5IiwiY29tcHV0ZURlc3RpbmF0aW9uIiwicmV3aW5kQnlEcmFnIiwidGhyZXNob2xkcyIsImRyYWdNaW5UaHJlc2hvbGQiLCJpc09iaiIsIm1vdXNlIiwidG91Y2giLCJmbGlja1Bvd2VyIiwiZmxpY2tNYXhQYWdlcyIsIm9ydGhvZ29uYWwiLCJjb29yZE9mIiwiZ2V0QmFzZUV2ZW50IiwiY2hhbmdlZFRvdWNoZXMiLCJ0YXJnZXQyIiwibm9EcmFnIiwiVG91Y2hFdmVudCIsImlzRHJhZ2dpbmciLCJOT1JNQUxJWkFUSU9OX01BUCIsIlNwYWNlYmFyIiwiUmlnaHQiLCJMZWZ0IiwiVXAiLCJEb3duIiwibm9ybWFsaXplS2V5IiwiS0VZQk9BUkRfRVZFTlQiLCJLZXlib2FyZCIsIl9FdmVudEludGVyZmFjZTEwIiwia2V5Ym9hcmQiLCJvbktleWRvd24iLCJfZGlzYWJsZWQiLCJTUkNfREFUQV9BVFRSSUJVVEUiLCJTUkNTRVRfREFUQV9BVFRSSUJVVEUiLCJJTUFHRV9TRUxFQ1RPUiIsIkxhenlMb2FkIiwiX0V2ZW50SW50ZXJmYWNlMTEiLCJpc1NlcXVlbnRpYWwiLCJsYXp5TG9hZCIsImVudHJpZXMiLCJsb2FkTmV4dCIsImNoZWNrIiwic3Jjc2V0IiwicHJlbG9hZFBhZ2VzIiwibG9hZCIsIm9uTG9hZCIsIlBhZ2luYXRpb24iLCJwYWdpbmF0aW9uQ2xhc3NlcyIsImNyZWF0ZVBhZ2luYXRpb24iLCJnZXREaXJlY3Rpb24iLCJzZWxlY3QiLCJsaSIsImNsYXNzIiwidGV4dCIsInBhZ2VYIiwicGFnaW5hdGlvbktleWJvYXJkIiwiZGlyIiwibmV4dFBhZ2UiLCJpdGVtIiwicGFnaW5hdGlvbkRpcmVjdGlvbiIsIl9idXR0b24iLCJUUklHR0VSX0tFWVMiLCJTeW5jIiwiaXNQYXJlbnQiLCJzeW5jIiwibmF2aWdhdGUiLCJXaGVlbCIsIl9FdmVudEludGVyZmFjZTEyIiwibGFzdFRpbWUiLCJ3aGVlbCIsIm9uV2hlZWwiLCJkZWx0YVkiLCJfbWluIiwid2hlZWxNaW5UaHJlc2hvbGQiLCJzbGVlcCIsIndoZWVsU2xlZXAiLCJzaG91bGRQcmV2ZW50IiwicmVsZWFzZVdoZWVsIiwiU1JfUkVNT1ZBTF9ERUxBWSIsIkxpdmUiLCJfRXZlbnRJbnRlcmZhY2UxMyIsImxpdmUiLCJzciIsInRleHRDb250ZW50IiwiQ29tcG9uZW50Q29uc3RydWN0b3JzIiwiZnJlZXplIiwiX19wcm90b19fIiwiSTE4TiIsIkRFRkFVTFRTIiwic3BlZWQiLCJyZXdpbmRTcGVlZCIsIkZhZGUiLCJkb25lIiwiU2xpZGUiLCJ0cmFuc2l0aW9uIiwiZW5kQ2FsbGJhY2siLCJnZXRTcGVlZCIsInVzZVNjcm9sbCIsIl9TcGxpZGUiLCJfU3BsaWRlMiIsIl9vIiwiX0UiLCJkZWZhdWx0cyIsIkpTT04iLCJfcHJvdG8iLCJFeHRlbnNpb25zIiwiX3RoaXMiLCJfQyIsIl9UIiwiQ29uc3RydWN0b3JzIiwiQ29tcG9uZW50IiwiY29tcG9uZW50IiwiX3RoaXMkZXZlbnQiLCJyZW1vdmUyIiwiU3BsaWRlIiwiUmVhY3QyIiwiRVZFTlRTIiwiY2xhc3NOYW1lcyIsIkJvb2xlYW4iLCJpc09iamVjdDIiLCJpc0VxdWFsRGVlcCIsInN1YmplY3QxIiwic3ViamVjdDIiLCJzb21lIiwia2V5czEiLCJrZXlzMiIsImhhc093blByb3BlcnR5IiwiaXNFcXVhbFNoYWxsb3ciLCJhcnJheTEiLCJhcnJheTIiLCJmb3JPd24yIiwibWVyZ2UyIiwiUmVhY3QiLCJTcGxpZGVUcmFjayIsIlNwbGlkZTIiLCJjb25zdHJ1Y3RvciIsInNwbGlkZVJlZiIsImNyZWF0ZVJlZiIsImNvbXBvbmVudERpZE1vdW50IiwiZXh0ZW5zaW9ucyIsImN1cnJlbnQiLCJnZXRTbGlkZXMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm5ld1NsaWRlcyIsIl9hIiwiaGFuZGxlciIsImFyZ3MiLCJyZW5kZXIiLCJSb290IiwiaGFzVHJhY2siLCJSZWFjdDMiLCJTcGxpZGVTbGlkZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@splidejs/react-splide/dist/js/react-splide.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@splidejs/splide-extension-auto-scroll/dist/js/splide-extension-auto-scroll.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@splidejs/splide-extension-auto-scroll/dist/js/splide-extension-auto-scroll.esm.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoScroll: () => (/* binding */ AutoScroll)\n/* harmony export */ });\n/*!\n * @splidejs/splide-extension-auto-scroll\n * Version  : 0.5.3\n * License  : MIT\n * Copyright: 2022 Naotoshi Fujita\n */ function empty(array) {\n    array.length = 0;\n}\nfunction slice$1(arrayLike, start, end) {\n    return Array.prototype.slice.call(arrayLike, start, end);\n}\nfunction apply$1(func) {\n    return func.bind.apply(func, [\n        null\n    ].concat(slice$1(arguments, 1)));\n}\nfunction raf(func) {\n    return requestAnimationFrame(func);\n}\nfunction typeOf$1(type, subject) {\n    return typeof subject === type;\n}\nvar isArray$1 = Array.isArray;\napply$1(typeOf$1, \"function\");\napply$1(typeOf$1, \"string\");\napply$1(typeOf$1, \"undefined\");\nfunction toArray$1(value) {\n    return isArray$1(value) ? value : [\n        value\n    ];\n}\nfunction forEach$1(values, iteratee) {\n    toArray$1(values).forEach(iteratee);\n}\nvar ownKeys$1 = Object.keys;\nfunction forOwn$1(object, iteratee, right) {\n    if (object) {\n        var keys = ownKeys$1(object);\n        keys = right ? keys.reverse() : keys;\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (key !== \"__proto__\") {\n                if (iteratee(object[key], key) === false) {\n                    break;\n                }\n            }\n        }\n    }\n    return object;\n}\nfunction assign$1(object) {\n    slice$1(arguments, 1).forEach(function(source) {\n        forOwn$1(source, function(value, key) {\n            object[key] = source[key];\n        });\n    });\n    return object;\n}\nvar min$1 = Math.min;\nfunction EventBinder() {\n    var listeners = [];\n    function bind(targets, events, callback, options) {\n        forEachEvent(targets, events, function(target, event, namespace) {\n            var isEventTarget = \"addEventListener\" in target;\n            var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target[\"removeListener\"].bind(target, callback);\n            isEventTarget ? target.addEventListener(event, callback, options) : target[\"addListener\"](callback);\n            listeners.push([\n                target,\n                event,\n                namespace,\n                callback,\n                remover\n            ]);\n        });\n    }\n    function unbind(targets, events, callback) {\n        forEachEvent(targets, events, function(target, event, namespace) {\n            listeners = listeners.filter(function(listener) {\n                if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {\n                    listener[4]();\n                    return false;\n                }\n                return true;\n            });\n        });\n    }\n    function dispatch(target, type, detail) {\n        var e;\n        var bubbles = true;\n        if (typeof CustomEvent === \"function\") {\n            e = new CustomEvent(type, {\n                bubbles: bubbles,\n                detail: detail\n            });\n        } else {\n            e = document.createEvent(\"CustomEvent\");\n            e.initCustomEvent(type, bubbles, false, detail);\n        }\n        target.dispatchEvent(e);\n        return e;\n    }\n    function forEachEvent(targets, events, iteratee) {\n        forEach$1(targets, function(target) {\n            target && forEach$1(events, function(events2) {\n                events2.split(\" \").forEach(function(eventNS) {\n                    var fragment = eventNS.split(\".\");\n                    iteratee(target, fragment[0], fragment[1]);\n                });\n            });\n        });\n    }\n    function destroy() {\n        listeners.forEach(function(data) {\n            data[4]();\n        });\n        empty(listeners);\n    }\n    return {\n        bind: bind,\n        unbind: unbind,\n        dispatch: dispatch,\n        destroy: destroy\n    };\n}\nvar EVENT_MOVE = \"move\";\nvar EVENT_MOVED = \"moved\";\nvar EVENT_UPDATED = \"updated\";\nvar EVENT_DRAG = \"drag\";\nvar EVENT_DRAGGED = \"dragged\";\nvar EVENT_SCROLL = \"scroll\";\nvar EVENT_SCROLLED = \"scrolled\";\nvar EVENT_DESTROY = \"destroy\";\nfunction EventInterface(Splide2) {\n    var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();\n    var binder = EventBinder();\n    function on(events, callback) {\n        binder.bind(bus, toArray$1(events).join(\" \"), function(e) {\n            callback.apply(callback, isArray$1(e.detail) ? e.detail : []);\n        });\n    }\n    function emit(event) {\n        binder.dispatch(bus, event, slice$1(arguments, 1));\n    }\n    if (Splide2) {\n        Splide2.event.on(EVENT_DESTROY, binder.destroy);\n    }\n    return assign$1(binder, {\n        bus: bus,\n        on: on,\n        off: apply$1(binder.unbind, bus),\n        emit: emit\n    });\n}\nfunction RequestInterval(interval, onInterval, onUpdate, limit) {\n    var now = Date.now;\n    var startTime;\n    var rate = 0;\n    var id;\n    var paused = true;\n    var count = 0;\n    function update() {\n        if (!paused) {\n            rate = interval ? min$1((now() - startTime) / interval, 1) : 1;\n            onUpdate && onUpdate(rate);\n            if (rate >= 1) {\n                onInterval();\n                startTime = now();\n                if (limit && ++count >= limit) {\n                    return pause();\n                }\n            }\n            raf(update);\n        }\n    }\n    function start(resume) {\n        !resume && cancel();\n        startTime = now() - (resume ? rate * interval : 0);\n        paused = false;\n        raf(update);\n    }\n    function pause() {\n        paused = true;\n    }\n    function rewind() {\n        startTime = now();\n        rate = 0;\n        if (onUpdate) {\n            onUpdate(rate);\n        }\n    }\n    function cancel() {\n        id && cancelAnimationFrame(id);\n        rate = 0;\n        id = 0;\n        paused = true;\n    }\n    function set(time) {\n        interval = time;\n    }\n    function isPaused() {\n        return paused;\n    }\n    return {\n        start: start,\n        rewind: rewind,\n        pause: pause,\n        cancel: cancel,\n        set: set,\n        isPaused: isPaused\n    };\n}\nfunction Throttle(func, duration) {\n    var interval;\n    function throttled() {\n        if (!interval) {\n            interval = RequestInterval(duration || 0, function() {\n                func();\n                interval = null;\n            }, null, 1);\n            interval.start();\n        }\n    }\n    return throttled;\n}\nvar CLASS_ACTIVE = \"is-active\";\nvar SLIDE = \"slide\";\nvar FADE = \"fade\";\nfunction slice(arrayLike, start, end) {\n    return Array.prototype.slice.call(arrayLike, start, end);\n}\nfunction apply(func) {\n    return func.bind(null, ...slice(arguments, 1));\n}\nfunction typeOf(type, subject) {\n    return typeof subject === type;\n}\nfunction isObject(subject) {\n    return !isNull(subject) && typeOf(\"object\", subject);\n}\nconst isArray = Array.isArray;\napply(typeOf, \"function\");\napply(typeOf, \"string\");\nconst isUndefined = apply(typeOf, \"undefined\");\nfunction isNull(subject) {\n    return subject === null;\n}\nfunction toArray(value) {\n    return isArray(value) ? value : [\n        value\n    ];\n}\nfunction forEach(values, iteratee) {\n    toArray(values).forEach(iteratee);\n}\nfunction toggleClass(elm, classes, add) {\n    if (elm) {\n        forEach(classes, (name)=>{\n            if (name) {\n                elm.classList[add ? \"add\" : \"remove\"](name);\n            }\n        });\n    }\n}\nconst ownKeys = Object.keys;\nfunction forOwn(object, iteratee, right) {\n    if (object) {\n        let keys = ownKeys(object);\n        keys = right ? keys.reverse() : keys;\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            if (key !== \"__proto__\") {\n                if (iteratee(object[key], key) === false) {\n                    break;\n                }\n            }\n        }\n    }\n    return object;\n}\nfunction assign(object) {\n    slice(arguments, 1).forEach((source)=>{\n        forOwn(source, (value, key)=>{\n            object[key] = source[key];\n        });\n    });\n    return object;\n}\nfunction removeAttribute(elms, attrs) {\n    forEach(elms, (elm)=>{\n        forEach(attrs, (attr)=>{\n            elm && elm.removeAttribute(attr);\n        });\n    });\n}\nfunction setAttribute(elms, attrs, value) {\n    if (isObject(attrs)) {\n        forOwn(attrs, (value2, name)=>{\n            setAttribute(elms, name, value2);\n        });\n    } else {\n        forEach(elms, (elm)=>{\n            isNull(value) || value === \"\" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));\n        });\n    }\n}\nconst { min, max, floor, ceil, abs } = Math;\nfunction clamp(number, x, y) {\n    const minimum = min(x, y);\n    const maximum = max(x, y);\n    return min(max(minimum, number), maximum);\n}\nconst DEFAULTS = {\n    speed: 1,\n    autoStart: true,\n    pauseOnHover: true,\n    pauseOnFocus: true\n};\nconst I18N = {\n    startScroll: \"Start auto scroll\",\n    pauseScroll: \"Pause auto scroll\"\n};\nfunction AutoScroll(Splide2, Components2, options) {\n    const { on, off, bind, unbind } = EventInterface(Splide2);\n    const { translate, getPosition, toIndex, getLimit } = Components2.Move;\n    const { setIndex, getIndex } = Components2.Controller;\n    const { orient } = Components2.Direction;\n    const { toggle } = Components2.Elements;\n    const { Live } = Components2;\n    const { root } = Splide2;\n    const throttledUpdateArrows = Throttle(Components2.Arrows.update, 500);\n    let autoScrollOptions = {};\n    let interval;\n    let stopped;\n    let hovered;\n    let focused;\n    let busy;\n    let currPosition;\n    function setup() {\n        const { autoScroll } = options;\n        autoScrollOptions = assign({}, DEFAULTS, isObject(autoScroll) ? autoScroll : {});\n    }\n    function mount() {\n        if (!Splide2.is(FADE)) {\n            if (!interval && options.autoScroll !== false) {\n                interval = RequestInterval(0, move);\n                listen();\n                autoStart();\n            }\n        }\n    }\n    function destroy() {\n        if (interval) {\n            interval.cancel();\n            interval = null;\n            currPosition = void 0;\n            off([\n                EVENT_MOVE,\n                EVENT_DRAG,\n                EVENT_SCROLL,\n                EVENT_MOVED,\n                EVENT_SCROLLED\n            ]);\n            unbind(root, \"mouseenter mouseleave focusin focusout\");\n            unbind(toggle, \"click\");\n        }\n    }\n    function listen() {\n        if (autoScrollOptions.pauseOnHover) {\n            bind(root, \"mouseenter mouseleave\", (e)=>{\n                hovered = e.type === \"mouseenter\";\n                autoToggle();\n            });\n        }\n        if (autoScrollOptions.pauseOnFocus) {\n            bind(root, \"focusin focusout\", (e)=>{\n                focused = e.type === \"focusin\";\n                autoToggle();\n            });\n        }\n        if (autoScrollOptions.useToggleButton) {\n            bind(toggle, \"click\", ()=>{\n                stopped ? play() : pause();\n            });\n        }\n        on(EVENT_UPDATED, update);\n        on([\n            EVENT_MOVE,\n            EVENT_DRAG,\n            EVENT_SCROLL\n        ], ()=>{\n            busy = true;\n            pause(false);\n        });\n        on([\n            EVENT_MOVED,\n            EVENT_DRAGGED,\n            EVENT_SCROLLED\n        ], ()=>{\n            busy = false;\n            autoToggle();\n        });\n    }\n    function update() {\n        const { autoScroll } = options;\n        if (autoScroll !== false) {\n            autoScrollOptions = assign({}, autoScrollOptions, isObject(autoScroll) ? autoScroll : {});\n            mount();\n        } else {\n            destroy();\n        }\n        if (interval && !isUndefined(currPosition)) {\n            translate(currPosition);\n        }\n    }\n    function autoStart() {\n        if (autoScrollOptions.autoStart) {\n            if (document.readyState === \"complete\") {\n                play();\n            } else {\n                bind(window, \"load\", play);\n            }\n        }\n    }\n    function play() {\n        if (isPaused()) {\n            interval.start(true);\n            Live.disable(true);\n            focused = hovered = stopped = false;\n            updateButton();\n        }\n    }\n    function pause(stop = true) {\n        if (!stopped) {\n            stopped = stop;\n            updateButton();\n            if (!isPaused()) {\n                interval.pause();\n                Live.disable(false);\n            }\n        }\n    }\n    function autoToggle() {\n        if (!stopped) {\n            hovered || focused || busy ? pause(false) : play();\n        }\n    }\n    function move() {\n        const position = getPosition();\n        const destination = computeDestination(position);\n        if (position !== destination) {\n            translate(destination);\n            updateIndex(currPosition = getPosition());\n        } else {\n            pause(false);\n            if (autoScrollOptions.rewind) {\n                Splide2.go(autoScrollOptions.speed > 0 ? 0 : Components2.Controller.getEnd());\n            }\n        }\n        throttledUpdateArrows();\n    }\n    function computeDestination(position) {\n        const speed = autoScrollOptions.speed || 1;\n        position += orient(speed);\n        if (Splide2.is(SLIDE)) {\n            position = clamp(position, getLimit(false), getLimit(true));\n        }\n        return position;\n    }\n    function updateIndex(position) {\n        const { length } = Splide2;\n        const index = (toIndex(position) + length) % length;\n        if (index !== getIndex()) {\n            setIndex(index);\n            Components2.Slides.update();\n            Components2.Pagination.update();\n            options.lazyLoad === \"nearby\" && Components2.LazyLoad.check();\n        }\n    }\n    function updateButton() {\n        if (toggle) {\n            const key = stopped ? \"startScroll\" : \"pauseScroll\";\n            toggleClass(toggle, CLASS_ACTIVE, !stopped);\n            setAttribute(toggle, \"aria-label\", options.i18n[key] || I18N[key]);\n        }\n    }\n    function isPaused() {\n        return !interval || interval.isPaused();\n    }\n    return {\n        setup,\n        mount,\n        destroy,\n        play,\n        pause,\n        isPaused\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS1leHRlbnNpb24tYXV0by1zY3JvbGwvZGlzdC9qcy9zcGxpZGUtZXh0ZW5zaW9uLWF1dG8tc2Nyb2xsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxTQUFTQSxNQUFNQyxLQUFLO0lBQ2xCQSxNQUFNQyxNQUFNLEdBQUc7QUFDakI7QUFFQSxTQUFTQyxRQUFRQyxTQUFTLEVBQUVDLEtBQUssRUFBRUMsR0FBRztJQUNwQyxPQUFPQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDTixXQUFXQyxPQUFPQztBQUN0RDtBQUVBLFNBQVNLLFFBQVFDLElBQUk7SUFDbkIsT0FBT0EsS0FBS0MsSUFBSSxDQUFDQyxLQUFLLENBQUNGLE1BQU07UUFBQztLQUFLLENBQUNHLE1BQU0sQ0FBQ1osUUFBUWEsV0FBVztBQUNoRTtBQUVBLFNBQVNDLElBQUlMLElBQUk7SUFDZixPQUFPTSxzQkFBc0JOO0FBQy9CO0FBRUEsU0FBU08sU0FBU0MsSUFBSSxFQUFFQyxPQUFPO0lBQzdCLE9BQU8sT0FBT0EsWUFBWUQ7QUFDNUI7QUFFQSxJQUFJRSxZQUFZZixNQUFNZ0IsT0FBTztBQUM3QlosUUFBUVEsVUFBVTtBQUNsQlIsUUFBUVEsVUFBVTtBQUNsQlIsUUFBUVEsVUFBVTtBQUVsQixTQUFTSyxVQUFVQyxLQUFLO0lBQ3RCLE9BQU9ILFVBQVVHLFNBQVNBLFFBQVE7UUFBQ0E7S0FBTTtBQUMzQztBQUVBLFNBQVNDLFVBQVVDLE1BQU0sRUFBRUMsUUFBUTtJQUNqQ0osVUFBVUcsUUFBUUUsT0FBTyxDQUFDRDtBQUM1QjtBQUVBLElBQUlFLFlBQVlDLE9BQU9DLElBQUk7QUFFM0IsU0FBU0MsU0FBU0MsTUFBTSxFQUFFTixRQUFRLEVBQUVPLEtBQUs7SUFDdkMsSUFBSUQsUUFBUTtRQUNWLElBQUlGLE9BQU9GLFVBQVVJO1FBQ3JCRixPQUFPRyxRQUFRSCxLQUFLSSxPQUFPLEtBQUtKO1FBRWhDLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJTCxLQUFLOUIsTUFBTSxFQUFFbUMsSUFBSztZQUNwQyxJQUFJQyxNQUFNTixJQUFJLENBQUNLLEVBQUU7WUFFakIsSUFBSUMsUUFBUSxhQUFhO2dCQUN2QixJQUFJVixTQUFTTSxNQUFNLENBQUNJLElBQUksRUFBRUEsU0FBUyxPQUFPO29CQUN4QztnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9KO0FBQ1Q7QUFFQSxTQUFTSyxTQUFTTCxNQUFNO0lBQ3RCL0IsUUFBUWEsV0FBVyxHQUFHYSxPQUFPLENBQUMsU0FBVVcsTUFBTTtRQUM1Q1AsU0FBU08sUUFBUSxTQUFVZixLQUFLLEVBQUVhLEdBQUc7WUFDbkNKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRSxNQUFNLENBQUNGLElBQUk7UUFDM0I7SUFDRjtJQUNBLE9BQU9KO0FBQ1Q7QUFFQSxJQUFJTyxRQUFRQyxLQUFLQyxHQUFHO0FBRXBCLFNBQVNDO0lBQ1AsSUFBSUMsWUFBWSxFQUFFO0lBRWxCLFNBQVNoQyxLQUFLaUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTztRQUM5Q0MsYUFBYUosU0FBU0MsUUFBUSxTQUFVSSxNQUFNLEVBQUVDLEtBQUssRUFBRUMsU0FBUztZQUM5RCxJQUFJQyxnQkFBaUIsc0JBQXNCSDtZQUMzQyxJQUFJSSxVQUFVRCxnQkFBZ0JILE9BQU9LLG1CQUFtQixDQUFDM0MsSUFBSSxDQUFDc0MsUUFBUUMsT0FBT0osVUFBVUMsV0FBV0UsTUFBTSxDQUFDLGlCQUFpQixDQUFDdEMsSUFBSSxDQUFDc0MsUUFBUUg7WUFDeElNLGdCQUFnQkgsT0FBT00sZ0JBQWdCLENBQUNMLE9BQU9KLFVBQVVDLFdBQVdFLE1BQU0sQ0FBQyxjQUFjLENBQUNIO1lBQzFGSCxVQUFVYSxJQUFJLENBQUM7Z0JBQUNQO2dCQUFRQztnQkFBT0M7Z0JBQVdMO2dCQUFVTzthQUFRO1FBQzlEO0lBQ0Y7SUFFQSxTQUFTSSxPQUFPYixPQUFPLEVBQUVDLE1BQU0sRUFBRUMsUUFBUTtRQUN2Q0UsYUFBYUosU0FBU0MsUUFBUSxTQUFVSSxNQUFNLEVBQUVDLEtBQUssRUFBRUMsU0FBUztZQUM5RFIsWUFBWUEsVUFBVWUsTUFBTSxDQUFDLFNBQVVDLFFBQVE7Z0JBQzdDLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEtBQUtWLFVBQVVVLFFBQVEsQ0FBQyxFQUFFLEtBQUtULFNBQVNTLFFBQVEsQ0FBQyxFQUFFLEtBQUtSLGFBQWMsRUFBQ0wsWUFBWWEsUUFBUSxDQUFDLEVBQUUsS0FBS2IsUUFBTyxHQUFJO29CQUMzSGEsUUFBUSxDQUFDLEVBQUU7b0JBQ1gsT0FBTztnQkFDVDtnQkFFQSxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsU0FBU0MsU0FBU1gsTUFBTSxFQUFFL0IsSUFBSSxFQUFFMkMsTUFBTTtRQUNwQyxJQUFJQztRQUNKLElBQUlDLFVBQVU7UUFFZCxJQUFJLE9BQU9DLGdCQUFnQixZQUFZO1lBQ3JDRixJQUFJLElBQUlFLFlBQVk5QyxNQUFNO2dCQUN4QjZDLFNBQVNBO2dCQUNURixRQUFRQTtZQUNWO1FBQ0YsT0FBTztZQUNMQyxJQUFJRyxTQUFTQyxXQUFXLENBQUM7WUFDekJKLEVBQUVLLGVBQWUsQ0FBQ2pELE1BQU02QyxTQUFTLE9BQU9GO1FBQzFDO1FBRUFaLE9BQU9tQixhQUFhLENBQUNOO1FBQ3JCLE9BQU9BO0lBQ1Q7SUFFQSxTQUFTZCxhQUFhSixPQUFPLEVBQUVDLE1BQU0sRUFBRW5CLFFBQVE7UUFDN0NGLFVBQVVvQixTQUFTLFNBQVVLLE1BQU07WUFDakNBLFVBQVV6QixVQUFVcUIsUUFBUSxTQUFVd0IsT0FBTztnQkFDM0NBLFFBQVFDLEtBQUssQ0FBQyxLQUFLM0MsT0FBTyxDQUFDLFNBQVU0QyxPQUFPO29CQUMxQyxJQUFJQyxXQUFXRCxRQUFRRCxLQUFLLENBQUM7b0JBQzdCNUMsU0FBU3VCLFFBQVF1QixRQUFRLENBQUMsRUFBRSxFQUFFQSxRQUFRLENBQUMsRUFBRTtnQkFDM0M7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxTQUFTQztRQUNQOUIsVUFBVWhCLE9BQU8sQ0FBQyxTQUFVK0MsSUFBSTtZQUM5QkEsSUFBSSxDQUFDLEVBQUU7UUFDVDtRQUNBNUUsTUFBTTZDO0lBQ1I7SUFFQSxPQUFPO1FBQ0xoQyxNQUFNQTtRQUNOOEMsUUFBUUE7UUFDUkcsVUFBVUE7UUFDVmEsU0FBU0E7SUFDWDtBQUNGO0FBQ0EsSUFBSUUsYUFBYTtBQUNqQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxnQkFBZ0I7QUFFcEIsU0FBU0MsZUFBZUMsT0FBTztJQUM3QixJQUFJQyxNQUFNRCxVQUFVQSxRQUFRbEMsS0FBSyxDQUFDbUMsR0FBRyxHQUFHcEIsU0FBU3FCLHNCQUFzQjtJQUN2RSxJQUFJQyxTQUFTN0M7SUFFYixTQUFTOEMsR0FBRzNDLE1BQU0sRUFBRUMsUUFBUTtRQUMxQnlDLE9BQU81RSxJQUFJLENBQUMwRSxLQUFLL0QsVUFBVXVCLFFBQVE0QyxJQUFJLENBQUMsTUFBTSxTQUFVM0IsQ0FBQztZQUN2RGhCLFNBQVNsQyxLQUFLLENBQUNrQyxVQUFVMUIsVUFBVTBDLEVBQUVELE1BQU0sSUFBSUMsRUFBRUQsTUFBTSxHQUFHLEVBQUU7UUFDOUQ7SUFDRjtJQUVBLFNBQVM2QixLQUFLeEMsS0FBSztRQUNqQnFDLE9BQU8zQixRQUFRLENBQUN5QixLQUFLbkMsT0FBT2pELFFBQVFhLFdBQVc7SUFDakQ7SUFFQSxJQUFJc0UsU0FBUztRQUNYQSxRQUFRbEMsS0FBSyxDQUFDc0MsRUFBRSxDQUFDTixlQUFlSyxPQUFPZCxPQUFPO0lBQ2hEO0lBRUEsT0FBT3BDLFNBQVNrRCxRQUFRO1FBQ3RCRixLQUFLQTtRQUNMRyxJQUFJQTtRQUNKRyxLQUFLbEYsUUFBUThFLE9BQU85QixNQUFNLEVBQUU0QjtRQUM1QkssTUFBTUE7SUFDUjtBQUNGO0FBRUEsU0FBU0UsZ0JBQWdCQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQzVELElBQUlDLE1BQU1DLEtBQUtELEdBQUc7SUFDbEIsSUFBSUU7SUFDSixJQUFJQyxPQUFPO0lBQ1gsSUFBSUM7SUFDSixJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsUUFBUTtJQUVaLFNBQVNDO1FBQ1AsSUFBSSxDQUFDRixRQUFRO1lBQ1hGLE9BQU9QLFdBQVd0RCxNQUFNLENBQUMwRCxRQUFRRSxTQUFRLElBQUtOLFVBQVUsS0FBSztZQUM3REUsWUFBWUEsU0FBU0s7WUFFckIsSUFBSUEsUUFBUSxHQUFHO2dCQUNiTjtnQkFDQUssWUFBWUY7Z0JBRVosSUFBSUQsU0FBUyxFQUFFTyxTQUFTUCxPQUFPO29CQUM3QixPQUFPUztnQkFDVDtZQUNGO1lBRUExRixJQUFJeUY7UUFDTjtJQUNGO0lBRUEsU0FBU3JHLE1BQU11RyxNQUFNO1FBQ25CLENBQUNBLFVBQVVDO1FBQ1hSLFlBQVlGLFFBQVNTLENBQUFBLFNBQVNOLE9BQU9QLFdBQVc7UUFDaERTLFNBQVM7UUFDVHZGLElBQUl5RjtJQUNOO0lBRUEsU0FBU0M7UUFDUEgsU0FBUztJQUNYO0lBRUEsU0FBU007UUFDUFQsWUFBWUY7UUFDWkcsT0FBTztRQUVQLElBQUlMLFVBQVU7WUFDWkEsU0FBU0s7UUFDWDtJQUNGO0lBRUEsU0FBU087UUFDUE4sTUFBTVEscUJBQXFCUjtRQUMzQkQsT0FBTztRQUNQQyxLQUFLO1FBQ0xDLFNBQVM7SUFDWDtJQUVBLFNBQVNRLElBQUlDLElBQUk7UUFDZmxCLFdBQVdrQjtJQUNiO0lBRUEsU0FBU0M7UUFDUCxPQUFPVjtJQUNUO0lBRUEsT0FBTztRQUNMbkcsT0FBT0E7UUFDUHlHLFFBQVFBO1FBQ1JILE9BQU9BO1FBQ1BFLFFBQVFBO1FBQ1JHLEtBQUtBO1FBQ0xFLFVBQVVBO0lBQ1o7QUFDRjtBQUVBLFNBQVNDLFNBQVN2RyxJQUFJLEVBQUV3RyxRQUFRO0lBQzlCLElBQUlyQjtJQUVKLFNBQVNzQjtRQUNQLElBQUksQ0FBQ3RCLFVBQVU7WUFDYkEsV0FBV0QsZ0JBQWdCc0IsWUFBWSxHQUFHO2dCQUN4Q3hHO2dCQUNBbUYsV0FBVztZQUNiLEdBQUcsTUFBTTtZQUNUQSxTQUFTMUYsS0FBSztRQUNoQjtJQUNGO0lBRUEsT0FBT2dIO0FBQ1Q7QUFDQSxJQUFJQyxlQUFlO0FBRW5CLElBQUlDLFFBQVE7QUFDWixJQUFJQyxPQUFPO0FBRVgsU0FBUy9HLE1BQU1MLFNBQVMsRUFBRUMsS0FBSyxFQUFFQyxHQUFHO0lBQ2xDLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNOLFdBQVdDLE9BQU9DO0FBQ3REO0FBRUEsU0FBU1EsTUFBTUYsSUFBSTtJQUNqQixPQUFPQSxLQUFLQyxJQUFJLENBQUMsU0FBU0osTUFBTU8sV0FBVztBQUM3QztBQUVBLFNBQVN5RyxPQUFPckcsSUFBSSxFQUFFQyxPQUFPO0lBQzNCLE9BQU8sT0FBT0EsWUFBWUQ7QUFDNUI7QUFDQSxTQUFTc0csU0FBU3JHLE9BQU87SUFDdkIsT0FBTyxDQUFDc0csT0FBT3RHLFlBQVlvRyxPQUFPLFVBQVVwRztBQUM5QztBQUNBLE1BQU1FLFVBQVVoQixNQUFNZ0IsT0FBTztBQUM3QlQsTUFBTTJHLFFBQVE7QUFDZDNHLE1BQU0yRyxRQUFRO0FBQ2QsTUFBTUcsY0FBYzlHLE1BQU0yRyxRQUFRO0FBQ2xDLFNBQVNFLE9BQU90RyxPQUFPO0lBQ3JCLE9BQU9BLFlBQVk7QUFDckI7QUFFQSxTQUFTd0csUUFBUXBHLEtBQUs7SUFDcEIsT0FBT0YsUUFBUUUsU0FBU0EsUUFBUTtRQUFDQTtLQUFNO0FBQ3pDO0FBRUEsU0FBU0ksUUFBUUYsTUFBTSxFQUFFQyxRQUFRO0lBQy9CaUcsUUFBUWxHLFFBQVFFLE9BQU8sQ0FBQ0Q7QUFDMUI7QUFFQSxTQUFTa0csWUFBWUMsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDcEMsSUFBSUYsS0FBSztRQUNQbEcsUUFBUW1HLFNBQVMsQ0FBQ0U7WUFDaEIsSUFBSUEsTUFBTTtnQkFDUkgsSUFBSUksU0FBUyxDQUFDRixNQUFNLFFBQVEsU0FBUyxDQUFDQztZQUN4QztRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1FLFVBQVVyRyxPQUFPQyxJQUFJO0FBRTNCLFNBQVNxRyxPQUFPbkcsTUFBTSxFQUFFTixRQUFRLEVBQUVPLEtBQUs7SUFDckMsSUFBSUQsUUFBUTtRQUNWLElBQUlGLE9BQU9vRyxRQUFRbEc7UUFDbkJGLE9BQU9HLFFBQVFILEtBQUtJLE9BQU8sS0FBS0o7UUFDaEMsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlMLEtBQUs5QixNQUFNLEVBQUVtQyxJQUFLO1lBQ3BDLE1BQU1DLE1BQU1OLElBQUksQ0FBQ0ssRUFBRTtZQUNuQixJQUFJQyxRQUFRLGFBQWE7Z0JBQ3ZCLElBQUlWLFNBQVNNLE1BQU0sQ0FBQ0ksSUFBSSxFQUFFQSxTQUFTLE9BQU87b0JBQ3hDO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT0o7QUFDVDtBQUVBLFNBQVNvRyxPQUFPcEcsTUFBTTtJQUNwQnpCLE1BQU1PLFdBQVcsR0FBR2EsT0FBTyxDQUFDLENBQUNXO1FBQzNCNkYsT0FBTzdGLFFBQVEsQ0FBQ2YsT0FBT2E7WUFDckJKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRSxNQUFNLENBQUNGLElBQUk7UUFDM0I7SUFDRjtJQUNBLE9BQU9KO0FBQ1Q7QUFFQSxTQUFTcUcsZ0JBQWdCQyxJQUFJLEVBQUVDLEtBQUs7SUFDbEM1RyxRQUFRMkcsTUFBTSxDQUFDVDtRQUNibEcsUUFBUTRHLE9BQU8sQ0FBQ0M7WUFDZFgsT0FBT0EsSUFBSVEsZUFBZSxDQUFDRztRQUM3QjtJQUNGO0FBQ0Y7QUFFQSxTQUFTQyxhQUFhSCxJQUFJLEVBQUVDLEtBQUssRUFBRWhILEtBQUs7SUFDdEMsSUFBSWlHLFNBQVNlLFFBQVE7UUFDbkJKLE9BQU9JLE9BQU8sQ0FBQ0csUUFBUVY7WUFDckJTLGFBQWFILE1BQU1OLE1BQU1VO1FBQzNCO0lBQ0YsT0FBTztRQUNML0csUUFBUTJHLE1BQU0sQ0FBQ1Q7WUFDYkosT0FBT2xHLFVBQVVBLFVBQVUsS0FBSzhHLGdCQUFnQlIsS0FBS1UsU0FBU1YsSUFBSVksWUFBWSxDQUFDRixPQUFPSSxPQUFPcEg7UUFDL0Y7SUFDRjtBQUNGO0FBRUEsTUFBTSxFQUFFa0IsR0FBRyxFQUFFbUcsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFLEdBQUd2RztBQUV2QyxTQUFTd0csTUFBTUMsTUFBTSxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDekIsTUFBTUMsVUFBVTNHLElBQUl5RyxHQUFHQztJQUN2QixNQUFNRSxVQUFVVCxJQUFJTSxHQUFHQztJQUN2QixPQUFPMUcsSUFBSW1HLElBQUlRLFNBQVNILFNBQVNJO0FBQ25DO0FBRUEsTUFBTUMsV0FBVztJQUNmQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsY0FBYztJQUNkQyxjQUFjO0FBQ2hCO0FBRUEsTUFBTUMsT0FBTztJQUNYQyxhQUFhO0lBQ2JDLGFBQWE7QUFDZjtBQUVBLFNBQVNDLFdBQVcxRSxPQUFPLEVBQUUyRSxXQUFXLEVBQUVoSCxPQUFPO0lBQy9DLE1BQU0sRUFBRXlDLEVBQUUsRUFBRUcsR0FBRyxFQUFFaEYsSUFBSSxFQUFFOEMsTUFBTSxFQUFFLEdBQUcwQixlQUFlQztJQUNqRCxNQUFNLEVBQUU0RSxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR0osWUFBWUssSUFBSTtJQUN0RSxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFLEdBQUdQLFlBQVlRLFVBQVU7SUFDckQsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR1QsWUFBWVUsU0FBUztJQUN4QyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHWCxZQUFZWSxRQUFRO0lBQ3ZDLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdiO0lBQ2pCLE1BQU0sRUFBRWMsSUFBSSxFQUFFLEdBQUd6RjtJQUNqQixNQUFNMEYsd0JBQXdCN0QsU0FBUzhDLFlBQVlnQixNQUFNLENBQUN2RSxNQUFNLEVBQUU7SUFDbEUsSUFBSXdFLG9CQUFvQixDQUFDO0lBQ3pCLElBQUluRjtJQUNKLElBQUlvRjtJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osU0FBU0M7UUFDUCxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHeEk7UUFDdkJpSSxvQkFBb0I1QyxPQUFPLENBQUMsR0FBR2tCLFVBQVU5QixTQUFTK0QsY0FBY0EsYUFBYSxDQUFDO0lBQ2hGO0lBQ0EsU0FBU0M7UUFDUCxJQUFJLENBQUNwRyxRQUFRcUcsRUFBRSxDQUFDbkUsT0FBTztZQUNyQixJQUFJLENBQUN6QixZQUFZOUMsUUFBUXdJLFVBQVUsS0FBSyxPQUFPO2dCQUM3QzFGLFdBQVdELGdCQUFnQixHQUFHOEY7Z0JBQzlCQztnQkFDQW5DO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsU0FBUy9FO1FBQ1AsSUFBSW9CLFVBQVU7WUFDWkEsU0FBU2MsTUFBTTtZQUNmZCxXQUFXO1lBQ1h3RixlQUFlLEtBQUs7WUFDcEIxRixJQUFJO2dCQUFDaEI7Z0JBQVlHO2dCQUFZRTtnQkFBY0o7Z0JBQWFLO2FBQWU7WUFDdkV4QixPQUFPb0gsTUFBTTtZQUNicEgsT0FBT2lILFFBQVE7UUFDakI7SUFDRjtJQUNBLFNBQVNpQjtRQUNQLElBQUlYLGtCQUFrQnZCLFlBQVksRUFBRTtZQUNsQzlJLEtBQUtrSyxNQUFNLHlCQUF5QixDQUFDL0c7Z0JBQ25Db0gsVUFBVXBILEVBQUU1QyxJQUFJLEtBQUs7Z0JBQ3JCMEs7WUFDRjtRQUNGO1FBQ0EsSUFBSVosa0JBQWtCdEIsWUFBWSxFQUFFO1lBQ2xDL0ksS0FBS2tLLE1BQU0sb0JBQW9CLENBQUMvRztnQkFDOUJxSCxVQUFVckgsRUFBRTVDLElBQUksS0FBSztnQkFDckIwSztZQUNGO1FBQ0Y7UUFDQSxJQUFJWixrQkFBa0JhLGVBQWUsRUFBRTtZQUNyQ2xMLEtBQUsrSixRQUFRLFNBQVM7Z0JBQ3BCTyxVQUFVYSxTQUFTckY7WUFDckI7UUFDRjtRQUNBakIsR0FBR1gsZUFBZTJCO1FBQ2xCaEIsR0FBRztZQUFDYjtZQUFZRztZQUFZRTtTQUFhLEVBQUU7WUFDekNvRyxPQUFPO1lBQ1AzRSxNQUFNO1FBQ1I7UUFDQWpCLEdBQUc7WUFBQ1o7WUFBYUc7WUFBZUU7U0FBZSxFQUFFO1lBQy9DbUcsT0FBTztZQUNQUTtRQUNGO0lBQ0Y7SUFDQSxTQUFTcEY7UUFDUCxNQUFNLEVBQUUrRSxVQUFVLEVBQUUsR0FBR3hJO1FBQ3ZCLElBQUl3SSxlQUFlLE9BQU87WUFDeEJQLG9CQUFvQjVDLE9BQU8sQ0FBQyxHQUFHNEMsbUJBQW1CeEQsU0FBUytELGNBQWNBLGFBQWEsQ0FBQztZQUN2RkM7UUFDRixPQUFPO1lBQ0wvRztRQUNGO1FBQ0EsSUFBSW9CLFlBQVksQ0FBQzZCLFlBQVkyRCxlQUFlO1lBQzFDckIsVUFBVXFCO1FBQ1o7SUFDRjtJQUNBLFNBQVM3QjtRQUNQLElBQUl3QixrQkFBa0J4QixTQUFTLEVBQUU7WUFDL0IsSUFBSXZGLFNBQVM4SCxVQUFVLEtBQUssWUFBWTtnQkFDdENEO1lBQ0YsT0FBTztnQkFDTG5MLEtBQUtxTCxRQUFRLFFBQVFGO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUNBLFNBQVNBO1FBQ1AsSUFBSTlFLFlBQVk7WUFDZG5CLFNBQVMxRixLQUFLLENBQUM7WUFDZnlLLEtBQUtxQixPQUFPLENBQUM7WUFDYmQsVUFBVUQsVUFBVUQsVUFBVTtZQUM5QmlCO1FBQ0Y7SUFDRjtJQUNBLFNBQVN6RixNQUFNMEYsT0FBTyxJQUFJO1FBQ3hCLElBQUksQ0FBQ2xCLFNBQVM7WUFDWkEsVUFBVWtCO1lBQ1ZEO1lBQ0EsSUFBSSxDQUFDbEYsWUFBWTtnQkFDZm5CLFNBQVNZLEtBQUs7Z0JBQ2RtRSxLQUFLcUIsT0FBTyxDQUFDO1lBQ2Y7UUFDRjtJQUNGO0lBQ0EsU0FBU0w7UUFDUCxJQUFJLENBQUNYLFNBQVM7WUFDWkMsV0FBV0MsV0FBV0MsT0FBTzNFLE1BQU0sU0FBU3FGO1FBQzlDO0lBQ0Y7SUFDQSxTQUFTSjtRQUNQLE1BQU1VLFdBQVduQztRQUNqQixNQUFNb0MsY0FBY0MsbUJBQW1CRjtRQUN2QyxJQUFJQSxhQUFhQyxhQUFhO1lBQzVCckMsVUFBVXFDO1lBQ1ZFLFlBQVlsQixlQUFlcEI7UUFDN0IsT0FBTztZQUNMeEQsTUFBTTtZQUNOLElBQUl1RSxrQkFBa0JwRSxNQUFNLEVBQUU7Z0JBQzVCeEIsUUFBUW9ILEVBQUUsQ0FBQ3hCLGtCQUFrQnpCLEtBQUssR0FBRyxJQUFJLElBQUlRLFlBQVlRLFVBQVUsQ0FBQ2tDLE1BQU07WUFDNUU7UUFDRjtRQUNBM0I7SUFDRjtJQUNBLFNBQVN3QixtQkFBbUJGLFFBQVE7UUFDbEMsTUFBTTdDLFFBQVF5QixrQkFBa0J6QixLQUFLLElBQUk7UUFDekM2QyxZQUFZNUIsT0FBT2pCO1FBQ25CLElBQUluRSxRQUFRcUcsRUFBRSxDQUFDcEUsUUFBUTtZQUNyQitFLFdBQVdwRCxNQUFNb0QsVUFBVWpDLFNBQVMsUUFBUUEsU0FBUztRQUN2RDtRQUNBLE9BQU9pQztJQUNUO0lBQ0EsU0FBU0csWUFBWUgsUUFBUTtRQUMzQixNQUFNLEVBQUVwTSxNQUFNLEVBQUUsR0FBR29GO1FBQ25CLE1BQU1zSCxRQUFRLENBQUN4QyxRQUFRa0MsWUFBWXBNLE1BQUssSUFBS0E7UUFDN0MsSUFBSTBNLFVBQVVwQyxZQUFZO1lBQ3hCRCxTQUFTcUM7WUFDVDNDLFlBQVk0QyxNQUFNLENBQUNuRyxNQUFNO1lBQ3pCdUQsWUFBWTZDLFVBQVUsQ0FBQ3BHLE1BQU07WUFDN0J6RCxRQUFROEosUUFBUSxLQUFLLFlBQVk5QyxZQUFZK0MsUUFBUSxDQUFDQyxLQUFLO1FBQzdEO0lBQ0Y7SUFDQSxTQUFTYjtRQUNQLElBQUl4QixRQUFRO1lBQ1YsTUFBTXRJLE1BQU02SSxVQUFVLGdCQUFnQjtZQUN0Q3JELFlBQVk4QyxRQUFRdEQsY0FBYyxDQUFDNkQ7WUFDbkN4QyxhQUFhaUMsUUFBUSxjQUFjM0gsUUFBUWlLLElBQUksQ0FBQzVLLElBQUksSUFBSXVILElBQUksQ0FBQ3ZILElBQUk7UUFDbkU7SUFDRjtJQUNBLFNBQVM0RTtRQUNQLE9BQU8sQ0FBQ25CLFlBQVlBLFNBQVNtQixRQUFRO0lBQ3ZDO0lBQ0EsT0FBTztRQUNMc0U7UUFDQUU7UUFDQS9HO1FBQ0FxSDtRQUNBckY7UUFDQU87SUFDRjtBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmludG8vLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS1leHRlbnNpb24tYXV0by1zY3JvbGwvZGlzdC9qcy9zcGxpZGUtZXh0ZW5zaW9uLWF1dG8tc2Nyb2xsLmVzbS5qcz8xNzNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQHNwbGlkZWpzL3NwbGlkZS1leHRlbnNpb24tYXV0by1zY3JvbGxcbiAqIFZlcnNpb24gIDogMC41LjNcbiAqIExpY2Vuc2UgIDogTUlUXG4gKiBDb3B5cmlnaHQ6IDIwMjIgTmFvdG9zaGkgRnVqaXRhXG4gKi9cbmZ1bmN0aW9uIGVtcHR5KGFycmF5KSB7XG4gIGFycmF5Lmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIHNsaWNlJDEoYXJyYXlMaWtlLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UsIHN0YXJ0LCBlbmQpO1xufVxuXG5mdW5jdGlvbiBhcHBseSQxKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmMuYmluZC5hcHBseShmdW5jLCBbbnVsbF0uY29uY2F0KHNsaWNlJDEoYXJndW1lbnRzLCAxKSkpO1xufVxuXG5mdW5jdGlvbiByYWYoZnVuYykge1xuICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmMpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2YkMSh0eXBlLCBzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gdHlwZTtcbn1cblxudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXk7XG5hcHBseSQxKHR5cGVPZiQxLCBcImZ1bmN0aW9uXCIpO1xuYXBwbHkkMSh0eXBlT2YkMSwgXCJzdHJpbmdcIik7XG5hcHBseSQxKHR5cGVPZiQxLCBcInVuZGVmaW5lZFwiKTtcblxuZnVuY3Rpb24gdG9BcnJheSQxKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5JDEodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoJDEodmFsdWVzLCBpdGVyYXRlZSkge1xuICB0b0FycmF5JDEodmFsdWVzKS5mb3JFYWNoKGl0ZXJhdGVlKTtcbn1cblxudmFyIG93bktleXMkMSA9IE9iamVjdC5rZXlzO1xuXG5mdW5jdGlvbiBmb3JPd24kMShvYmplY3QsIGl0ZXJhdGVlLCByaWdodCkge1xuICBpZiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzJDEob2JqZWN0KTtcbiAgICBrZXlzID0gcmlnaHQgPyBrZXlzLnJldmVyc2UoKSA6IGtleXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShvYmplY3Rba2V5XSwga2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiQxKG9iamVjdCkge1xuICBzbGljZSQxKGFyZ3VtZW50cywgMSkuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgZm9yT3duJDEoc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBtaW4kMSA9IE1hdGgubWluO1xuXG5mdW5jdGlvbiBFdmVudEJpbmRlcigpIHtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGJpbmQodGFyZ2V0cywgZXZlbnRzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGZvckVhY2hFdmVudCh0YXJnZXRzLCBldmVudHMsIGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgICAgIHZhciBpc0V2ZW50VGFyZ2V0ID0gKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIHRhcmdldCk7XG4gICAgICB2YXIgcmVtb3ZlciA9IGlzRXZlbnRUYXJnZXQgPyB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHRhcmdldCwgZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zKSA6IHRhcmdldFtcInJlbW92ZUxpc3RlbmVyXCJdLmJpbmQodGFyZ2V0LCBjYWxsYmFjayk7XG4gICAgICBpc0V2ZW50VGFyZ2V0ID8gdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zKSA6IHRhcmdldFtcImFkZExpc3RlbmVyXCJdKGNhbGxiYWNrKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKFt0YXJnZXQsIGV2ZW50LCBuYW1lc3BhY2UsIGNhbGxiYWNrLCByZW1vdmVyXSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmJpbmQodGFyZ2V0cywgZXZlbnRzLCBjYWxsYmFjaykge1xuICAgIGZvckVhY2hFdmVudCh0YXJnZXRzLCBldmVudHMsIGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lclswXSA9PT0gdGFyZ2V0ICYmIGxpc3RlbmVyWzFdID09PSBldmVudCAmJiBsaXN0ZW5lclsyXSA9PT0gbmFtZXNwYWNlICYmICghY2FsbGJhY2sgfHwgbGlzdGVuZXJbM10gPT09IGNhbGxiYWNrKSkge1xuICAgICAgICAgIGxpc3RlbmVyWzRdKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKHRhcmdldCwgdHlwZSwgZGV0YWlsKSB7XG4gICAgdmFyIGU7XG4gICAgdmFyIGJ1YmJsZXMgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBlID0gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgYnViYmxlczogYnViYmxlcyxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBkZXRhaWwpO1xuICAgIH1cblxuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaEV2ZW50KHRhcmdldHMsIGV2ZW50cywgaXRlcmF0ZWUpIHtcbiAgICBmb3JFYWNoJDEodGFyZ2V0cywgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0ICYmIGZvckVhY2gkMShldmVudHMsIGZ1bmN0aW9uIChldmVudHMyKSB7XG4gICAgICAgIGV2ZW50czIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TlMpIHtcbiAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBldmVudE5TLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICBpdGVyYXRlZSh0YXJnZXQsIGZyYWdtZW50WzBdLCBmcmFnbWVudFsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBkYXRhWzRdKCk7XG4gICAgfSk7XG4gICAgZW1wdHkobGlzdGVuZXJzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmluZDogYmluZCxcbiAgICB1bmJpbmQ6IHVuYmluZCxcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgZGVzdHJveTogZGVzdHJveVxuICB9O1xufVxudmFyIEVWRU5UX01PVkUgPSBcIm1vdmVcIjtcbnZhciBFVkVOVF9NT1ZFRCA9IFwibW92ZWRcIjtcbnZhciBFVkVOVF9VUERBVEVEID0gXCJ1cGRhdGVkXCI7XG52YXIgRVZFTlRfRFJBRyA9IFwiZHJhZ1wiO1xudmFyIEVWRU5UX0RSQUdHRUQgPSBcImRyYWdnZWRcIjtcbnZhciBFVkVOVF9TQ1JPTEwgPSBcInNjcm9sbFwiO1xudmFyIEVWRU5UX1NDUk9MTEVEID0gXCJzY3JvbGxlZFwiO1xudmFyIEVWRU5UX0RFU1RST1kgPSBcImRlc3Ryb3lcIjtcblxuZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoU3BsaWRlMikge1xuICB2YXIgYnVzID0gU3BsaWRlMiA/IFNwbGlkZTIuZXZlbnQuYnVzIDogZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgYmluZGVyID0gRXZlbnRCaW5kZXIoKTtcblxuICBmdW5jdGlvbiBvbihldmVudHMsIGNhbGxiYWNrKSB7XG4gICAgYmluZGVyLmJpbmQoYnVzLCB0b0FycmF5JDEoZXZlbnRzKS5qb2luKFwiIFwiKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBpc0FycmF5JDEoZS5kZXRhaWwpID8gZS5kZXRhaWwgOiBbXSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgYmluZGVyLmRpc3BhdGNoKGJ1cywgZXZlbnQsIHNsaWNlJDEoYXJndW1lbnRzLCAxKSk7XG4gIH1cblxuICBpZiAoU3BsaWRlMikge1xuICAgIFNwbGlkZTIuZXZlbnQub24oRVZFTlRfREVTVFJPWSwgYmluZGVyLmRlc3Ryb3kpO1xuICB9XG5cbiAgcmV0dXJuIGFzc2lnbiQxKGJpbmRlciwge1xuICAgIGJ1czogYnVzLFxuICAgIG9uOiBvbixcbiAgICBvZmY6IGFwcGx5JDEoYmluZGVyLnVuYmluZCwgYnVzKSxcbiAgICBlbWl0OiBlbWl0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBSZXF1ZXN0SW50ZXJ2YWwoaW50ZXJ2YWwsIG9uSW50ZXJ2YWwsIG9uVXBkYXRlLCBsaW1pdCkge1xuICB2YXIgbm93ID0gRGF0ZS5ub3c7XG4gIHZhciBzdGFydFRpbWU7XG4gIHZhciByYXRlID0gMDtcbiAgdmFyIGlkO1xuICB2YXIgcGF1c2VkID0gdHJ1ZTtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHJhdGUgPSBpbnRlcnZhbCA/IG1pbiQxKChub3coKSAtIHN0YXJ0VGltZSkgLyBpbnRlcnZhbCwgMSkgOiAxO1xuICAgICAgb25VcGRhdGUgJiYgb25VcGRhdGUocmF0ZSk7XG5cbiAgICAgIGlmIChyYXRlID49IDEpIHtcbiAgICAgICAgb25JbnRlcnZhbCgpO1xuICAgICAgICBzdGFydFRpbWUgPSBub3coKTtcblxuICAgICAgICBpZiAobGltaXQgJiYgKytjb3VudCA+PSBsaW1pdCkge1xuICAgICAgICAgIHJldHVybiBwYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJhZih1cGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KHJlc3VtZSkge1xuICAgICFyZXN1bWUgJiYgY2FuY2VsKCk7XG4gICAgc3RhcnRUaW1lID0gbm93KCkgLSAocmVzdW1lID8gcmF0ZSAqIGludGVydmFsIDogMCk7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgcmFmKHVwZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgIHN0YXJ0VGltZSA9IG5vdygpO1xuICAgIHJhdGUgPSAwO1xuXG4gICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICBvblVwZGF0ZShyYXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWQgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgIHJhdGUgPSAwO1xuICAgIGlkID0gMDtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KHRpbWUpIHtcbiAgICBpbnRlcnZhbCA9IHRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gcGF1c2VkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgcmV3aW5kOiByZXdpbmQsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIGNhbmNlbDogY2FuY2VsLFxuICAgIHNldDogc2V0LFxuICAgIGlzUGF1c2VkOiBpc1BhdXNlZFxuICB9O1xufVxuXG5mdW5jdGlvbiBUaHJvdHRsZShmdW5jLCBkdXJhdGlvbikge1xuICB2YXIgaW50ZXJ2YWw7XG5cbiAgZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgIGludGVydmFsID0gUmVxdWVzdEludGVydmFsKGR1cmF0aW9uIHx8IDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgICBpbnRlcnZhbCA9IG51bGw7XG4gICAgICB9LCBudWxsLCAxKTtcbiAgICAgIGludGVydmFsLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cbnZhciBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiO1xuXG52YXIgU0xJREUgPSBcInNsaWRlXCI7XG52YXIgRkFERSA9IFwiZmFkZVwiO1xuXG5mdW5jdGlvbiBzbGljZShhcnJheUxpa2UsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSwgc3RhcnQsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmMuYmluZChudWxsLCAuLi5zbGljZShhcmd1bWVudHMsIDEpKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKHR5cGUsIHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSB0eXBlO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gIWlzTnVsbChzdWJqZWN0KSAmJiB0eXBlT2YoXCJvYmplY3RcIiwgc3ViamVjdCk7XG59XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmFwcGx5KHR5cGVPZiwgXCJmdW5jdGlvblwiKTtcbmFwcGx5KHR5cGVPZiwgXCJzdHJpbmdcIik7XG5jb25zdCBpc1VuZGVmaW5lZCA9IGFwcGx5KHR5cGVPZiwgXCJ1bmRlZmluZWRcIik7XG5mdW5jdGlvbiBpc051bGwoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIGZvckVhY2godmFsdWVzLCBpdGVyYXRlZSkge1xuICB0b0FycmF5KHZhbHVlcykuZm9yRWFjaChpdGVyYXRlZSk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsbSwgY2xhc3NlcywgYWRkKSB7XG4gIGlmIChlbG0pIHtcbiAgICBmb3JFYWNoKGNsYXNzZXMsIChuYW1lKSA9PiB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBlbG0uY2xhc3NMaXN0W2FkZCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXShuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBvd25LZXlzID0gT2JqZWN0LmtleXM7XG5cbmZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlLCByaWdodCkge1xuICBpZiAob2JqZWN0KSB7XG4gICAgbGV0IGtleXMgPSBvd25LZXlzKG9iamVjdCk7XG4gICAga2V5cyA9IHJpZ2h0ID8ga2V5cy5yZXZlcnNlKCkgOiBrZXlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgIT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKG9iamVjdFtrZXldLCBrZXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbihvYmplY3QpIHtcbiAgc2xpY2UoYXJndW1lbnRzLCAxKS5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICBmb3JPd24oc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbG1zLCBhdHRycykge1xuICBmb3JFYWNoKGVsbXMsIChlbG0pID0+IHtcbiAgICBmb3JFYWNoKGF0dHJzLCAoYXR0cikgPT4ge1xuICAgICAgZWxtICYmIGVsbS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxtcywgYXR0cnMsIHZhbHVlKSB7XG4gIGlmIChpc09iamVjdChhdHRycykpIHtcbiAgICBmb3JPd24oYXR0cnMsICh2YWx1ZTIsIG5hbWUpID0+IHtcbiAgICAgIHNldEF0dHJpYnV0ZShlbG1zLCBuYW1lLCB2YWx1ZTIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2goZWxtcywgKGVsbSkgPT4ge1xuICAgICAgaXNOdWxsKHZhbHVlKSB8fCB2YWx1ZSA9PT0gXCJcIiA/IHJlbW92ZUF0dHJpYnV0ZShlbG0sIGF0dHJzKSA6IGVsbS5zZXRBdHRyaWJ1dGUoYXR0cnMsIFN0cmluZyh2YWx1ZSkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IHsgbWluLCBtYXgsIGZsb29yLCBjZWlsLCBhYnMgfSA9IE1hdGg7XG5cbmZ1bmN0aW9uIGNsYW1wKG51bWJlciwgeCwgeSkge1xuICBjb25zdCBtaW5pbXVtID0gbWluKHgsIHkpO1xuICBjb25zdCBtYXhpbXVtID0gbWF4KHgsIHkpO1xuICByZXR1cm4gbWluKG1heChtaW5pbXVtLCBudW1iZXIpLCBtYXhpbXVtKTtcbn1cblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIHNwZWVkOiAxLFxuICBhdXRvU3RhcnQ6IHRydWUsXG4gIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcbiAgcGF1c2VPbkZvY3VzOiB0cnVlXG59O1xuXG5jb25zdCBJMThOID0ge1xuICBzdGFydFNjcm9sbDogXCJTdGFydCBhdXRvIHNjcm9sbFwiLFxuICBwYXVzZVNjcm9sbDogXCJQYXVzZSBhdXRvIHNjcm9sbFwiXG59O1xuXG5mdW5jdGlvbiBBdXRvU2Nyb2xsKFNwbGlkZTIsIENvbXBvbmVudHMyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgb24sIG9mZiwgYmluZCwgdW5iaW5kIH0gPSBFdmVudEludGVyZmFjZShTcGxpZGUyKTtcbiAgY29uc3QgeyB0cmFuc2xhdGUsIGdldFBvc2l0aW9uLCB0b0luZGV4LCBnZXRMaW1pdCB9ID0gQ29tcG9uZW50czIuTW92ZTtcbiAgY29uc3QgeyBzZXRJbmRleCwgZ2V0SW5kZXggfSA9IENvbXBvbmVudHMyLkNvbnRyb2xsZXI7XG4gIGNvbnN0IHsgb3JpZW50IH0gPSBDb21wb25lbnRzMi5EaXJlY3Rpb247XG4gIGNvbnN0IHsgdG9nZ2xlIH0gPSBDb21wb25lbnRzMi5FbGVtZW50cztcbiAgY29uc3QgeyBMaXZlIH0gPSBDb21wb25lbnRzMjtcbiAgY29uc3QgeyByb290IH0gPSBTcGxpZGUyO1xuICBjb25zdCB0aHJvdHRsZWRVcGRhdGVBcnJvd3MgPSBUaHJvdHRsZShDb21wb25lbnRzMi5BcnJvd3MudXBkYXRlLCA1MDApO1xuICBsZXQgYXV0b1Njcm9sbE9wdGlvbnMgPSB7fTtcbiAgbGV0IGludGVydmFsO1xuICBsZXQgc3RvcHBlZDtcbiAgbGV0IGhvdmVyZWQ7XG4gIGxldCBmb2N1c2VkO1xuICBsZXQgYnVzeTtcbiAgbGV0IGN1cnJQb3NpdGlvbjtcbiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgY29uc3QgeyBhdXRvU2Nyb2xsIH0gPSBvcHRpb25zO1xuICAgIGF1dG9TY3JvbGxPcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUUywgaXNPYmplY3QoYXV0b1Njcm9sbCkgPyBhdXRvU2Nyb2xsIDoge30pO1xuICB9XG4gIGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGlmICghU3BsaWRlMi5pcyhGQURFKSkge1xuICAgICAgaWYgKCFpbnRlcnZhbCAmJiBvcHRpb25zLmF1dG9TY3JvbGwgIT09IGZhbHNlKSB7XG4gICAgICAgIGludGVydmFsID0gUmVxdWVzdEludGVydmFsKDAsIG1vdmUpO1xuICAgICAgICBsaXN0ZW4oKTtcbiAgICAgICAgYXV0b1N0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKGludGVydmFsKSB7XG4gICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcbiAgICAgIGludGVydmFsID0gbnVsbDtcbiAgICAgIGN1cnJQb3NpdGlvbiA9IHZvaWQgMDtcbiAgICAgIG9mZihbRVZFTlRfTU9WRSwgRVZFTlRfRFJBRywgRVZFTlRfU0NST0xMLCBFVkVOVF9NT1ZFRCwgRVZFTlRfU0NST0xMRURdKTtcbiAgICAgIHVuYmluZChyb290LCBcIm1vdXNlZW50ZXIgbW91c2VsZWF2ZSBmb2N1c2luIGZvY3Vzb3V0XCIpO1xuICAgICAgdW5iaW5kKHRvZ2dsZSwgXCJjbGlja1wiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgIGlmIChhdXRvU2Nyb2xsT3B0aW9ucy5wYXVzZU9uSG92ZXIpIHtcbiAgICAgIGJpbmQocm9vdCwgXCJtb3VzZWVudGVyIG1vdXNlbGVhdmVcIiwgKGUpID0+IHtcbiAgICAgICAgaG92ZXJlZCA9IGUudHlwZSA9PT0gXCJtb3VzZWVudGVyXCI7XG4gICAgICAgIGF1dG9Ub2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYXV0b1Njcm9sbE9wdGlvbnMucGF1c2VPbkZvY3VzKSB7XG4gICAgICBiaW5kKHJvb3QsIFwiZm9jdXNpbiBmb2N1c291dFwiLCAoZSkgPT4ge1xuICAgICAgICBmb2N1c2VkID0gZS50eXBlID09PSBcImZvY3VzaW5cIjtcbiAgICAgICAgYXV0b1RvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhdXRvU2Nyb2xsT3B0aW9ucy51c2VUb2dnbGVCdXR0b24pIHtcbiAgICAgIGJpbmQodG9nZ2xlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgc3RvcHBlZCA/IHBsYXkoKSA6IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgb24oRVZFTlRfVVBEQVRFRCwgdXBkYXRlKTtcbiAgICBvbihbRVZFTlRfTU9WRSwgRVZFTlRfRFJBRywgRVZFTlRfU0NST0xMXSwgKCkgPT4ge1xuICAgICAgYnVzeSA9IHRydWU7XG4gICAgICBwYXVzZShmYWxzZSk7XG4gICAgfSk7XG4gICAgb24oW0VWRU5UX01PVkVELCBFVkVOVF9EUkFHR0VELCBFVkVOVF9TQ1JPTExFRF0sICgpID0+IHtcbiAgICAgIGJ1c3kgPSBmYWxzZTtcbiAgICAgIGF1dG9Ub2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgY29uc3QgeyBhdXRvU2Nyb2xsIH0gPSBvcHRpb25zO1xuICAgIGlmIChhdXRvU2Nyb2xsICE9PSBmYWxzZSkge1xuICAgICAgYXV0b1Njcm9sbE9wdGlvbnMgPSBhc3NpZ24oe30sIGF1dG9TY3JvbGxPcHRpb25zLCBpc09iamVjdChhdXRvU2Nyb2xsKSA/IGF1dG9TY3JvbGwgOiB7fSk7XG4gICAgICBtb3VudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0cm95KCk7XG4gICAgfVxuICAgIGlmIChpbnRlcnZhbCAmJiAhaXNVbmRlZmluZWQoY3VyclBvc2l0aW9uKSkge1xuICAgICAgdHJhbnNsYXRlKGN1cnJQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGF1dG9TdGFydCgpIHtcbiAgICBpZiAoYXV0b1Njcm9sbE9wdGlvbnMuYXV0b1N0YXJ0KSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHBsYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbmQod2luZG93LCBcImxvYWRcIiwgcGxheSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgaWYgKGlzUGF1c2VkKCkpIHtcbiAgICAgIGludGVydmFsLnN0YXJ0KHRydWUpO1xuICAgICAgTGl2ZS5kaXNhYmxlKHRydWUpO1xuICAgICAgZm9jdXNlZCA9IGhvdmVyZWQgPSBzdG9wcGVkID0gZmFsc2U7XG4gICAgICB1cGRhdGVCdXR0b24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2Uoc3RvcCA9IHRydWUpIHtcbiAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgIHN0b3BwZWQgPSBzdG9wO1xuICAgICAgdXBkYXRlQnV0dG9uKCk7XG4gICAgICBpZiAoIWlzUGF1c2VkKCkpIHtcbiAgICAgICAgaW50ZXJ2YWwucGF1c2UoKTtcbiAgICAgICAgTGl2ZS5kaXNhYmxlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXV0b1RvZ2dsZSgpIHtcbiAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgIGhvdmVyZWQgfHwgZm9jdXNlZCB8fCBidXN5ID8gcGF1c2UoZmFsc2UpIDogcGxheSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtb3ZlKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zaXRpb24oKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGNvbXB1dGVEZXN0aW5hdGlvbihwb3NpdGlvbik7XG4gICAgaWYgKHBvc2l0aW9uICE9PSBkZXN0aW5hdGlvbikge1xuICAgICAgdHJhbnNsYXRlKGRlc3RpbmF0aW9uKTtcbiAgICAgIHVwZGF0ZUluZGV4KGN1cnJQb3NpdGlvbiA9IGdldFBvc2l0aW9uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXVzZShmYWxzZSk7XG4gICAgICBpZiAoYXV0b1Njcm9sbE9wdGlvbnMucmV3aW5kKSB7XG4gICAgICAgIFNwbGlkZTIuZ28oYXV0b1Njcm9sbE9wdGlvbnMuc3BlZWQgPiAwID8gMCA6IENvbXBvbmVudHMyLkNvbnRyb2xsZXIuZ2V0RW5kKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdHRsZWRVcGRhdGVBcnJvd3MoKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlRGVzdGluYXRpb24ocG9zaXRpb24pIHtcbiAgICBjb25zdCBzcGVlZCA9IGF1dG9TY3JvbGxPcHRpb25zLnNwZWVkIHx8IDE7XG4gICAgcG9zaXRpb24gKz0gb3JpZW50KHNwZWVkKTtcbiAgICBpZiAoU3BsaWRlMi5pcyhTTElERSkpIHtcbiAgICAgIHBvc2l0aW9uID0gY2xhbXAocG9zaXRpb24sIGdldExpbWl0KGZhbHNlKSwgZ2V0TGltaXQodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlSW5kZXgocG9zaXRpb24pIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gU3BsaWRlMjtcbiAgICBjb25zdCBpbmRleCA9ICh0b0luZGV4KHBvc2l0aW9uKSArIGxlbmd0aCkgJSBsZW5ndGg7XG4gICAgaWYgKGluZGV4ICE9PSBnZXRJbmRleCgpKSB7XG4gICAgICBzZXRJbmRleChpbmRleCk7XG4gICAgICBDb21wb25lbnRzMi5TbGlkZXMudXBkYXRlKCk7XG4gICAgICBDb21wb25lbnRzMi5QYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgb3B0aW9ucy5sYXp5TG9hZCA9PT0gXCJuZWFyYnlcIiAmJiBDb21wb25lbnRzMi5MYXp5TG9hZC5jaGVjaygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVCdXR0b24oKSB7XG4gICAgaWYgKHRvZ2dsZSkge1xuICAgICAgY29uc3Qga2V5ID0gc3RvcHBlZCA/IFwic3RhcnRTY3JvbGxcIiA6IFwicGF1c2VTY3JvbGxcIjtcbiAgICAgIHRvZ2dsZUNsYXNzKHRvZ2dsZSwgQ0xBU1NfQUNUSVZFLCAhc3RvcHBlZCk7XG4gICAgICBzZXRBdHRyaWJ1dGUodG9nZ2xlLCBcImFyaWEtbGFiZWxcIiwgb3B0aW9ucy5pMThuW2tleV0gfHwgSTE4TltrZXldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuICFpbnRlcnZhbCB8fCBpbnRlcnZhbC5pc1BhdXNlZCgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2V0dXAsXG4gICAgbW91bnQsXG4gICAgZGVzdHJveSxcbiAgICBwbGF5LFxuICAgIHBhdXNlLFxuICAgIGlzUGF1c2VkXG4gIH07XG59XG5cbmV4cG9ydCB7IEF1dG9TY3JvbGwgfTtcbiJdLCJuYW1lcyI6WyJlbXB0eSIsImFycmF5IiwibGVuZ3RoIiwic2xpY2UkMSIsImFycmF5TGlrZSIsInN0YXJ0IiwiZW5kIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcHBseSQxIiwiZnVuYyIsImJpbmQiLCJhcHBseSIsImNvbmNhdCIsImFyZ3VtZW50cyIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInR5cGVPZiQxIiwidHlwZSIsInN1YmplY3QiLCJpc0FycmF5JDEiLCJpc0FycmF5IiwidG9BcnJheSQxIiwidmFsdWUiLCJmb3JFYWNoJDEiLCJ2YWx1ZXMiLCJpdGVyYXRlZSIsImZvckVhY2giLCJvd25LZXlzJDEiLCJPYmplY3QiLCJrZXlzIiwiZm9yT3duJDEiLCJvYmplY3QiLCJyaWdodCIsInJldmVyc2UiLCJpIiwia2V5IiwiYXNzaWduJDEiLCJzb3VyY2UiLCJtaW4kMSIsIk1hdGgiLCJtaW4iLCJFdmVudEJpbmRlciIsImxpc3RlbmVycyIsInRhcmdldHMiLCJldmVudHMiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJmb3JFYWNoRXZlbnQiLCJ0YXJnZXQiLCJldmVudCIsIm5hbWVzcGFjZSIsImlzRXZlbnRUYXJnZXQiLCJyZW1vdmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwdXNoIiwidW5iaW5kIiwiZmlsdGVyIiwibGlzdGVuZXIiLCJkaXNwYXRjaCIsImRldGFpbCIsImUiLCJidWJibGVzIiwiQ3VzdG9tRXZlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50czIiLCJzcGxpdCIsImV2ZW50TlMiLCJmcmFnbWVudCIsImRlc3Ryb3kiLCJkYXRhIiwiRVZFTlRfTU9WRSIsIkVWRU5UX01PVkVEIiwiRVZFTlRfVVBEQVRFRCIsIkVWRU5UX0RSQUciLCJFVkVOVF9EUkFHR0VEIiwiRVZFTlRfU0NST0xMIiwiRVZFTlRfU0NST0xMRUQiLCJFVkVOVF9ERVNUUk9ZIiwiRXZlbnRJbnRlcmZhY2UiLCJTcGxpZGUyIiwiYnVzIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImJpbmRlciIsIm9uIiwiam9pbiIsImVtaXQiLCJvZmYiLCJSZXF1ZXN0SW50ZXJ2YWwiLCJpbnRlcnZhbCIsIm9uSW50ZXJ2YWwiLCJvblVwZGF0ZSIsImxpbWl0Iiwibm93IiwiRGF0ZSIsInN0YXJ0VGltZSIsInJhdGUiLCJpZCIsInBhdXNlZCIsImNvdW50IiwidXBkYXRlIiwicGF1c2UiLCJyZXN1bWUiLCJjYW5jZWwiLCJyZXdpbmQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNldCIsInRpbWUiLCJpc1BhdXNlZCIsIlRocm90dGxlIiwiZHVyYXRpb24iLCJ0aHJvdHRsZWQiLCJDTEFTU19BQ1RJVkUiLCJTTElERSIsIkZBREUiLCJ0eXBlT2YiLCJpc09iamVjdCIsImlzTnVsbCIsImlzVW5kZWZpbmVkIiwidG9BcnJheSIsInRvZ2dsZUNsYXNzIiwiZWxtIiwiY2xhc3NlcyIsImFkZCIsIm5hbWUiLCJjbGFzc0xpc3QiLCJvd25LZXlzIiwiZm9yT3duIiwiYXNzaWduIiwicmVtb3ZlQXR0cmlidXRlIiwiZWxtcyIsImF0dHJzIiwiYXR0ciIsInNldEF0dHJpYnV0ZSIsInZhbHVlMiIsIlN0cmluZyIsIm1heCIsImZsb29yIiwiY2VpbCIsImFicyIsImNsYW1wIiwibnVtYmVyIiwieCIsInkiLCJtaW5pbXVtIiwibWF4aW11bSIsIkRFRkFVTFRTIiwic3BlZWQiLCJhdXRvU3RhcnQiLCJwYXVzZU9uSG92ZXIiLCJwYXVzZU9uRm9jdXMiLCJJMThOIiwic3RhcnRTY3JvbGwiLCJwYXVzZVNjcm9sbCIsIkF1dG9TY3JvbGwiLCJDb21wb25lbnRzMiIsInRyYW5zbGF0ZSIsImdldFBvc2l0aW9uIiwidG9JbmRleCIsImdldExpbWl0IiwiTW92ZSIsInNldEluZGV4IiwiZ2V0SW5kZXgiLCJDb250cm9sbGVyIiwib3JpZW50IiwiRGlyZWN0aW9uIiwidG9nZ2xlIiwiRWxlbWVudHMiLCJMaXZlIiwicm9vdCIsInRocm90dGxlZFVwZGF0ZUFycm93cyIsIkFycm93cyIsImF1dG9TY3JvbGxPcHRpb25zIiwic3RvcHBlZCIsImhvdmVyZWQiLCJmb2N1c2VkIiwiYnVzeSIsImN1cnJQb3NpdGlvbiIsInNldHVwIiwiYXV0b1Njcm9sbCIsIm1vdW50IiwiaXMiLCJtb3ZlIiwibGlzdGVuIiwiYXV0b1RvZ2dsZSIsInVzZVRvZ2dsZUJ1dHRvbiIsInBsYXkiLCJyZWFkeVN0YXRlIiwid2luZG93IiwiZGlzYWJsZSIsInVwZGF0ZUJ1dHRvbiIsInN0b3AiLCJwb3NpdGlvbiIsImRlc3RpbmF0aW9uIiwiY29tcHV0ZURlc3RpbmF0aW9uIiwidXBkYXRlSW5kZXgiLCJnbyIsImdldEVuZCIsImluZGV4IiwiU2xpZGVzIiwiUGFnaW5hdGlvbiIsImxhenlMb2FkIiwiTGF6eUxvYWQiLCJjaGVjayIsImkxOG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@splidejs/splide-extension-auto-scroll/dist/js/splide-extension-auto-scroll.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@splidejs/splide/dist/css/splide.min.css":
/*!***************************************************************!*\
  !*** ./node_modules/@splidejs/splide/dist/css/splide.min.css ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"9c256ac79696\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS9kaXN0L2Nzcy9zcGxpZGUubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpbnRvLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9jc3Mvc3BsaWRlLm1pbi5jc3M/MDljYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjljMjU2YWM3OTY5NlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@splidejs/splide/dist/css/splide.min.css\n");

/***/ })

};
;